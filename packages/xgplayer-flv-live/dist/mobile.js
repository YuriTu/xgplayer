<<<<<<< HEAD
!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("xgplayer")):"function"==typeof define&&define.amd?define(["xgplayer"],n):"object"==typeof exports?exports["xgplayer-flv"]=n(require("xgplayer")):e["xgplayer-flv"]=n(e.xgplayer)}(window,(function(__WEBPACK_EXTERNAL_MODULE_xgplayer__){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(r,i,function(n){return e[n]}.bind(null,i));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=1)}({"../../node_modules/events/events.js":
/*!*******************************************************************************************!*\
  !*** /Users/jiangyuqing/Desktop/Projects/devspace/xgplayer/node_modules/events/events.js ***!
  \*******************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\n\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function () {\n    return defaultMaxListeners;\n  },\n  set: function (arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function () {\n\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = type === 'error';\n\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined) return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = this._events;\n  if (events === undefined) return this;\n\n  list = events[type];\n  if (list === undefined) return this;\n\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n\n    if (list.length === 1) events[type] = list[0];\n\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n\n  return this;\n};\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined) return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n//# sourceURL=webpack://xgplayer-flv//Users/jiangyuqing/Desktop/Projects/devspace/xgplayer/node_modules/events/events.js?")},"../xgplayer-buffer/index.js":
/*!***********************************!*\
  !*** ../xgplayer-buffer/index.js ***!
  \***********************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = {\n  Track: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").default,\n  Tracks: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").Tracks,\n  AudioTrack: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").AudioTrack,\n  VideoTrack: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").VideoTrack,\n\n  XgBuffer: __webpack_require__(/*! ./src/buffer */ "../xgplayer-buffer/src/buffer.js").XgBuffer,\n  RemuxBuffer: __webpack_require__(/*! ./src/buffer */ "../xgplayer-buffer/src/buffer.js").RemuxBuffer,\n\n  PreSource: __webpack_require__(/*! ./src/presouce */ "../xgplayer-buffer/src/presouce.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/index.js?')},"../xgplayer-buffer/src/buffer.js":
/*!****************************************!*\
  !*** ../xgplayer-buffer/src/buffer.js ***!
  \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nlet XgBuffer = exports.XgBuffer = function () {\n  /**\n   * A buffer to store loaded data.\n   *\n   * @class LoaderBuffer\n   * @param {number} length - Optional the buffer size\n   */\n  function XgBuffer(length) {\n    _classCallCheck(this, XgBuffer);\n\n    this.length = length || 0;\n    this.historyLen = length || 0;\n    this.array = [];\n    this.offset = 0;\n  }\n\n  /**\n   * The function to push data.\n   *\n   * @param {number} data - The data to push into the buffer\n   */\n\n\n  _createClass(XgBuffer, [{\n    key: "push",\n    value: function push(data) {\n      this.array.push(data);\n      this.length += data.byteLength;\n      this.historyLen += data.byteLength;\n    }\n\n    /**\n     * The function to shift data.\n     *\n     * @param {number} length - The size of shift.\n     */\n\n  }, {\n    key: "shift",\n    value: function shift(length) {\n      if (this.array.length < 1) {\n        return new Uint8Array(0);\n      }\n\n      if (length === undefined) {\n        return this._shiftBuffer();\n      }\n      if (this.offset + length === this.array[0].length) {\n        let ret = this.array[0].slice(this.offset, this.offset + length);\n        this.offset = 0;\n        this.array.shift();\n        this.length -= length;\n        return ret;\n      }\n\n      if (this.offset + length < this.array[0].length) {\n        let ret = this.array[0].slice(this.offset, this.offset + length);\n        this.offset += length;\n        this.length -= length;\n        return ret;\n      }\n\n      let ret = new Uint8Array(length);\n      let tmpoff = 0;\n      while (this.array.length > 0 && length > 0) {\n        if (this.offset + length < this.array[0].length) {\n          let tmp = this.array[0].slice(this.offset, this.offset + length);\n          ret.set(tmp, tmpoff);\n          this.offset += length;\n          this.length -= length;\n          length = 0;\n          break;\n        } else {\n          let templength = this.array[0].length - this.offset;\n          ret.set(this.array[0].slice(this.offset, this.array[0].length), tmpoff);\n          this.array.shift();\n          this.offset = 0;\n          tmpoff += templength;\n          this.length -= templength;\n          length -= templength;\n        }\n      }\n      return ret;\n    }\n\n    /**\n     * Function to clear the buffer.\n     */\n\n  }, {\n    key: "clear",\n    value: function clear() {\n      this.array = [];\n      this.length = 0;\n      this.offset = 0;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this.clear();\n      this.historyLen = 0;\n    }\n\n    /**\n     * Function to shift one unit8Array.\n     */\n\n  }, {\n    key: "_shiftBuffer",\n    value: function _shiftBuffer() {\n      this.length -= this.array[0].length;\n      this.offset = 0;\n      return this.array.shift();\n    }\n\n    /**\n     * Convert uint8 data to number.\n     *\n     * @param {number} start - the start postion.\n     * @param {number} length - the length of data.\n     */\n\n  }, {\n    key: "toInt",\n    value: function toInt(start, length) {\n      let retInt = 0;\n      let i = this.offset + start;\n      while (i < this.offset + length + start) {\n        if (i < this.array[0].length) {\n          retInt = retInt * 256 + this.array[0][i];\n        } else if (this.array[1]) {\n          retInt = retInt * 256 + this.array[1][i - this.array[0].length];\n        }\n\n        i++;\n      }\n      return retInt;\n    }\n  }]);\n\n  return XgBuffer;\n}();\n\nlet RemuxBuffer = exports.RemuxBuffer = function () {\n  function RemuxBuffer() {\n    _classCallCheck(this, RemuxBuffer);\n\n    this.video = [];\n    this.audio = [];\n  }\n\n  _createClass(RemuxBuffer, [{\n    key: "destroy",\n    value: function destroy() {\n      this.video = [];\n      this.audio = [];\n    }\n  }]);\n\n  return RemuxBuffer;\n}();\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/src/buffer.js?')},"../xgplayer-buffer/src/presouce.js":
/*!******************************************!*\
  !*** ../xgplayer-buffer/src/presouce.js ***!
  \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet Source = function Source() {\n  _classCallCheck(this, Source);\n\n  this.mimetype = '';\n  this.init = null;\n  this.data = [];\n};\n\nlet PreSource = function () {\n  function PreSource() {\n    _classCallCheck(this, PreSource);\n\n    this.sources = {};\n  }\n\n  _createClass(PreSource, [{\n    key: 'getSource',\n    value: function getSource(source) {\n      return this.sources[source];\n    }\n  }, {\n    key: 'createSource',\n    value: function createSource(name) {\n      this.sources[name] = new Source();\n      return this.sources[name];\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.sources = {};\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.sources = {};\n    }\n  }]);\n\n  return PreSource;\n}();\n\nexports.default = PreSource;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/src/presouce.js?")},"../xgplayer-buffer/src/track.js":
/*!***************************************!*\
  !*** ../xgplayer-buffer/src/track.js ***!
  \***************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet Track = function () {\n  /**\n   * The constructor.\n   */\n  function Track() {\n    _classCallCheck(this, Track);\n\n    this.id = -1;\n    this.sequenceNumber = 0;\n    this.samples = [];\n    this.droppedSamples = [];\n    this.length = 0;\n  }\n\n  /**\n   * Reset the track.\n   */\n\n\n  _createClass(Track, [{\n    key: 'reset',\n    value: function reset() {\n      this.sequenceNumber = 0;\n      this.samples = [];\n      this.length = 0;\n    }\n    /**\n     * destroy the track.\n     */\n\n  }, {\n    key: 'distroy',\n    value: function distroy() {\n      this.reset();\n      this.id = -1;\n    }\n  }]);\n\n  return Track;\n}();\n\nexports.default = Track;\n\nlet AudioTrack = exports.AudioTrack = function (_Track) {\n  _inherits(AudioTrack, _Track);\n\n  /**\n   * The constructor for audio track.\n   */\n  function AudioTrack() {\n    _classCallCheck(this, AudioTrack);\n\n    var _this = _possibleConstructorReturn(this, (AudioTrack.__proto__ || Object.getPrototypeOf(AudioTrack)).call(this));\n\n    _this.TAG = 'AudioTrack';\n    _this.type = 'audio';\n    return _this;\n  }\n\n  return AudioTrack;\n}(Track);\n\nlet VideoTrack = exports.VideoTrack = function (_Track2) {\n  _inherits(VideoTrack, _Track2);\n\n  /**\n   * The constructor for video track.\n   */\n  function VideoTrack() {\n    _classCallCheck(this, VideoTrack);\n\n    var _this2 = _possibleConstructorReturn(this, (VideoTrack.__proto__ || Object.getPrototypeOf(VideoTrack)).call(this));\n\n    _this2.TAG = 'VideoTrack';\n    _this2.type = 'video';\n    _this2.dropped = 0;\n    return _this2;\n  }\n  /**\n   * reset the video track.\n   */\n\n\n  _createClass(VideoTrack, [{\n    key: 'reset',\n    value: function reset() {\n      this.sequenceNumber = 0;\n      this.samples = [];\n      this.length = 0;\n      this.dropped = 0;\n    }\n  }]);\n\n  return VideoTrack;\n}(Track);\n\nlet Tracks = exports.Tracks = function () {\n  function Tracks() {\n    _classCallCheck(this, Tracks);\n\n    this.audioTrack = null;\n    this.videoTrack = null;\n  }\n\n  _createClass(Tracks, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.audioTrack = null;\n      this.videoTrack = null;\n    }\n  }]);\n\n  return Tracks;\n}();\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/src/track.js?")},"../xgplayer-codec/index.js":
/*!**********************************!*\
  !*** ../xgplayer-codec/index.js ***!
  \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = {\n  Nalunit: __webpack_require__(/*! ./src/h264/nalunit */ "../xgplayer-codec/src/h264/nalunit/index.js").default,\n  SpsParser: __webpack_require__(/*! ./src/h264/nalunit/sps */ "../xgplayer-codec/src/h264/nalunit/sps.js").default,\n\n  Compatibility: __webpack_require__(/*! ./src/compatibility */ "../xgplayer-codec/src/compatibility.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/index.js?')},"../xgplayer-codec/src/aac/aac-helper.js":
/*!***********************************************!*\
  !*** ../xgplayer-codec/src/aac/aac-helper.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nlet AAC = function () {\n  function AAC() {\n    _classCallCheck(this, AAC);\n  }\n\n  _createClass(AAC, null, [{\n    key: \'getSilentFrame\',\n    value: function getSilentFrame(codec, channelCount) {\n      if (codec === \'mp4a.40.2\') {\n        // handle LC-AAC\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n      } else {\n        // handle HE-AAC (mp4a.40.5 / mp4a.40.29)\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        }\n      }\n      return null;\n    }\n  }]);\n\n  return AAC;\n}();\n\nexports.default = AAC;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/aac/aac-helper.js?')},"../xgplayer-codec/src/compatibility.js":
/*!**********************************************!*\
  !*** ../xgplayer-codec/src/compatibility.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _aacHelper = __webpack_require__(/*! ./aac/aac-helper */ \"../xgplayer-codec/src/aac/aac-helper.js\");\n\nvar _aacHelper2 = _interopRequireDefault(_aacHelper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nconst { REMUX_EVENTS, DEMUX_EVENTS } = _xgplayerUtils.EVENTS;\n\nlet Compatibility = function () {\n  function Compatibility() {\n    _classCallCheck(this, Compatibility);\n\n    this.nextAudioDts = 0; // 模拟下一段音频数据的dts\n    this.nextVideoDts = 0; // 模拟下一段视频数据的dts\n\n    this.lastAudioSamplesLen = 0; // 上一段音频数据的长度\n    this.lastVideoSamplesLen = 0; // 上一段视频数据的长度\n\n    this.lastVideoDts = undefined; // 上一段音频数据的长度\n    this.lastAudioDts = undefined; // 上一段视频数据的长度\n\n    this.allAudioSamplesCount = 0; // 音频总数据量(原始帧)\n    this.allVideoSamplesCount = 0; // 视频总数据量(原始帧)\n\n    this._firstAudioSample = null;\n    this._firstVideoSample = null;\n\n    this.filledAudioSamples = []; // 补充音频帧（）\n    this.filledVideoSamples = []; // 补充视频帧（）\n\n    this._videoLargeGap = 0;\n    this._audioLargeGap = 0;\n  }\n\n  _createClass(Compatibility, [{\n    key: 'init',\n    value: function init() {\n      this.before(REMUX_EVENTS.REMUX_MEDIA, this.doFix.bind(this));\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.nextAudioDts = null; // 估算下一段音频数据的dts\n      this.nextVideoDts = null; // 估算下一段视频数据的dts\n\n      this.lastAudioSamplesLen = 0; // 上一段音频数据的长度\n      this.lastVideoSamplesLen = 0; // 上一段视频数据的长度\n\n      this.lastVideoDts = undefined; // 上一段音频数据的长度\n      this.lastAudioDts = undefined; // 上一段视频数据的长度\n\n      // this.allAudioSamplesCount = 0 // 音频总数据量(原始帧)\n      // this.allVideoSamplesCount = 0 // 视频总数据量(原始帧)\n\n      // this._firstAudioSample = null\n      // this._firstVideoSample = null\n\n      this.filledAudioSamples = []; // 补充音频帧（）\n      this.filledVideoSamples = []; // 补充视频帧（）\n    }\n  }, {\n    key: 'doFix',\n    value: function doFix() {\n      const { isFirstAudioSamples, isFirstVideoSamples } = this.getFirstSample();\n\n      // this.removeInvalidSamples()\n\n      this.recordSamplesCount();\n\n      if (this._firstVideoSample) {\n        this.fixRefSampleDuration(this.videoTrack.meta, this.videoTrack.samples);\n      }\n      if (this._firstAudioSample) {\n        this.fixRefSampleDuration(this.audioTrack.meta, this.audioTrack.samples);\n      }\n\n      const { changed: videoChanged, changedIdx: videoChangedIdx } = Compatibility.detactChangeStream(this.videoTrack.samples);\n      if (videoChanged && !isFirstAudioSamples) {\n        this.fixChangeStreamVideo(videoChangedIdx);\n      } else {\n        this.doFixVideo(isFirstVideoSamples);\n      }\n\n      const { changed: audioChanged, changedIdx: audioChangedIdx } = Compatibility.detactChangeStream(this.audioTrack.samples);\n      if (audioChanged) {\n        this.fixChangeStreamAudio(audioChangedIdx);\n      } else {\n        this.doFixAudio(isFirstAudioSamples);\n      }\n\n      // this.removeInvalidSamples()\n    }\n  }, {\n    key: 'doFixVideo',\n    value: function doFixVideo(first, streamChangeStart) {\n      let { samples: videoSamples, meta } = this.videoTrack;\n\n      if (meta.frameRate && meta.frameRate.fixed === false) {\n        return;\n      }\n\n      if (!videoSamples || !videoSamples.length || !this._firstVideoSample) {\n        return;\n      }\n\n      // console.log(`video lastSample, ${videoSamples[videoSamples.length - 1].dts}`)\n\n      const firstSample = videoSamples[0];\n\n      const samplesLen = videoSamples.length;\n\n      // step0.修复hls流出现巨大gap，需要强制重定位的问题\n      if (this._videoLargeGap > 0) {\n        Compatibility.doFixLargeGap(videoSamples, this._videoLargeGap);\n      }\n\n      if (firstSample.dts !== this._firstVideoSample.dts && (streamChangeStart || Compatibility.detectLargeGap(this.nextVideoDts, firstSample))) {\n        if (streamChangeStart) {\n          this.nextVideoDts = streamChangeStart; // FIX: Hls中途切codec，在如果直接seek到后面的点会导致largeGap计算失败\n        }\n\n        this._videoLargeGap = this.nextVideoDts - firstSample.dts;\n        Compatibility.doFixLargeGap(videoSamples, this._videoLargeGap);\n      }\n\n      const firstDts = firstSample.dts;\n\n      // step1. 修复与audio首帧差距太大的问题\n      if (first && this._firstAudioSample) {\n        const videoFirstDts = this._firstVideoSample.dts;\n        const audioFirstDts = this._firstAudioSample.dts;\n        const gap = videoFirstDts - audioFirstDts;\n        if (gap > 2 * meta.refSampleDuration) {\n          const fillCount = Math.floor(gap / meta.refSampleDuration);\n\n          for (let i = 0; i < fillCount; i++) {\n            const clonedFirstSample = Object.assign({}, firstSample); // 视频头部帧缺失需要复制第一帧\n            // 重新计算sample的dts和pts\n            clonedFirstSample.dts = videoFirstDts - (i + 1) * meta.refSampleDuration;\n            clonedFirstSample.pts = clonedFirstSample.dts + clonedFirstSample.cts;\n\n            videoSamples.unshift(clonedFirstSample);\n\n            this.filledVideoSamples.push({\n              dts: clonedFirstSample.dts,\n              size: clonedFirstSample.data.byteLength\n            });\n          }\n        }\n      }\n\n      let gap;\n      // step2. 修复samples段之间的间距问题、\n      if (this.nextVideoDts) {\n        // step1. 处理samples段之间的丢帧情况\n        // 当发现duration差距大于2帧时进行补帧\n        gap = firstDts - this.nextVideoDts;\n        const absGap = Math.abs(gap);\n        if (gap > 2 * meta.refSampleDuration) {\n          const fillFrameCount = Math.floor(gap / meta.refSampleDuration);\n\n          for (let i = 0; i < fillFrameCount; i++) {\n            const clonedSample = Object.assign({}, videoSamples[0]);\n            const computed = firstDts - (i + 1) * meta.refSampleDuration;\n\n            clonedSample.dts = computed > this.nextVideoDts ? computed : this.nextVideoDts; // 补的第一帧一定要是nextVideoDts\n            clonedSample.pts = clonedSample.dts + clonedSample.cts;\n\n            this.videoTrack.samples.unshift(clonedSample);\n\n            this.filledVideoSamples.push({\n              dts: clonedSample.dts,\n              size: clonedSample.data.byteLength\n            });\n          }\n        } else if (absGap <= meta.refSampleDuration && absGap > 0) {\n          // 当差距在+-一帧之间时将第一帧的dts强行定位到期望位置\n          // console.log('重定位视频帧dts', videoSamples[0].dts, this.nextVideoDts)\n          videoSamples[0].dts = this.nextVideoDts;\n          videoSamples[0].originDts = videoSamples[0].dts;\n          videoSamples[0].cts = videoSamples[0].cts !== undefined ? videoSamples[0].cts : videoSamples[0].pts - videoSamples[0].dts;\n          videoSamples[0].pts = videoSamples[0].dts + videoSamples[0].cts;\n        } else if (gap < 0) {\n          // 出现大的gap\n          Compatibility.doFixLargeGap(videoSamples, -1 * gap);\n        }\n      }\n      const lastDts = videoSamples[videoSamples.length - 1].dts;\n\n      const lastSampleDuration = videoSamples.length >= 2 ? lastDts - videoSamples[videoSamples.length - 2].dts : meta.refSampleDuration;\n\n      this.lastVideoSamplesLen = samplesLen;\n      this.nextVideoDts = lastDts + lastSampleDuration;\n      this.lastVideoDts = lastDts;\n\n      // step2. 修复sample段之内的间距问题\n      // step3. 修复samples段内部的dts异常问题\n      for (let i = 0, len = videoSamples.length; i < len; i++) {\n        const current = videoSamples[i];\n        const next = videoSamples[i + 1];\n\n        if (!next) {\n          break;\n        }\n\n        const duration = next.dts - current.dts;\n\n        if (duration > 2 * meta.refSampleDuration) {\n          // 两帧之间间隔太大，需要补空白帧\n          let fillFrameCount = Math.floor(duration / meta.refSampleDuration);\n\n          let fillFrameIdx = 0;\n          while (fillFrameIdx < fillFrameCount) {\n            const fillFrame = Object.assign({}, next);\n            fillFrame.dts = current.dts + (fillFrameIdx + 1) * meta.refSampleDuration;\n            fillFrame.pts = fillFrame.dts + fillFrame.cts;\n            if (fillFrame < next.dts) {\n              videoSamples.splice(i, 0, fillFrame);\n\n              this.filledVideoSamples.push({\n                dts: fillFrame.dts,\n                size: fillFrame.data.byteLength\n              });\n            }\n\n            fillFrameIdx++;\n            i++;\n          }\n        }\n      }\n\n      this.videoTrack.samples = videoSamples;\n    }\n  }, {\n    key: 'doFixAudio',\n    value: function doFixAudio(first, streamChangeStart) {\n      let { samples: audioSamples, meta } = this.audioTrack;\n\n      if (!audioSamples || !audioSamples.length) {\n        return;\n      }\n      // console.log(`audio lastSample, ${audioSamples[audioSamples.length - 1].dts}`)\n\n      const samplesLen = audioSamples.length;\n      const silentFrame = _aacHelper2.default.getSilentFrame(meta.codec, meta.channelCount);\n\n      const firstSample = this._firstAudioSample;\n\n      const _firstSample = audioSamples[0];\n      // 对audioSamples按照dts做排序\n      // audioSamples = Compatibility.sortAudioSamples(audioSamples)\n      if (this._audioLargeGap > 0) {\n        Compatibility.doFixLargeGap(audioSamples, this._audioLargeGap);\n      }\n\n      if (_firstSample.dts !== this._firstAudioSample.dts && (streamChangeStart || Compatibility.detectLargeGap(this.nextAudioDts, _firstSample))) {\n        if (streamChangeStart) {\n          this.nextAudioDts = streamChangeStart; // FIX: Hls中途切codec，在如果直接seek到后面的点会导致largeGap计算失败\n        }\n        this._audioLargeGap = this.nextAudioDts - _firstSample.dts;\n        Compatibility.doFixLargeGap(audioSamples, this._audioLargeGap);\n      }\n      // step0. 首帧与video首帧间距大的问题\n      if (this._firstVideoSample && first) {\n        const videoFirstPts = this._firstVideoSample.pts ? this._firstVideoSample.pts : this._firstVideoSample.dts + this._firstVideoSample.cts;\n\n        if (firstSample.dts - videoFirstPts > meta.refSampleDuration) {\n          const silentSampleCount = Math.floor((firstSample.dts - videoFirstPts) / meta.refSampleDuration);\n\n          for (let i = 0; i < silentSampleCount; i++) {\n            const silentSample = {\n              data: silentFrame,\n              datasize: silentFrame.byteLength,\n              dts: firstSample.dts - (i + 1) * meta.refSampleDuration,\n              filtered: 0\n            };\n\n            audioSamples.unshift(silentSample);\n\n            this.filledAudioSamples.push({\n              dts: silentSample.dts,\n              size: silentSample.data.byteLength\n            });\n          }\n        }\n      }\n\n      let gap;\n      const firstDts = audioSamples[0].dts;\n\n      if (this.nextAudioDts) {\n        // step1. 处理samples段之间的丢帧情况\n        // 当发现duration差距大于1帧时进行补帧\n        gap = firstDts - this.nextAudioDts;\n        const absGap = Math.abs(gap);\n\n        if (absGap > meta.refSampleDuration && samplesLen === 1 && this.lastAudioSamplesLen === 1) {\n          meta.refSampleDurationFixed = undefined;\n        }\n\n        if (gap > 2 * meta.refSampleDuration) {\n          if (samplesLen === 1 && this.lastAudioSamplesLen === 1) {\n            // 如果sample的length一直是1，而且一直不符合refSampleDuration，需要动态修改refSampleDuration\n            meta.refSampleDurationFixed = meta.refSampleDurationFixed !== undefined ? meta.refSampleDurationFixed + gap : meta.refSampleDuration + gap;\n          } else {\n            const silentFrameCount = Math.floor(gap / meta.refSampleDuration);\n\n            for (let i = 0; i < silentFrameCount; i++) {\n              const computed = firstDts - (i + 1) * meta.refSampleDuration;\n              const silentSample = Object.assign({}, audioSamples[0], {\n                dts: computed > this.nextAudioDts ? computed : this.nextAudioDts\n              });\n\n              this.filledAudioSamples.push({\n                dts: silentSample.dts,\n                size: silentSample.data.byteLength\n              });\n              this.audioTrack.samples.unshift(silentSample);\n            }\n          }\n        } else if (absGap <= meta.refSampleDuration && absGap > 0) {\n          // 当差距比较小的时候将音频帧重定位\n          // console.log('重定位音频帧dts', audioSamples[0].dts, this.nextAudioDts)\n          audioSamples[0].dts = this.nextAudioDts;\n          audioSamples[0].pts = this.nextAudioDts;\n        } else if (gap < 0) {\n          Compatibility.doFixLargeGap(audioSamples, -1 * gap);\n        }\n      }\n      const lastDts = audioSamples[audioSamples.length - 1].dts;\n      const lastSampleDuration = audioSamples.length >= 2 ? lastDts - audioSamples[audioSamples.length - 2].dts : meta.refSampleDuration;\n\n      this.lastAudioSamplesLen = samplesLen;\n      this.nextAudioDts = meta.refSampleDurationFixed ? lastDts + meta.refSampleDurationFixed : lastDts + lastSampleDuration;\n      this.lastAudioDts = lastDts;\n\n      // step3. 修复samples段内部的dts异常问题\n      for (let i = 0, len = audioSamples.length; i < len; i++) {\n        const current = audioSamples[i];\n        const next = audioSamples[i + 1];\n\n        if (!next) {\n          break;\n        }\n\n        const duration = next.dts - current.dts;\n        audioSamples[i].duration = duration;\n        /*\n        if (duration > (2 * meta.refSampleDuration)) {\n          // 两帧之间间隔太大，需要补空白帧\n          /**\n          let silentFrameCount = Math.floor(duration / meta.refSampleDuration)\n          let frameIdx = 0\n           while (frameIdx < silentFrameCount) {\n            const silentSample = {\n              data: silentFrame,\n              datasize: silentFrame.byteLength,\n              dts: current.dts + (frameIdx + 1) * meta.refSampleDuration,\n              filtered: 0,\n              isSilent: true\n            }\n             audioSamples.splice(i, 0, silentSample)\n             this.filledAudioSamples.push({\n              dts: silentSample.dts,\n              size: silentSample.data.byteLength\n            })\n             frameIdx++\n            i++ // 不对静音帧做比较\n          }\n        } */\n      }\n\n      this.audioTrack.samples = Compatibility.sortAudioSamples(audioSamples);\n    }\n  }, {\n    key: 'fixChangeStreamVideo',\n    value: function fixChangeStreamVideo(changeIdx) {\n      const { samples, meta } = this.videoTrack;\n      const prevDts = changeIdx === 0 ? this.getStreamChangeStart(samples[0]) : samples[changeIdx - 1].dts;\n      const curDts = samples[changeIdx].dts;\n      const isContinue = Math.abs(prevDts - curDts) <= 2 * meta.refSampleDuration;\n\n      if (isContinue) {\n        if (!samples[changeIdx].options) {\n          samples[changeIdx].options = {\n            isContinue: true\n          };\n        } else {\n          samples[changeIdx].options.isContinue = true;\n        }\n        return this.doFixVideo(false);\n      }\n\n      const firstPartSamples = samples.slice(0, changeIdx);\n      const secondPartSamples = samples.slice(changeIdx);\n      const firstSample = samples[0];\n\n      const changeSample = secondPartSamples[0];\n      const firstPartDuration = changeSample.dts - firstSample.dts;\n      const streamChangeStart = firstSample.options && firstSample.options.start + firstPartDuration ? firstSample.options.start : null;\n\n      this.videoTrack.samples = samples.slice(0, changeIdx);\n\n      this.doFixVideo(false);\n\n      this.videoTrack.samples = samples.slice(changeIdx);\n\n      this.doFixVideo(false, streamChangeStart);\n\n      this.videoTrack.samples = firstPartSamples.concat(secondPartSamples);\n    }\n  }, {\n    key: 'fixChangeStreamAudio',\n    value: function fixChangeStreamAudio(changeIdx) {\n      const { samples, meta } = this.audioTrack;\n\n      const prevDts = changeIdx === 0 ? this.getStreamChangeStart(samples[0]) : samples[changeIdx - 1].dts;\n      const curDts = samples[changeIdx].dts;\n      const isContinue = Math.abs(prevDts - curDts) <= 2 * meta.refSampleDuration;\n\n      if (isContinue) {\n        if (!samples[changeIdx].options) {\n          samples[changeIdx].options = {\n            isContinue: true\n          };\n        } else {\n          samples[changeIdx].options.isContinue = true;\n        }\n        return this.doFixAudio(false);\n      }\n\n      const firstPartSamples = samples.slice(0, changeIdx);\n      const secondPartSamples = samples.slice(changeIdx);\n      const firstSample = samples[0];\n\n      const changeSample = secondPartSamples[0];\n      const firstPartDuration = changeSample.dts - firstSample.dts;\n      const streamChangeStart = firstSample.options && firstSample.options.start + firstPartDuration ? firstSample.options.start : null;\n\n      this.audioTrack.samples = firstPartSamples;\n\n      this.doFixAudio(false);\n\n      this.audioTrack.samples = secondPartSamples;\n\n      this.doFixAudio(false, streamChangeStart);\n\n      this.audioTrack.samples = firstPartSamples.concat(secondPartSamples);\n    }\n  }, {\n    key: 'getFirstSample',\n    value: function getFirstSample() {\n      // 获取video和audio的首帧数据\n      let { samples: videoSamples } = this.videoTrack;\n      let { samples: audioSamples } = this.audioTrack;\n\n      let isFirstVideoSamples = false;\n      let isFirstAudioSamples = false;\n\n      if (!this._firstVideoSample && videoSamples.length) {\n        this._firstVideoSample = Compatibility.findFirstVideoSample(videoSamples);\n        isFirstVideoSamples = true;\n      }\n\n      if (!this._firstAudioSample && audioSamples.length) {\n        this._firstAudioSample = Compatibility.findFirstAudioSample(audioSamples); // 寻找dts最小的帧作为首个音频帧\n        isFirstAudioSamples = true;\n      }\n\n      return {\n        isFirstVideoSamples,\n        isFirstAudioSamples\n      };\n    }\n\n    /**\n     * 在没有refSampleDuration的问题流中，\n     */\n\n  }, {\n    key: 'fixRefSampleDuration',\n    value: function fixRefSampleDuration(meta, samples) {\n      const isVideo = meta.type === 'video';\n      const allSamplesCount = isVideo ? this.allVideoSamplesCount : this.allAudioSamplesCount;\n      const firstDts = isVideo ? this._firstVideoSample.dts : this._firstAudioSample.dts;\n      const filledSamplesCount = isVideo ? this.filledVideoSamples.length : this.filledAudioSamples.length;\n\n      if (!meta.refSampleDuration || meta.refSampleDuration <= 0 || Number.isNaN(meta.refSampleDuration)) {\n        if (samples.length >= 1) {\n          const lastDts = samples[samples.length - 1].dts;\n\n          meta.refSampleDuration = Math.floor((lastDts - firstDts) / (allSamplesCount + filledSamplesCount - 1)); // 将refSampleDuration重置为计算后的平均值\n        }\n      } else if (meta.refSampleDuration) {\n        if (samples.length >= 5) {\n          const lastDts = samples[samples.length - 1].dts;\n          const firstDts = samples[0].dts;\n          const durationAvg = (lastDts - firstDts) / (samples.length - 1);\n\n          meta.refSampleDuration = Math.floor(Math.abs(meta.refSampleDuration - durationAvg) <= 5 ? meta.refSampleDuration : durationAvg); // 将refSampleDuration重置为计算后的平均值\n        }\n      }\n    }\n\n    /**\n     * 记录截止目前一共播放了多少帧\n     */\n\n  }, {\n    key: 'recordSamplesCount',\n    value: function recordSamplesCount() {\n      const { audioTrack, videoTrack } = this;\n\n      this.allAudioSamplesCount += audioTrack.samples.length;\n      this.allVideoSamplesCount += videoTrack.samples.length;\n    }\n\n    /**\n     * 去除不合法的帧（倒退、重复帧）\n     */\n\n  }, {\n    key: 'removeInvalidSamples',\n    value: function removeInvalidSamples() {\n      const { _firstVideoSample, _firstAudioSample } = this;\n\n      this.audioTrack.samples = this.audioTrack.samples.filter(sample => {\n        return sample.dts >= _firstAudioSample.dts && (this.lastAudioDts === undefined || sample.dts > this.lastAudioDts);\n      });\n\n      this.videoTrack.samples = this.videoTrack.samples.filter(sample => {\n        return sample.dts >= _firstVideoSample.dts && (this.lastVideoDts === undefined || sample.dts > this.lastVideoDts);\n      });\n    }\n  }, {\n    key: 'getStreamChangeStart',\n    value: function getStreamChangeStart(sample) {\n      if (sample.options && sample.options.start) {\n        return sample.options.start - this.dtsBase;\n      }\n      return Infinity;\n    }\n  }, {\n    key: 'tracks',\n    get: function () {\n      return this._context.getInstance('TRACKS');\n    }\n  }, {\n    key: 'audioTrack',\n    get: function () {\n      if (this.tracks) {\n        return this.tracks.audioTrack;\n      }\n      return null;\n    }\n  }, {\n    key: 'videoTrack',\n    get: function () {\n      if (this.tracks) {\n        return this.tracks.videoTrack;\n      }\n      return null;\n    }\n  }, {\n    key: 'dtsBase',\n    get: function () {\n      const remuxer = this._context.getInstance('MP4_REMUXER');\n      if (remuxer) {\n        return remuxer._dtsBase;\n      }\n      return 0;\n    }\n  }], [{\n    key: 'sortAudioSamples',\n    value: function sortAudioSamples(samples) {\n      if (samples.length === 1) {\n        return samples;\n      }\n\n      return samples.sort((a, b) => {\n        return a.dts - b.dts;\n      });\n    }\n\n    /**\n     * 寻找dts最小的sample\n     * @param samples\n     */\n\n  }, {\n    key: 'findFirstAudioSample',\n    value: function findFirstAudioSample(samples) {\n      if (!samples || samples.length === 0) {\n        return null;\n      }\n\n      return Compatibility.sortAudioSamples(samples)[0];\n    }\n  }, {\n    key: 'findFirstVideoSample',\n    value: function findFirstVideoSample(samples) {\n      if (!samples.length) {\n        return null;\n      }\n\n      const sorted = samples.sort((a, b) => {\n        return a.dts - b.dts;\n      });\n\n      for (let i = 0, len = sorted.length; i < len; i++) {\n        if (sorted[i].isKeyframe) {\n          return sorted[i];\n        }\n      }\n    }\n  }, {\n    key: 'detectLargeGap',\n    value: function detectLargeGap(nextDts, firstSample) {\n      if (nextDts === null) {\n        return;\n      }\n      const curDts = firstSample.dts || 0;\n      const cond1 = nextDts - curDts >= 1000 || curDts - nextDts >= 1000; // fix hls流出现大量流dts间距问题\n      const cond2 = firstSample.options && firstSample.options.discontinue;\n\n      return cond1 || cond2;\n    }\n  }, {\n    key: 'doFixLargeGap',\n    value: function doFixLargeGap(samples, gap) {\n      for (let i = 0, len = samples.length; i < len; i++) {\n        const sample = samples[i];\n        sample.dts += gap;\n        if (sample.pts) {\n          sample.pts += gap;\n        }\n      }\n    }\n\n    /**\n     * 中途换流\n     */\n\n  }, {\n    key: 'detactChangeStream',\n    value: function detactChangeStream(samples) {\n      let changed = false;\n      let changedIdx = -1;\n      for (let i = 0, len = samples.length; i < len; i++) {\n        if (samples[i].options && samples[i].options.meta) {\n          changed = true;\n          changedIdx = i;\n          break;\n        }\n      }\n\n      return {\n        changed,\n        changedIdx\n      };\n    }\n  }]);\n\n  return Compatibility;\n}();\n\nexports.default = Compatibility;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/compatibility.js?")},"../xgplayer-codec/src/h264/nalunit/golomb.js":
/*!****************************************************!*\
  !*** ../xgplayer-codec/src/h264/nalunit/golomb.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet Golomb = function () {\n  function Golomb(uint8array) {\n    _classCallCheck(this, Golomb);\n\n    this.TAG = 'Golomb';\n    this._buffer = uint8array;\n    this._bufferIndex = 0;\n    this._totalBytes = uint8array.byteLength;\n    this._totalBits = uint8array.byteLength * 8;\n    this._currentWord = 0;\n    this._currentWordBitsLeft = 0;\n  }\n\n  _createClass(Golomb, [{\n    key: 'destroy',\n    value: function destroy() {\n      this._buffer = null;\n    }\n  }, {\n    key: '_fillCurrentWord',\n    value: function _fillCurrentWord() {\n      let bufferBytesLeft = this._totalBytes - this._bufferIndex;\n      if (bufferBytesLeft <= 0) {\n        // TODO 异常处理\n      }\n\n      let bytesRead = Math.min(4, bufferBytesLeft);\n      let word = new Uint8Array(4);\n      word.set(this._buffer.subarray(this._bufferIndex, this._bufferIndex + bytesRead));\n      this._currentWord = new DataView(word.buffer).getUint32(0);\n\n      this._bufferIndex += bytesRead;\n      this._currentWordBitsLeft = bytesRead * 8;\n    }\n  }, {\n    key: 'readBits',\n    value: function readBits(size) {\n      let bits = Math.min(this._currentWordBitsLeft, size); // :uint\n      let valu = this._currentWord >>> 32 - bits;\n      if (size > 32) {\n        throw new Error('Cannot read more than 32 bits at a time');\n      }\n      this._currentWordBitsLeft -= bits;\n      if (this._currentWordBitsLeft > 0) {\n        this._currentWord <<= bits;\n      } else if (this._totalBytes - this._bufferIndex > 0) {\n        this._fillCurrentWord();\n      }\n\n      bits = size - bits;\n      if (bits > 0 && this._currentWordBitsLeft) {\n        return valu << bits | this.readBits(bits);\n      } else {\n        return valu;\n      }\n    }\n  }, {\n    key: 'readBool',\n    value: function readBool() {\n      return this.readBits(1) === 1;\n    }\n  }, {\n    key: 'readByte',\n    value: function readByte() {\n      return this.readBits(8);\n    }\n  }, {\n    key: '_skipLeadingZero',\n    value: function _skipLeadingZero() {\n      let zeroCount;\n      for (zeroCount = 0; zeroCount < this._currentWordBitsLeft; zeroCount++) {\n        if ((this._currentWord & 0x80000000 >>> zeroCount) !== 0) {\n          this._currentWord <<= zeroCount;\n          this._currentWordBitsLeft -= zeroCount;\n          return zeroCount;\n        }\n      }\n      this._fillCurrentWord();\n      return zeroCount + this._skipLeadingZero();\n    }\n  }, {\n    key: 'readUEG',\n    value: function readUEG() {\n      // unsigned exponential golomb\n      let leadingZeros = this._skipLeadingZero();\n      return this.readBits(leadingZeros + 1) - 1;\n    }\n  }, {\n    key: 'readSEG',\n    value: function readSEG() {\n      // signed exponential golomb\n      let value = this.readUEG();\n      if (value & 0x01) {\n        return value + 1 >>> 1;\n      } else {\n        return -1 * (value >>> 1);\n      }\n    }\n  }]);\n\n  return Golomb;\n}();\n\nexports.default = Golomb;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/h264/nalunit/golomb.js?")},"../xgplayer-codec/src/h264/nalunit/index.js":
/*!***************************************************!*\
  !*** ../xgplayer-codec/src/h264/nalunit/index.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _sps = __webpack_require__(/*! ./sps */ \"../xgplayer-codec/src/h264/nalunit/sps.js\");\n\nvar _sps2 = _interopRequireDefault(_sps);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet Nalunit = function () {\n  function Nalunit() {\n    _classCallCheck(this, Nalunit);\n  }\n\n  _createClass(Nalunit, null, [{\n    key: 'getNalunits',\n    value: function getNalunits(buffer) {\n      if (buffer.length - buffer.position < 4) {\n        return [];\n      }\n\n      let buf = buffer.dataview;\n      let position = buffer.position;\n      if (buf.getInt32(position) === 1 || buf.getInt16(position) === 0 && buf.getInt8(position + 2) === 1) {\n        return Nalunit.getAnnexbNals(buffer);\n      } else {\n        return Nalunit.getAvccNals(buffer);\n      }\n    }\n  }, {\n    key: 'getAnnexbNals',\n    value: function getAnnexbNals(buffer) {\n      let nals = [];\n      let position = Nalunit.getHeaderPositionAnnexB(buffer);\n      let start = position.pos;\n      let end = start;\n      while (start < buffer.length - 4) {\n        let header = buffer.buffer.slice(start, start + position.headerLength);\n        if (position.pos === buffer.position) {\n          buffer.skip(position.headerLength);\n        }\n        position = Nalunit.getHeaderPositionAnnexB(buffer);\n        end = position.pos;\n        let body = new Uint8Array(buffer.buffer.slice(start + header.byteLength, end));\n        let unit = { header, body };\n        Nalunit.analyseNal(unit);\n        nals.push(unit);\n        buffer.skip(end - buffer.position);\n        start = end;\n      }\n      return nals;\n    }\n  }, {\n    key: 'getAvccNals',\n    value: function getAvccNals(buffer) {\n      let nals = [];\n      while (buffer.position < buffer.length - 4) {\n        let length = buffer.dataview.getInt32(buffer.position);\n        if (buffer.length - buffer.position >= length) {\n          let header = buffer.buffer.slice(buffer.position, buffer.position + 4);\n          buffer.skip(4);\n          let body = buffer.buffer.slice(buffer.position, buffer.position + length);\n          buffer.skip(length);\n          let unit = { header, body };\n          Nalunit.analyseNal(unit);\n          nals.push(unit);\n        } else {\n          break;\n        }\n      }\n      return nals;\n    }\n  }, {\n    key: 'analyseNal',\n    value: function analyseNal(unit) {\n      let type = unit.body[0] & 0x1f;\n      switch (type) {\n        case 1:\n          // NDR\n          unit.ndr = true;\n          break;\n        case 5:\n          // IDR\n          unit.idr = true;\n          break;\n        case 6:\n          // SEI\n          break;\n        case 7:\n          // SPS\n          unit.sps = _sps2.default.parseSPS(unit.body);\n          break;\n        case 8:\n          // PPS\n          unit.pps = true;\n          break;\n        case 9:\n          // AUD\n          break;\n        default:\n          break;\n      }\n    }\n  }, {\n    key: 'getHeaderPositionAnnexB',\n    value: function getHeaderPositionAnnexB(buffer) {\n      // seperate\n      let pos = buffer.position;\n      let headerLength = 0;\n      while (headerLength !== 3 && headerLength !== 4 && pos < buffer.length - 4) {\n        if (buffer.dataview.getInt16(pos) === 0) {\n          if (buffer.dataview.getInt16(pos + 2) === 1) {\n            // 0x000001\n            headerLength = 4;\n          } else if (buffer.dataview.getInt8(pos + 2) === 1) {\n            headerLength = 3;\n          } else {\n            pos++;\n          }\n        } else {\n          pos++;\n        }\n      }\n\n      if (pos === buffer.length - 4) {\n        if (buffer.dataview.getInt16(pos) === 0) {\n          if (buffer.dataview.getInt16(pos + 2) === 1) {\n            // 0x000001\n            headerLength = 4;\n          }\n        } else {\n          pos++;\n          if (buffer.dataview.getInt16(pos) === 0 && buffer.dataview.getInt8(pos) === 1) {\n            // 0x0000001\n            headerLength = 3;\n          } else {\n            pos = buffer.length;\n          }\n        }\n      }\n      return { pos, headerLength };\n    }\n  }, {\n    key: 'getAvcc',\n    value: function getAvcc(sps, pps) {\n      let ret = new Uint8Array(sps.byteLength + pps.byteLength + 11);\n      ret[0] = 0x01;\n      ret[1] = sps[1];\n      ret[2] = sps[2];\n      ret[3] = sps[3];\n      ret[4] = 255;\n      ret[5] = 225;\n\n      let offset = 6;\n\n      ret.set(new Uint8Array([sps.byteLength >>> 8 & 0xff, sps.byteLength & 0xff]), offset);\n      offset += 2;\n      ret.set(sps, offset);\n      offset += sps.byteLength;\n\n      ret[offset] = 1;\n      offset++;\n\n      ret.set(new Uint8Array([pps.byteLength >>> 8 & 0xff, pps.byteLength & 0xff]), offset);\n      offset += 2;\n      ret.set(pps, offset);\n      return ret;\n    }\n  }]);\n\n  return Nalunit;\n}();\n\nexports.default = Nalunit;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/h264/nalunit/index.js?")},"../xgplayer-codec/src/h264/nalunit/sps.js":
/*!*************************************************!*\
  !*** ../xgplayer-codec/src/h264/nalunit/sps.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable camelcase  */\n/* eslint-disable one-var  */\n\n\nvar _golomb = __webpack_require__(/*! ./golomb */ \"../xgplayer-codec/src/h264/nalunit/golomb.js\");\n\nvar _golomb2 = _interopRequireDefault(_golomb);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet SPSParser = function () {\n  function SPSParser() {\n    _classCallCheck(this, SPSParser);\n  }\n\n  _createClass(SPSParser, null, [{\n    key: '_ebsp2rbsp',\n    value: function _ebsp2rbsp(uint8array) {\n      let src = uint8array;\n      let srcLength = src.byteLength;\n      let dst = new Uint8Array(srcLength);\n      let dstIdx = 0;\n\n      for (let i = 0; i < srcLength; i++) {\n        if (i >= 2) {\n          if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n            continue;\n          }\n        }\n        dst[dstIdx] = src[i];\n        dstIdx++;\n      }\n\n      return new Uint8Array(dst.buffer, 0, dstIdx);\n    }\n  }, {\n    key: 'parseSPS',\n    value: function parseSPS(uint8array) {\n      let rbsp = SPSParser._ebsp2rbsp(uint8array);\n      let gb = new _golomb2.default(rbsp);\n\n      gb.readByte();\n      let profileIdc = gb.readByte();\n      gb.readByte();\n      let levelIdc = gb.readByte();\n      gb.readUEG();\n\n      let profile_string = SPSParser.getProfileString(profileIdc);\n      let level_string = SPSParser.getLevelString(levelIdc);\n      let chroma_format_idc = 1;\n      let chroma_format = 420;\n      let chroma_format_table = [0, 420, 422, 444];\n      let bit_depth = 8;\n\n      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128 || profileIdc === 138 || profileIdc === 144) {\n        chroma_format_idc = gb.readUEG();\n        if (chroma_format_idc === 3) {\n          gb.readBits(1);\n        }\n        if (chroma_format_idc <= 3) {\n          chroma_format = chroma_format_table[chroma_format_idc];\n        }\n\n        bit_depth = gb.readUEG() + 8;\n        gb.readUEG();\n        gb.readBits(1);\n        if (gb.readBool()) {\n          let scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;\n          for (let i = 0; i < scaling_list_count; i++) {\n            if (gb.readBool()) {\n              if (i < 6) {\n                SPSParser._skipScalingList(gb, 16);\n              } else {\n                SPSParser._skipScalingList(gb, 64);\n              }\n            }\n          }\n        }\n      }\n      gb.readUEG();\n      let pic_order_cnt_type = gb.readUEG();\n      if (pic_order_cnt_type === 0) {\n        gb.readUEG();\n      } else if (pic_order_cnt_type === 1) {\n        gb.readBits(1);\n        gb.readSEG();\n        gb.readSEG();\n        let num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n        for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n          gb.readSEG();\n        }\n      }\n      gb.readUEG();\n      gb.readBits(1);\n\n      let pic_width_in_mbs_minus1 = gb.readUEG();\n      let pic_height_in_map_units_minus1 = gb.readUEG();\n\n      let frame_mbs_only_flag = gb.readBits(1);\n      if (frame_mbs_only_flag === 0) {\n        gb.readBits(1);\n      }\n      gb.readBits(1);\n\n      let frame_crop_left_offset = 0;\n      let frame_crop_right_offset = 0;\n      let frame_crop_top_offset = 0;\n      let frame_crop_bottom_offset = 0;\n\n      let frame_cropping_flag = gb.readBool();\n      if (frame_cropping_flag) {\n        frame_crop_left_offset = gb.readUEG();\n        frame_crop_right_offset = gb.readUEG();\n        frame_crop_top_offset = gb.readUEG();\n        frame_crop_bottom_offset = gb.readUEG();\n      }\n\n      let par_width = 1,\n          par_height = 1;\n      let fps = 0,\n          fps_fixed = true,\n          fps_num = 0,\n          fps_den = 0;\n\n      let vui_parameters_present_flag = gb.readBool();\n      if (vui_parameters_present_flag) {\n        if (gb.readBool()) {\n          // aspect_ratio_info_present_flag\n          let aspect_ratio_idc = gb.readByte();\n          let par_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n          let par_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n\n          if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n            par_width = par_w_table[aspect_ratio_idc - 1];\n            par_height = par_h_table[aspect_ratio_idc - 1];\n          } else if (aspect_ratio_idc === 255) {\n            par_width = gb.readByte() << 8 | gb.readByte();\n            par_height = gb.readByte() << 8 | gb.readByte();\n          }\n        }\n\n        if (gb.readBool()) {\n          gb.readBool();\n        }\n        if (gb.readBool()) {\n          gb.readBits(4);\n          if (gb.readBool()) {\n            gb.readBits(24);\n          }\n        }\n        if (gb.readBool()) {\n          gb.readUEG();\n          gb.readUEG();\n        }\n        if (gb.readBool()) {\n          let num_units_in_tick = gb.readBits(32);\n          let time_scale = gb.readBits(32);\n          fps_fixed = gb.readBool();\n\n          fps_num = time_scale;\n          fps_den = num_units_in_tick * 2;\n          fps = fps_num / fps_den;\n        }\n      }\n\n      let parScale = 1;\n      if (par_width !== 1 || par_height !== 1) {\n        parScale = par_width / par_height;\n      }\n\n      let crop_unit_x = 0,\n          crop_unit_y = 0;\n      if (chroma_format_idc === 0) {\n        crop_unit_x = 1;\n        crop_unit_y = 2 - frame_mbs_only_flag;\n      } else {\n        let sub_wc = chroma_format_idc === 3 ? 1 : 2;\n        let sub_hc = chroma_format_idc === 1 ? 2 : 1;\n        crop_unit_x = sub_wc;\n        crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n      }\n\n      let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n      let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n\n      codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n      codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n\n      let present_width = Math.ceil(codec_width * parScale);\n\n      gb.destroy();\n      gb = null;\n\n      return {\n        profile_string: profile_string,\n        level_string: level_string,\n        bit_depth: bit_depth,\n        chroma_format: chroma_format,\n        chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n\n        frame_rate: {\n          fixed: fps_fixed,\n          fps: fps,\n          fps_den: fps_den,\n          fps_num: fps_num\n        },\n\n        par_ratio: {\n          width: par_width,\n          height: par_height\n        },\n\n        codec_size: {\n          width: codec_width,\n          height: codec_height\n        },\n\n        present_size: {\n          width: present_width,\n          height: codec_height\n        }\n      };\n    }\n  }, {\n    key: '_skipScalingList',\n    value: function _skipScalingList(gb, count) {\n      let last_scale = 8,\n          next_scale = 8;\n      let delta_scale = 0;\n      for (let i = 0; i < count; i++) {\n        if (next_scale !== 0) {\n          delta_scale = gb.readSEG();\n          next_scale = (last_scale + delta_scale + 256) % 256;\n        }\n        last_scale = next_scale === 0 ? last_scale : next_scale;\n      }\n    }\n  }, {\n    key: 'getProfileString',\n    value: function getProfileString(profileIdc) {\n      switch (profileIdc) {\n        case 66:\n          return 'Baseline';\n        case 77:\n          return 'Main';\n        case 88:\n          return 'Extended';\n        case 100:\n          return 'High';\n        case 110:\n          return 'High10';\n        case 122:\n          return 'High422';\n        case 244:\n          return 'High444';\n        default:\n          return 'Unknown';\n      }\n    }\n  }, {\n    key: 'getLevelString',\n    value: function getLevelString(levelIdc) {\n      return (levelIdc / 10).toFixed(1);\n    }\n  }, {\n    key: 'getChromaFormatString',\n    value: function getChromaFormatString(chroma) {\n      switch (chroma) {\n        case 420:\n          return '4:2:0';\n        case 422:\n          return '4:2:2';\n        case 444:\n          return '4:4:4';\n        default:\n          return 'Unknown';\n      }\n    }\n  }, {\n    key: 'toVideoMeta',\n    value: function toVideoMeta(spsConfig) {\n      let meta = {};\n      if (spsConfig && spsConfig.codec_size) {\n        meta.codecWidth = spsConfig.codec_size.width;\n        meta.codecHeight = spsConfig.codec_size.height;\n        meta.presentWidth = spsConfig.present_size.width;\n        meta.presentHeight = spsConfig.present_size.height;\n      }\n\n      meta.profile = spsConfig.profile_string;\n      meta.level = spsConfig.level_string;\n      meta.bitDepth = spsConfig.bit_depth;\n      meta.chromaFormat = spsConfig.chroma_format;\n\n      meta.parRatio = {\n        width: spsConfig.par_ratio.width,\n        height: spsConfig.par_ratio.height\n      };\n\n      meta.frameRate = spsConfig.frame_rate;\n\n      let fpsDen = meta.frameRate.fps_den;\n      let fpsNum = meta.frameRate.fps_num;\n      meta.refSampleDuration = Math.floor(meta.timescale * (fpsDen / fpsNum));\n      return meta;\n    }\n  }]);\n\n  return SPSParser;\n}();\n\nexports.default = SPSParser;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/h264/nalunit/sps.js?")},"../xgplayer-demux/index.js":
/*!**********************************!*\
  !*** ../xgplayer-demux/index.js ***!
  \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = {\n  // HLS\n  M3U8Parser: __webpack_require__(/*! ./src/hls/demuxer/m3u8parser */ "../xgplayer-demux/src/hls/demuxer/m3u8parser.js").default,\n  TsDemuxer: __webpack_require__(/*! ./src/hls/demuxer/ts */ "../xgplayer-demux/src/hls/demuxer/ts.js").default,\n  Playlist: __webpack_require__(/*! ./src/hls/playlist */ "../xgplayer-demux/src/hls/playlist.js").default,\n  FlvDemuxer: __webpack_require__(/*! ./src/flv/index */ "../xgplayer-demux/src/flv/index.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/index.js?')},"../xgplayer-demux/src/flv/amf-parser.js":
/*!***********************************************!*\
  !*** ../xgplayer-demux/src/flv/amf-parser.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nconst DATA_TYPES = {\n  NUMBER: 0,\n  BOOLEAN: 1,\n  STRING: 2,\n  OBJECT: 3,\n  MIX_ARRAY: 8,\n  OBJECT_END: 9,\n  STRICT_ARRAY: 10,\n  DATE: 11,\n  LONE_STRING: 12\n\n  /**\n   * meta信息解析\n   */\n};\nlet AMFParser = function () {\n  function AMFParser() {\n    _classCallCheck(this, AMFParser);\n\n    this.offset = 0;\n    this.readOffset = this.offset;\n  }\n\n  _createClass(AMFParser, [{\n    key: 'resolve',\n    value: function resolve(meta, size) {\n      if (size < 3) {\n        throw new Error('not enough data for metainfo');\n      }\n      const metaData = {};\n      const name = this.parseValue(meta);\n      const value = this.parseValue(meta, size - name.bodySize);\n      metaData[name.data] = value.data;\n\n      this.resetStatus();\n      return metaData;\n    }\n  }, {\n    key: 'resetStatus',\n    value: function resetStatus() {\n      this.offset = 0;\n      this.readOffset = this.offset;\n    }\n  }, {\n    key: 'parseString',\n    value: function parseString(buffer) {\n      const dv = new DataView(buffer, this.readOffset);\n      const strLen = dv.getUint16(0, !_xgplayerUtils.isLe);\n      let str = '';\n      if (strLen > 0) {\n        str = _xgplayerUtils.UTF8.decode(new Uint8Array(buffer, this.readOffset + 2, strLen));\n      } else {\n        str = '';\n      }\n      let size = strLen + 2;\n      this.readOffset += size;\n      return {\n        data: str,\n        bodySize: strLen + 2\n      };\n    }\n  }, {\n    key: 'parseDate',\n    value: function parseDate(buffer, size) {\n      const dv = new DataView(buffer, this.readOffset, size);\n      let ts = dv.getFloat64(0, !_xgplayerUtils.isLe);\n      const timeOffset = dv.getInt16(8, !_xgplayerUtils.isLe);\n      ts += timeOffset * 60 * 1000;\n\n      this.readOffset += 10;\n      return {\n        data: new Date(ts),\n        bodySize: 10\n      };\n    }\n  }, {\n    key: 'parseObject',\n    value: function parseObject(buffer, size) {\n      const name = this.parseString(buffer, size);\n      const value = this.parseValue(buffer, size - name.bodySize);\n      return {\n        data: {\n          name: name.data,\n          value: value.data\n        },\n        bodySize: name.bodySize + value.bodySize,\n        isObjEnd: value.isObjEnd\n      };\n    }\n  }, {\n    key: 'parseLongString',\n    value: function parseLongString(buffer) {\n      const dv = new DataView(buffer, this.readOffset);\n      const strLen = dv.getUint32(0, !_xgplayerUtils.isLe);\n      let str = '';\n      if (strLen > 0) {\n        str = _xgplayerUtils.UTF8.decode(new Uint8Array(buffer, this.readOffset + 2, strLen));\n      } else {\n        str = '';\n      }\n      // const size = strLen + 4;\n      this.readOffset += strLen + 4;\n      return {\n        data: str,\n        bodySize: strLen + 4\n      };\n    }\n\n    /**\n     * 解析meta中的变量\n     */\n\n  }, {\n    key: 'parseValue',\n    value: function parseValue(data, size) {\n      let buffer = new ArrayBuffer();\n      if (data instanceof ArrayBuffer) {\n        buffer = data;\n      } else {\n        buffer = data.buffer;\n      }\n      const {\n        NUMBER,\n        BOOLEAN,\n        STRING,\n        OBJECT,\n        MIX_ARRAY,\n        OBJECT_END,\n        STRICT_ARRAY,\n        DATE,\n        LONE_STRING\n      } = DATA_TYPES;\n      const dataView = new DataView(buffer, this.readOffset, size);\n      let isObjEnd = false;\n      const type = dataView.getUint8(0);\n      let offset = 1;\n      this.readOffset += 1;\n      let value = null;\n\n      switch (type) {\n        case NUMBER:\n          {\n            value = dataView.getFloat64(1, !_xgplayerUtils.isLe);\n            this.readOffset += 8;\n            offset += 8;\n            break;\n          }\n        case BOOLEAN:\n          {\n            const boolNum = dataView.getUint8(1);\n            value = !!boolNum;\n            this.readOffset += 1;\n            offset += 1;\n            break;\n          }\n        case STRING:\n          {\n            const str = this.parseString(buffer);\n            value = str.data;\n            offset += str.bodySize;\n            break;\n          }\n        case OBJECT:\n          {\n            value = {};\n            let objEndSize = 0;\n            if (dataView.getUint32(size - 4, !_xgplayerUtils.isLe) & 0x00FFFFFF) {\n              objEndSize = 3;\n            }\n            // this.readOffset += offset - 1;\n            while (offset < size - 4) {\n              const amfObj = this.parseObject(buffer, size - offset - objEndSize);\n              if (amfObj.isObjectEnd) {\n                break;\n              }\n              value[amfObj.data.name] = amfObj.data.value;\n              offset += amfObj.bodySize;\n            }\n            if (offset <= size - 3) {\n              const mark = dataView.getUint32(offset - 1, !_xgplayerUtils.isLe) & 0x00FFFFFF;\n              if (mark === 9) {\n                this.readOffset += 3;\n                offset += 3;\n              }\n            }\n            break;\n          }\n        case MIX_ARRAY:\n          {\n            value = {};\n            offset += 4;\n            this.readOffset += 4;\n            let objEndSize = 0;\n            if ((dataView.getUint32(size - 4, !_xgplayerUtils.isLe) & 0x00FFFFFF) === 9) {\n              objEndSize = 3;\n            }\n\n            while (offset < size - 8) {\n              const amfVar = this.parseObject(buffer, size - offset - objEndSize);\n              if (amfVar.isObjectEnd) {\n                break;\n              }\n              value[amfVar.data.name] = amfVar.data.value;\n              offset += amfVar.bodySize;\n            }\n            if (offset <= size - 3) {\n              const marker = dataView.getUint32(offset - 1, !_xgplayerUtils.isLe) & 0x00FFFFFF;\n              if (marker === 9) {\n                offset += 3;\n                this.readOffset += 3;\n              }\n            }\n            break;\n          }\n\n        case OBJECT_END:\n          {\n            value = null;\n            isObjEnd = true;\n            break;\n          }\n\n        case STRICT_ARRAY:\n          {\n            value = [];\n            const arrLength = dataView.getUint32(1, !_xgplayerUtils.isLe);\n            offset += 4;\n            this.readOffset += 4;\n            for (let i = 0; i < arrLength; i++) {\n              const script = this.parseValue(buffer, size - offset);\n              value.push(script.data);\n              offset += script.bodySize;\n            }\n            break;\n          }\n\n        case DATE:\n          {\n            const date = this.parseDate(buffer, size - 1);\n            value = date.data;\n            offset += date.bodySize;\n            break;\n          }\n\n        case LONE_STRING:\n          {\n            const longStr = this.parseLongString(buffer, size - 1);\n            value = longStr.data;\n            offset += longStr.bodySize;\n            break;\n          }\n\n        default:\n          {\n            offset = size;\n          }\n      }\n\n      return {\n        data: value,\n        bodySize: offset,\n        isObjEnd: isObjEnd\n      };\n    }\n  }]);\n\n  return AMFParser;\n}();\n\nexports.default = AMFParser;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/flv/amf-parser.js?")},"../xgplayer-demux/src/flv/index.js":
/*!******************************************!*\
  !*** ../xgplayer-demux/src/flv/index.js ***!
  \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _xgplayerCodec = __webpack_require__(/*! xgplayer-codec */ \"../xgplayer-codec/index.js\");\n\nvar _xgplayerBuffer = __webpack_require__(/*! xgplayer-buffer */ \"../xgplayer-buffer/index.js\");\n\nvar _amfParser = __webpack_require__(/*! ./amf-parser */ \"../xgplayer-demux/src/flv/amf-parser.js\");\n\nvar _amfParser2 = _interopRequireDefault(_amfParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nconst DEMUX_EVENTS = _xgplayerUtils.EVENTS.DEMUX_EVENTS;\n\nlet FlvDemuxer = function () {\n  function FlvDemuxer() {\n    _classCallCheck(this, FlvDemuxer);\n\n    this._firstFragmentLoaded = false;\n    this._trackNum = 0;\n    this._hasScript = false;\n  }\n\n  _createClass(FlvDemuxer, [{\n    key: 'init',\n    value: function init() {\n      this.on(DEMUX_EVENTS.DEMUX_START, this.doParseFlv.bind(this));\n    }\n\n    /**\n     * if the flv head is valid\n     * @param data\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'doParseFlv',\n    value: function doParseFlv() {\n      if (!this._firstFragmentLoaded) {\n        if (this.loaderBuffer.length < 13) {\n          return;\n        }\n        const header = this.loaderBuffer.shift(13);\n        this.parseFlvHeader(header);\n        this.doParseFlv(); // 递归调用，继续解析flv流\n      } else {\n        if (this.loaderBuffer.length < 11) {\n          return;\n        }\n        let chunk;\n\n        let loopMax = 100000; // 防止死循环产生\n        do {\n          chunk = this._parseFlvTag();\n        } while (chunk && loopMax-- > 0);\n\n        this.emit(DEMUX_EVENTS.DEMUX_COMPLETE);\n      }\n    }\n  }, {\n    key: 'parseFlvHeader',\n    value: function parseFlvHeader(header) {\n      if (!FlvDemuxer.isFlvFile(header)) {\n        this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error('invalid flv file'));\n        this.doParseFlv();\n      } else {\n        this._firstFragmentLoaded = true;\n        const playType = FlvDemuxer.getPlayType(header[4]);\n\n        if (playType.hasVideo) {\n          this.initVideoTrack();\n        }\n\n        if (playType.hasAudio) {\n          this.initAudioTrack();\n        }\n      }\n      this.doParseFlv();\n    }\n\n    /**\n     * init default video track configs\n     */\n\n  }, {\n    key: 'initVideoTrack',\n    value: function initVideoTrack() {\n      this._trackNum++;\n      let videoTrack = new _xgplayerBuffer.VideoTrack();\n      videoTrack.meta = new _xgplayerUtils.VideoTrackMeta();\n      videoTrack.id = videoTrack.meta.id = this._trackNum;\n\n      this.tracks.videoTrack = videoTrack;\n    }\n\n    /**\n     * init default audio track configs\n     */\n\n  }, {\n    key: 'initAudioTrack',\n    value: function initAudioTrack() {\n      this._trackNum++;\n      let audioTrack = new _xgplayerBuffer.AudioTrack();\n      audioTrack.meta = new _xgplayerUtils.AudioTrackMeta();\n      audioTrack.id = audioTrack.meta.id = this._trackNum;\n\n      this.tracks.audioTrack = audioTrack;\n    }\n\n    /**\n     * Package the data as the following data structure\n     * {\n     *    data: Uint8Array. the Stream data.\n     *    info: The first byte info of the Tag.\n     *    tagType: 8、9、18\n     *    timeStamp: the timestemp\n     * }\n     */\n\n  }, {\n    key: '_parseFlvTag',\n    value: function _parseFlvTag() {\n      if (this.loaderBuffer.length < 11) {\n        return null;\n      }\n      let chunk = this._parseFlvTagHeader();\n      if (chunk) {\n        this._processChunk(chunk);\n      }\n      return chunk;\n    }\n\n    /**\n     * Parse the 11 byte tag Header\n     */\n\n  }, {\n    key: '_parseFlvTagHeader',\n    value: function _parseFlvTagHeader() {\n      let offset = 0;\n      let chunk = {};\n\n      let tagType = this.loaderBuffer.toInt(offset, 1);\n      offset += 1;\n\n      // 2 bit FMS reserved, 1 bit filtered, 5 bit tag type\n      chunk.filtered = (tagType & 32) >>> 5;\n      chunk.tagType = tagType & 31;\n\n      // 3 Byte datasize\n      chunk.datasize = this.loaderBuffer.toInt(offset, 3);\n      offset += 3;\n\n      if (chunk.tagType !== 8 && chunk.tagType !== 9 && chunk.tagType !== 11 && chunk.tagType !== 18 || this.loaderBuffer.toInt(8, 3) !== 0) {\n        if (this.loaderBuffer && this.loaderBuffer.length > 0) {\n          this.loaderBuffer.shift(1);\n        }\n        this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error('tagType ' + chunk.tagType), false);\n        return null;\n      }\n\n      if (this.loaderBuffer.length < chunk.datasize + 15) {\n        return null;\n      }\n\n      // read the data.\n      this.loaderBuffer.shift(4);\n\n      // 3 Byte timestamp\n      let timestamp = this.loaderBuffer.toInt(0, 3);\n      this.loaderBuffer.shift(3);\n\n      // 1 Byte timestampExt\n      let timestampExt = this.loaderBuffer.shift(1)[0];\n      if (timestampExt > 0) {\n        timestamp += timestampExt * 0x1000000;\n      }\n\n      chunk.dts = timestamp;\n\n      // streamId\n      this.loaderBuffer.shift(3);\n      return chunk;\n    }\n  }, {\n    key: '_processChunk',\n    value: function _processChunk(chunk) {\n      switch (chunk.tagType) {\n        case 18:\n          this._parseScriptData(chunk);\n          break;\n        case 8:\n          this._parseAACData(chunk);\n          break;\n        case 9:\n          this._parseHevcData(chunk);\n          break;\n        case 11:\n          // for some CDN that did not process the currect RTMP messages\n          this.loaderBuffer.shift(3);\n          break;\n        default:\n          this.loaderBuffer.shift(1);\n      }\n    }\n\n    /**\n     * parse flv script data\n     * @param chunk\n     * @private\n     */\n\n  }, {\n    key: '_parseScriptData',\n    value: function _parseScriptData(chunk) {\n      let audioTrack = this.tracks.audioTrack;\n      let videoTrack = this.tracks.videoTrack;\n\n      let data = this.loaderBuffer.shift(chunk.datasize);\n\n      const info = new _amfParser2.default().resolve(data, data.length);\n\n      const onMetaData = this._context.onMetaData = info ? info.onMetaData : undefined;\n\n      // fill mediaInfo\n      this._context.mediaInfo.duration = onMetaData.duration;\n      this._context.mediaInfo.hasVideo = onMetaData.hasVideo;\n      this._context.mediaInfo.hsaAudio = onMetaData.hasAudio;\n\n      let validate = this._datasizeValidator(chunk.datasize);\n      if (validate) {\n        this.emit(DEMUX_EVENTS.MEDIA_INFO);\n        this._hasScript = true;\n      }\n\n      // Edit default meta.\n      if (audioTrack && !audioTrack.hasSpecificConfig) {\n        let meta = audioTrack.meta;\n        if (onMetaData.audiosamplerate) {\n          meta.sampleRate = onMetaData.audiosamplerate;\n        }\n\n        if (onMetaData.audiochannels) {\n          meta.channelCount = onMetaData.audiochannels;\n        }\n\n        switch (onMetaData.audiosamplerate) {\n          case 44100:\n            meta.sampleRateIndex = 4;\n            break;\n          case 22050:\n            meta.sampleRateIndex = 7;\n            break;\n          case 11025:\n            meta.sampleRateIndex = 10;\n            break;\n        }\n      }\n      if (videoTrack && !videoTrack.hasSpecificConfig) {\n        let meta = videoTrack.meta;\n        if (typeof onMetaData.framerate === 'number') {\n          let fpsNum = Math.floor(onMetaData.framerate * 1000);\n          if (fpsNum > 0) {\n            let fps = fpsNum / 1000;\n            if (!meta.frameRate) {\n              meta.frameRate = {};\n            }\n            meta.frameRate.fixed = true;\n            meta.frameRate.fps = fps;\n            meta.frameRate.fps_num = fpsNum;\n            meta.frameRate.fps_den = 1000;\n          }\n        }\n      }\n    }\n  }, {\n    key: '_aacSequenceHeaderParser',\n    value: function _aacSequenceHeaderParser(data) {\n      let ret = {};\n      ret.hasSpecificConfig = true;\n      ret.objectType = data[1] >>> 3;\n      ret.originObjectType = ret.objectType;\n      ret.sampleRateIndex = (data[1] & 7) << 1 | data[2] >>> 7;\n      ret.audiosamplerate = this._switchAudioSampleRate(ret.sampleRateIndex);\n      ret.channelCount = (data[2] & 120) >>> 3;\n      ret.frameLength = (data[2] & 4) >>> 2;\n      ret.dependsOnCoreCoder = (data[2] & 2) >>> 1;\n      ret.extensionFlagIndex = data[2] & 1;\n\n      ret.codec = `mp4a.40.${ret.objectType}`;\n      let userAgent = window.navigator.userAgent.toLowerCase();\n      let extensionSamplingIndex;\n\n      let config;\n      let samplingIndex = ret.sampleRateIndex;\n\n      if (userAgent.indexOf('firefox') !== -1) {\n        // firefox: use SBR (HE-AAC) if freq less than 24kHz\n        if (ret.sampleRateIndex >= 6) {\n          ret.objectType = 5;\n          config = new Array(4);\n          extensionSamplingIndex = samplingIndex - 3;\n        } else {\n          // use LC-AAC\n          ret.objectType = 2;\n          config = new Array(2);\n          extensionSamplingIndex = samplingIndex;\n        }\n      } else if (userAgent.indexOf('android') !== -1 || _xgplayerUtils.sniffer.browser === 'safari') {\n        // android: always use LC-AAC\n        ret.objectType = 2;\n        config = new Array(2);\n        extensionSamplingIndex = samplingIndex;\n      } else {\n        // for other browsers, e.g. chrome...\n        // Always use HE-AAC to make it easier to switch aac codec profile\n        ret.objectType = 5;\n        extensionSamplingIndex = ret.sampleRateIndex;\n        config = new Array(4);\n\n        if (ret.sampleRateIndex >= 6) {\n          extensionSamplingIndex = ret.sampleRateIndex - 3;\n        } else if (ret.channelCount === 1) {\n          // Mono channel\n          ret.objectType = 2;\n          config = new Array(2);\n          extensionSamplingIndex = ret.sampleRateIndex;\n        }\n      }\n\n      config[0] = ret.objectType << 3;\n      config[0] |= (ret.sampleRateIndex & 0x0F) >>> 1;\n      config[1] = (ret.sampleRateIndex & 0x0F) << 7;\n      config[1] |= (ret.channelCount & 0x0F) << 3;\n      if (ret.objectType === 5) {\n        config[1] |= (extensionSamplingIndex & 0x0F) >>> 1;\n        config[2] = (extensionSamplingIndex & 0x01) << 7;\n        // extended audio object type: force to 2 (LC-AAC)\n        config[2] |= 2 << 2;\n        config[3] = 0;\n      }\n      ret.config = config;\n      return ret;\n    }\n  }, {\n    key: '_parseAACData',\n    value: function _parseAACData(chunk) {\n      let track = this.tracks.audioTrack;\n      if (!track) {\n        return;\n      }\n\n      let meta = track.meta;\n\n      if (!meta) {\n        track.meta = new _xgplayerUtils.AudioTrackMeta();\n        meta = track.meta;\n      }\n\n      let info = this.loaderBuffer.shift(1)[0];\n\n      chunk.data = this.loaderBuffer.shift(chunk.datasize - 1);\n\n      let format = (info & 240) >>> 4;\n\n      track.format = format;\n\n      if (format !== 10) {\n        this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error(`invalid audio format: ${format}`));\n      }\n\n      if (format === 10 && !this._hasAudioSequence) {\n        meta.sampleRate = this._switchAudioSamplingFrequency(info);\n        meta.sampleRateIndex = (info & 12) >>> 2;\n        meta.frameLenth = (info & 2) >>> 1;\n        meta.channelCount = info & 1;\n        meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);\n      }\n\n      let audioSampleRate = meta.audioSampleRate;\n      let audioSampleRateIndex = meta.sampleRateIndex;\n      let refSampleDuration = meta.refSampleDuration;\n\n      delete chunk.tagType;\n      let validate = this._datasizeValidator(chunk.datasize);\n\n      if (chunk.data[0] === 0) {\n        // AAC Sequence Header\n        let aacHeader = this._aacSequenceHeaderParser(chunk.data);\n        audioSampleRate = aacHeader.audiosamplerate || meta.audioSampleRate;\n        audioSampleRateIndex = aacHeader.sampleRateIndex || meta.sampleRateIndex;\n        refSampleDuration = Math.floor(1024 / audioSampleRate * meta.timescale);\n\n        meta.channelCount = aacHeader.channelCount;\n        meta.sampleRate = audioSampleRate;\n        meta.sampleRateIndex = audioSampleRateIndex;\n        meta.refSampleDuration = refSampleDuration;\n        meta.duration = this._context.mediaInfo.duration * meta.timescale;\n        meta.config = aacHeader.config;\n        meta.objectType = aacHeader.objectType;\n        meta.originObjectType = aacHeader.originObjectType;\n\n        const audioMedia = this._context.mediaInfo.audio;\n\n        // fill audio media info\n        audioMedia.codec = aacHeader.codec;\n        audioMedia.channelCount = aacHeader.channelCount;\n        audioMedia.sampleRate = audioSampleRate;\n        audioMedia.sampleRateIndex = aacHeader.audioSampleRateIndex;\n\n        if (this._hasScript && !this._hasAudioSequence) {\n          this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n        } else if (this._hasScript && this._hasAudioSequence) {\n          this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n          this.emit(DEMUX_EVENTS.AUDIO_METADATA_CHANGE);\n          // this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio')\n        }\n        this._hasAudioSequence = true;\n\n        this._metaChange = true;\n      } else {\n        if (this._metaChange) {\n          chunk.options = {\n            meta: track.meta\n          };\n          this._metaChange = false;\n        }\n\n        chunk.data = chunk.data.slice(1, chunk.data.length);\n        track.samples.push(chunk);\n      }\n      if (!validate) {\n        this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error('TAG length error at ' + chunk.datasize), false);\n        // this.logger.warn(this.TAG, error.message)\n      }\n    }\n\n    /**\n     * parse hevc/avc video data\n     * @param chunk\n     * @private\n     */\n\n  }, {\n    key: '_parseHevcData',\n    value: function _parseHevcData(chunk) {\n      // header\n      let info = this.loaderBuffer.shift(1)[0];\n      chunk.frameType = (info & 0xf0) >>> 4;\n      chunk.isKeyframe = chunk.frameType === 1;\n      // let tempCodecID = this.tracks.videoTrack.codecID\n      let codecID = info & 0x0f;\n      this.tracks.videoTrack.codecID = codecID;\n\n      // hevc和avc的header解析方式一样\n      chunk.avcPacketType = this.loaderBuffer.shift(1)[0];\n      chunk.cts = this.loaderBuffer.toInt(0, 3);\n      this.loaderBuffer.shift(3);\n\n      // 12 for hevc, 7 for avc\n      if (codecID === 12) {\n        const data = this.loaderBuffer.shift(chunk.datasize - 5);\n        chunk.data = data;\n\n        if (Number.parseInt(chunk.avcPacketType) !== 0) {\n          if (!this._datasizeValidator(chunk.datasize)) {\n            this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n          }\n          let nalu = {};\n          let r = 0;\n          nalu.cts = chunk.cts;\n          nalu.dts = chunk.dts;\n          while (chunk.data.length > r) {\n            let sizes = chunk.data.slice(Number.parseInt(r), 4 + r);\n            nalu.size = sizes[3];\n            nalu.size += sizes[2] * 256;\n            nalu.size += sizes[1] * 256 * 256;\n            nalu.size += sizes[0] * 256 * 256 * 256;\n            r += 4;\n            nalu.data = chunk.data.slice(Number.parseInt(r), nalu.size + r);\n            r += nalu.size;\n            this.tracks.videoTrack.samples.push(nalu);\n            this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n          }\n        } else if (Number.parseInt(chunk.avcPacketType) === 0) {\n          if (!this._datasizeValidator(chunk.datasize)) {\n            this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n          } else {\n            this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n          }\n        }\n      } else if (codecID === 7) {\n        let data = this.loaderBuffer.shift(chunk.datasize - 5);\n        if (data[4] === 0 && data[5] === 0 && data[6] === 0 && data[7] === 1) {\n          let avcclength = 0;\n          for (let i = 0; i < 4; i++) {\n            avcclength = avcclength * 256 + data[i];\n          }\n          avcclength -= 4;\n          data = data.slice(4, data.length);\n          data[3] = avcclength % 256;\n          avcclength = (avcclength - data[3]) / 256;\n          data[2] = avcclength % 256;\n          avcclength = (avcclength - data[2]) / 256;\n          data[1] = avcclength % 256;\n          data[0] = (avcclength - data[1]) / 256;\n        }\n\n        chunk.data = data;\n        // If it is AVC sequece Header.\n        if (chunk.avcPacketType === 0) {\n          this._avcSequenceHeaderParser(chunk.data);\n          let validate = this._datasizeValidator(chunk.datasize);\n          if (validate) {\n            if (this._hasScript && !this._hasVideoSequence) {\n              this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n            } else if (this._hasScript && this._hasVideoSequence) {\n              this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n              this.emit(DEMUX_EVENTS.VIDEO_METADATA_CHANGE);\n              // this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video')\n            }\n            this._hasVideoSequence = true;\n          }\n          this._metaChange = true;\n        } else {\n          if (!this._datasizeValidator(chunk.datasize)) {\n            this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n            return;\n          }\n          if (this._metaChange) {\n            chunk.options = {\n              meta: Object.assign({}, this.tracks.videoTrack.meta)\n            };\n            this._metaChange = false;\n          }\n          this.tracks.videoTrack.samples.push(chunk);\n          // this.emit(DEMUX_EVENTS.DEMUX_COMPLETE)\n        }\n      } else {\n        this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`video codeid is ${codecID}`), false);\n        chunk.data = this.loaderBuffer.shift(chunk.datasize - 1);\n        if (!this._datasizeValidator(chunk.datasize)) {\n          this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n        }\n        this.tracks.videoTrack.samples.push(chunk);\n        this.emit(DEMUX_EVENTS.DEMUX_COMPLETE);\n      }\n      delete chunk.tagType;\n    }\n\n    /**\n     * parse avc metadata\n     * @param data\n     * @private\n     */\n\n  }, {\n    key: '_avcSequenceHeaderParser',\n    value: function _avcSequenceHeaderParser(data) {\n      let track = this.tracks.videoTrack;\n\n      if (!track) {\n        return;\n      }\n\n      let offset = 0;\n\n      if (!track.meta) {\n        track.meta = new _xgplayerUtils.VideoTrackMeta();\n      }\n      let meta = track.meta;\n\n      meta.configurationVersion = data[0];\n      meta.avcProfileIndication = data[1];\n      meta.profileCompatibility = data[2];\n      meta.avcLevelIndication = data[3] / 10;\n      meta.nalUnitLength = (data[4] & 0x03) + 1;\n\n      let numOfSps = data[5] & 0x1f;\n      offset = 6;\n      let config = {};\n\n      // parse SPS\n      for (let i = 0; i < numOfSps; i++) {\n        let size = data[offset] * 255 + data[offset + 1];\n        offset += 2;\n\n        let sps = new Uint8Array(size);\n        for (let j = 0; j < size; j++) {\n          sps[j] = data[offset + j];\n        }\n\n        // codec string\n        let codecString = 'avc1.';\n        for (let j = 1; j < 4; j++) {\n          let h = sps[j].toString(16);\n          if (h.length < 2) {\n            h = '0' + h;\n          }\n          codecString += h;\n        }\n\n        meta.codec = codecString;\n\n        offset += size;\n        this.tracks.videoTrack.meta.sps = sps;\n        config = _xgplayerCodec.SpsParser.parseSPS(sps);\n      }\n\n      let numOfPps = data[offset];\n\n      offset++;\n\n      for (let i = 0; i < numOfPps; i++) {\n        let size = data[offset] * 255 + data[offset + 1];\n        offset += 2;\n        let pps = new Uint8Array(size);\n        for (let j = 0; j < size; j++) {\n          pps[j] = data[offset + j];\n        }\n        offset += size;\n        this.tracks.videoTrack.meta.pps = pps;\n      }\n\n      Object.assign(meta, _xgplayerCodec.SpsParser.toVideoMeta(config));\n\n      // fill video media info\n      const videoMedia = this._context.mediaInfo.video;\n\n      videoMedia.codec = meta.codec;\n      videoMedia.profile = meta.profile;\n      videoMedia.level = meta.level;\n      videoMedia.chromaFormat = meta.chromaFormat;\n      videoMedia.frameRate = meta.frameRate;\n      videoMedia.parRatio = meta.parRatio;\n      videoMedia.width = videoMedia.width === meta.presentWidth ? videoMedia.width : meta.presentWidth;\n      videoMedia.height = videoMedia.height === meta.presentHeight ? videoMedia.width : meta.presentHeight;\n\n      meta.duration = this._context.mediaInfo.duration * meta.timescale;\n      meta.avcc = new Uint8Array(data.length);\n      meta.avcc.set(data);\n      track.meta = meta;\n    }\n\n    /**\n     * choose audio sample rate\n     * @param samplingFrequencyIndex\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_switchAudioSampleRate',\n    value: function _switchAudioSampleRate(samplingFrequencyIndex) {\n      let samplingFrequencyList = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n      return samplingFrequencyList[samplingFrequencyIndex];\n    }\n\n    /**\n     * choose audio sampling frequence\n     * @param info\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_switchAudioSamplingFrequency',\n    value: function _switchAudioSamplingFrequency(info) {\n      let samplingFrequencyIndex = (info & 12) >>> 2;\n      let samplingFrequencyList = [5500, 11025, 22050, 44100, 48000];\n      return samplingFrequencyList[samplingFrequencyIndex];\n    }\n\n    /**\n     * choose audio channel count\n     * @param info\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: '_switchAudioChannel',\n    value: function _switchAudioChannel(info) {\n      let sampleTrackNumIndex = info & 1;\n      let sampleTrackNumList = [1, 2];\n      return sampleTrackNumList[sampleTrackNumIndex];\n    }\n\n    /**\n     * check datasize is valid use 4 Byte after current tag\n     * @param datasize\n     * @returns {boolean}\n     * @private\n     */\n\n  }, {\n    key: '_datasizeValidator',\n    value: function _datasizeValidator(datasize) {\n      let datasizeConfirm = this.loaderBuffer.toInt(0, 4);\n      this.loaderBuffer.shift(4);\n      return datasizeConfirm === datasize + 11;\n    }\n  }, {\n    key: 'loaderBuffer',\n    get: function () {\n      const buffer = this._context.getInstance('LOADER_BUFFER');\n      if (buffer) {\n        return buffer;\n      } else {\n        this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error('找不到 loaderBuffer 实例'));\n      }\n    }\n  }, {\n    key: 'tracks',\n    get: function () {\n      return this._context.getInstance('TRACKS');\n    }\n  }, {\n    key: 'logger',\n    get: function () {\n      return this._context.getInstance('LOGGER');\n    }\n  }], [{\n    key: 'isFlvFile',\n    value: function isFlvFile(data) {\n      return !(data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01);\n    }\n\n    /**\n     * If the stream has audio or video.\n     * @param {number} streamFlag - Data from the stream which is define whether the audio / video track is exist.\n     */\n\n  }, {\n    key: 'getPlayType',\n    value: function getPlayType(streamFlag) {\n      const result = {\n        hasVideo: false,\n        hasAudio: false\n      };\n\n      if (streamFlag & 0x01 > 0) {\n        result.hasVideo = true;\n      }\n\n      if (streamFlag & 0x04 > 0) {\n        result.hasAudio = true;\n      }\n\n      return result;\n    }\n  }]);\n\n  return FlvDemuxer;\n}();\n\nexports.default = FlvDemuxer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/flv/index.js?")},"../xgplayer-demux/src/hls/demuxer/m3u8parser.js":
/*!*******************************************************!*\
  !*** ../xgplayer-demux/src/hls/demuxer/m3u8parser.js ***!
  \*******************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Reference: https://tools.ietf.org/html/rfc8216#section-4.3\n */\nlet M3U8Parser = function () {\n  function M3U8Parser() {\n    _classCallCheck(this, M3U8Parser);\n  }\n\n  _createClass(M3U8Parser, null, [{\n    key: 'parse',\n    value: function parse(text) {\n      let baseurl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      let ret = {\n        duration: 0\n      };\n      if (!text || !text.split) {\n        return;\n      }\n      let refs = text.split(/\\r|\\n/);\n      refs = refs.filter(ref => {\n        return ref;\n      });\n      let ref = refs.shift();\n      if (!ref.match('#EXTM3U')) {\n        throw new Error(`Invalid m3u8 file: not \"#EXTM3U\"`);\n        return null;\n      }\n      ref = refs.shift();\n      while (ref) {\n        let refm = ref.match(/#(.[A-Z|-]*):(.*)/);\n        let refd = ref.match(/#(.[A-Z|-]*)/);\n        if (refd && refm && refm.length > 2) {\n          switch (refm[1]) {\n            case 'EXT-X-VERSION':\n              ret.version = parseInt(refm[2]);\n              break;\n            case 'EXT-X-MEDIA-SEQUENCE':\n              ret.sequence = parseInt(refm[2]);\n              break;\n            case 'EXT-X-TARGETDURATION':\n              ret.targetduration = parseFloat(refm[2]);\n              break;\n            case 'EXTINF':\n              M3U8Parser.parseFrag(refm, refs, ret, baseurl);\n              break;\n            case 'EXT-X-KEY':\n              M3U8Parser.parseDecrypt(refm[2], ret);\n              break;\n            default:\n              break;\n          }\n        }if (refd && refd.length > 1) {\n          switch (refd[1]) {\n            case 'EXT-X-DISCONTINUITY':\n              ref = refs.shift();\n              let refm = ref.match(/#(.[A-Z|-]*):(.*)/);\n              if (refm.length > 2 && refm[1] === 'EXTINF') {\n                M3U8Parser.parseFrag(refm, refs, ret, baseurl, true);\n              }\n              break;\n            default:\n              break;\n          }\n        }\n        ref = refs.shift();\n      }\n      return ret;\n    }\n  }, {\n    key: 'parseFrag',\n    value: function parseFrag(refm, refs, ret, baseurl, discontinue) {\n      if (!ret.frags) {\n        ret.frags = [];\n      }\n\n      let freg = {\n        start: ret.duration,\n        duration: parseFloat(refm[2]) * 1000\n      };\n\n      ret.duration += freg.duration;\n      let nextline = refs.shift();\n      if (nextline.match(/#(.*):(.*)/)) {\n        nextline = refs.shift();\n      }\n      if (nextline.length > 0 && nextline.charAt(0) === '/' && baseurl.match(/.*\\/\\/.*\\.\\w+/g)) {\n        baseurl = baseurl.match(/.*\\/\\/.*\\.\\w+/g)[0];\n      }\n      if (nextline.match(/.*:\\/\\/.*/)) {\n        freg.url = nextline;\n      } else {\n        freg.url = baseurl + nextline;\n      }\n      freg.discontinue = discontinue;\n      ret.frags.push(freg);\n    }\n  }, {\n    key: 'parseURL',\n    value: function parseURL(url) {\n      let baseurl = '';\n      let urls = url.match(/(.*\\/).*\\.m3u8/);\n      if (urls && urls.length > 0) {\n        for (let i = 0; i < urls.length; i++) {\n          if (urls[i].match(/.*\\/$/g) && urls[i].length > baseurl.length) {\n            baseurl = urls[i];\n          }\n        }\n      }\n      return baseurl;\n    }\n  }, {\n    key: 'parseDecrypt',\n    value: function parseDecrypt(refm, ret) {\n      ret.encrypt = {};\n      let refs = refm.split(',');\n      for (let i in refs) {\n        let cmd = refs[i];\n        if (cmd.match(/METHOD=(.*)/)) {\n          ret.encrypt.method = cmd.match(/METHOD=(.*)/)[1];\n        }\n        if (cmd.match(/URI=\"(.*)\"/)) {\n          ret.encrypt.uri = cmd.match(/URI=\"(.*)\"/)[1];\n        }\n\n        if (cmd.match(/IV=0x(.*)/)) {\n          let iv = cmd.match(/IV=0x(.*)/)[1];\n          let length = Math.ceil(iv.length / 2);\n          ret.encrypt.ivb = new Uint8Array(length);\n          for (let i = length - 1; i >= 0; i--) {\n            let im = parseInt(iv.substr(i * 2, 2), 16);\n            ret.encrypt.ivb[i] = im;\n          }\n          ret.encrypt.iv = iv;\n        }\n      };\n    }\n  }]);\n\n  return M3U8Parser;\n}();\n\nexports.default = M3U8Parser;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/hls/demuxer/m3u8parser.js?")},"../xgplayer-demux/src/hls/demuxer/ts.js":
/*!***********************************************!*\
  !*** ../xgplayer-demux/src/hls/demuxer/ts.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _xgplayerCodec = __webpack_require__(/*! xgplayer-codec */ \"../xgplayer-codec/index.js\");\n\nvar _xgplayerBuffer = __webpack_require__(/*! xgplayer-buffer */ \"../xgplayer-buffer/index.js\");\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nconst DEMUX_EVENTS = _xgplayerUtils.EVENTS.DEMUX_EVENTS;\nconst StreamType = {\n  0x01: ['video', 'MPEG-1'],\n  0x02: ['video', 'MPEG-2'],\n  0x1b: ['video', 'AVC.H264'],\n  0xea: ['video', 'VC-1'],\n  0x03: ['audio', 'MPEG-1'],\n  0x04: ['audio', 'MPEG-2'],\n  0x0f: ['audio', 'MPEG-2.AAC'],\n  0x11: ['audio', 'MPEG-4.AAC'],\n  0x80: ['audio', 'LPCM'],\n  0x81: ['audio', 'AC3'],\n  0x06: ['audio', 'AC3'],\n  0x82: ['audio', 'DTS'],\n  0x83: ['audio', 'Dolby TrueHD'],\n  0x84: ['audio', 'AC3-Plus'],\n  0x85: ['audio', 'DTS-HD'],\n  0x86: ['audio', 'DTS-MA'],\n  0xa1: ['audio', 'AC3-Plus-SEC'],\n  0xa2: ['audio', 'DTS-HD-SEC']\n};\n\nlet TsDemuxer = function () {\n  function TsDemuxer(configs) {\n    _classCallCheck(this, TsDemuxer);\n\n    this.configs = Object.assign({}, configs);\n    this.demuxing = false;\n    this.pat = [];\n    this.pmt = [];\n    this._hasVideoMeta = false;\n    this._hasAudioMeta = false;\n  }\n\n  _createClass(TsDemuxer, [{\n    key: 'init',\n    value: function init() {\n      this.on(DEMUX_EVENTS.DEMUX_START, this.demux.bind(this));\n    }\n  }, {\n    key: 'demux',\n    value: function demux(frag) {\n      if (this.demuxing) {\n        return;\n      }\n\n      let buffer = this.inputBuffer;\n      let frags = { pat: [], pmt: [] };\n      let peses = {};\n\n      // Read TS segment\n      while (buffer.length >= 188) {\n        if (buffer.length >= 1 && buffer.array[0][buffer.offset] !== 71) {\n          this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`Untrust sync code: ${buffer.array[0][buffer.offset]}, try to recover;`), false);\n        }\n        while (buffer.length >= 1 && buffer.array[0][buffer.offset] !== 71) {\n          buffer.shift(1);\n        }\n        let buf = buffer.shift(188);\n        // console.log(buf);\n        let tsStream = new _xgplayerUtils.Stream(buf.buffer);\n        let ts = {};\n        TsDemuxer.read(tsStream, ts, frags);\n        if (ts.pes) {\n          if (!peses[ts.header.pid]) {\n            peses[ts.header.pid] = [];\n          }\n          peses[ts.header.pid].push(ts.pes);\n          ts.pes.ES.buffer = [ts.pes.ES.buffer];\n        } else if (peses[ts.header.pid]) {\n          peses[ts.header.pid][peses[ts.header.pid].length - 1].ES.buffer.push(ts.payload.stream);\n        }\n      }\n\n      let AudioOptions = frag;\n      let VideoOptions = frag;\n\n      // Get Frames data\n      for (let i = 0; i < Object.keys(peses).length; i++) {\n        let epeses = peses[Object.keys(peses)[i]];\n        for (let j = 0; j < epeses.length; j++) {\n          epeses[j].id = Object.keys(peses)[i];\n          epeses[j].ES.buffer = TsDemuxer.Merge(epeses[j].ES.buffer);\n          if (epeses[j].type === 'audio') {\n            this.pushAudioSample(epeses[j], AudioOptions);\n            AudioOptions = {};\n          } else if (epeses[j].type === 'video') {\n            this.pushVideoSample(epeses[j], VideoOptions);\n            VideoOptions = {};\n          }\n        }\n      }\n\n      if (this._hasAudioMeta) {\n        this.emit(DEMUX_EVENTS.DEMUX_COMPLETE, 'audio');\n      }\n      if (this._hasVideoMeta) {\n        this.emit(DEMUX_EVENTS.DEMUX_COMPLETE, 'video');\n      }\n    }\n  }, {\n    key: 'pushAudioSample',\n    value: function pushAudioSample(pes, options) {\n      let track;\n      if (!this._tracks.audioTrack) {\n        this._tracks.audioTrack = new _xgplayerBuffer.AudioTrack();\n        track = this._tracks.audioTrack;\n      } else {\n        track = this._tracks.audioTrack;\n      }\n      let meta = new _xgplayerUtils.AudioTrackMeta({\n        audioSampleRate: pes.ES.frequence,\n        sampleRate: pes.ES.frequence,\n        channelCount: pes.ES.channel,\n        codec: 'mp4a.40.' + pes.ES.audioObjectType,\n        config: pes.ES.audioConfig,\n        id: 2,\n        sampleRateIndex: pes.ES.frequencyIndex\n      });\n      meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);\n\n      let metaEqual = TsDemuxer.compaireMeta(track.meta, meta, true);\n\n      if (!this._hasAudioMeta || !metaEqual) {\n        track.meta = meta;\n        this._hasAudioMeta = true;\n        this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n      }\n\n      let data = new Uint8Array(pes.ES.buffer.buffer.slice(pes.ES.buffer.position, pes.ES.buffer.length));\n      let dts = parseInt(pes.pts / 90);\n      let pts = parseInt(pes.pts / 90);\n      let sample = new _xgplayerUtils.AudioTrackSample({ dts, pts, data, options });\n      track.samples.push(sample);\n    }\n  }, {\n    key: 'pushVideoSample',\n    value: function pushVideoSample(pes, options) {\n      let nals = _xgplayerCodec.Nalunit.getNalunits(pes.ES.buffer);\n      let track;\n      let meta = new _xgplayerUtils.VideoTrackMeta();\n      if (!this._tracks.videoTrack) {\n        this._tracks.videoTrack = new _xgplayerBuffer.VideoTrack();\n        track = this._tracks.videoTrack;\n      } else {\n        track = this._tracks.videoTrack;\n      }\n      let sampleLength = 0;\n      let sps = false;\n      let pps = false;\n      for (let i = 0; i < nals.length; i++) {\n        let nal = nals[i];\n        if (nal.sps) {\n          sps = nal;\n          track.sps = nal.body;\n          meta.chromaFormat = sps.sps.chroma_format;\n          meta.codec = 'avc1.';\n          for (var j = 1; j < 4; j++) {\n            var h = sps.body[j].toString(16);\n            if (h.length < 2) {\n              h = '0' + h;\n            }\n            meta.codec += h;\n          }\n          meta.codecHeight = sps.sps.codec_size.height;\n          meta.codecWidth = sps.sps.codec_size.width;\n          meta.frameRate = sps.sps.frame_rate;\n          meta.id = 1;\n          meta.level = sps.sps.level_string;\n          meta.presentHeight = sps.sps.present_size.height;\n          meta.presentWidth = sps.sps.present_size.width;\n          meta.profile = sps.sps.profile_string;\n          meta.refSampleDuration = Math.floor(meta.timescale * (sps.sps.frame_rate.fps_den / sps.sps.frame_rate.fps_num));\n          meta.sarRatio = sps.sps.sar_ratio ? sps.sps.sar_ratio : sps.sps.par_ratio;\n        } else if (nal.pps) {\n          track.pps = nal.body;\n          pps = nal;\n        } else {\n          sampleLength += 4 + nal.body.byteLength;\n        }\n      }\n\n      if (sps && pps) {\n        meta.avcc = _xgplayerCodec.Nalunit.getAvcc(sps.body, pps.body);\n        let metaEqual = TsDemuxer.compaireMeta(track.meta, meta, true);\n        if (!this._hasVideoMeta || !metaEqual) {\n          if (options) {\n            options.meta = Object.assign({}, meta);\n          } else {\n            options = {\n              meta: Object.assign({}, meta)\n            };\n          }\n          track.meta = meta;\n          this._hasVideoMeta = true;\n          this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n        }\n      }\n\n      let data = new Uint8Array(sampleLength);\n      let offset = 0;\n      let isKeyframe = false;\n      for (let i = 0; i < nals.length; i++) {\n        let nal = nals[i];\n        let length = nal.body.byteLength;\n        if (nal.idr) {\n          isKeyframe = true;\n        }\n        if (!nal.pps && !nal.sps) {\n          data.set(new Uint8Array([length >>> 24 & 0xff, length >>> 16 & 0xff, length >>> 8 & 0xff, length & 0xff]), offset);\n          offset += 4;\n          data.set(nal.body, offset);\n          offset += length;\n        }\n      }\n      let sample = new _xgplayerUtils.VideoTrackSample({\n        dts: parseInt(pes.dts / 90),\n        pts: parseInt(pes.pts / 90),\n        cts: (pes.pts - pes.dts) / 90,\n        originDts: pes.dts,\n        isKeyframe,\n        data,\n        options\n      });\n      track.samples.push(sample);\n    }\n  }, {\n    key: 'destory',\n    value: function destory() {\n      this.off(DEMUX_EVENTS.DEMUX_START, this.demux);\n      this.configs = {};\n      this.demuxing = false;\n      this.pat = [];\n      this.pmt = [];\n      this._hasVideoMeta = false;\n      this._hasAudioMeta = false;\n    }\n  }, {\n    key: 'inputBuffer',\n    get: function () {\n      return this._context.getInstance(this.configs.inputbuffer);\n    }\n  }, {\n    key: '_tracks',\n    get: function () {\n      return this._context.getInstance('TRACKS');\n    }\n  }], [{\n    key: 'compaireArray',\n    value: function compaireArray(a, b, type) {\n      let al = 0;\n      let bl = 0;\n      if (type === 'Uint8Array') {\n        al = a.byteLength;\n        bl = b.byteLength;\n      } else if (type === 'Array') {\n        al = a.length;\n        bl = b.length;\n      }\n      if (al !== bl) {\n        return false;\n      }\n\n      for (let i = 0; i < al; i++) {\n        if (a[i] !== b[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compaireMeta',\n    value: function compaireMeta(a, b, ignoreDuration) {\n      if (!a || !b) {\n        return false;\n      }\n\n      for (let i = 0, k = Object.keys(a).length; i < k; i++) {\n        let itema = a[Object.keys(a)[i]];\n        let itemb = b[Object.keys(a)[i]];\n        if (typeof itema !== 'object') {\n          if (ignoreDuration && Object.keys(a)[i] !== 'duration' && Object.keys(a)[i] !== 'refSampleDuration' && Object.keys(a)[i] !== 'refSampleDurationFixed' && itema !== itemb) {\n            return false;\n          }\n        } else if (itema.byteLength !== undefined) {\n          if (itemb.byteLength === undefined) {\n            return false;\n          }\n          if (!TsDemuxer.compaireArray(itema, itemb, 'Uint8Array')) {\n            return false;\n          }\n        } else if (itema.length !== undefined) {\n          if (itemb.length === undefined) {\n            return false;\n          }\n          if (!TsDemuxer.compaireArray(itema, itemb, 'Array')) {\n            return false;\n          }\n        } else {\n          if (!TsDemuxer.compaireMeta(itema, itemb)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'Merge',\n    value: function Merge(buffers) {\n      let data;\n      let length = 0;\n      let offset = 0;\n      for (let i = 0; i < buffers.length; i++) {\n        length += buffers[i].length - buffers[i].position;\n      }\n\n      data = new Uint8Array(length);\n      for (let i = 0; i < buffers.length; i++) {\n        let buffer = buffers[i];\n        data.set(new Uint8Array(buffer.buffer, buffer.position), offset);\n        offset += buffer.length - buffer.position;\n      }\n      return new _xgplayerUtils.Stream(data.buffer);\n    }\n  }, {\n    key: 'read',\n    value: function read(stream, ts, frags) {\n      TsDemuxer.readHeader(stream, ts);\n      TsDemuxer.readPayload(stream, ts, frags);\n      if (ts.header.packet === 'MEDIA' && ts.header.payload === 1 && !ts.unknownPIDs) {\n        ts.pes = TsDemuxer.PES(ts);\n      }\n    }\n  }, {\n    key: 'readPayload',\n    value: function readPayload(stream, ts, frags) {\n      let header = ts.header;\n      let pid = header.pid;\n      switch (pid) {\n        case 0:\n          TsDemuxer.PAT(stream, ts, frags);\n          break;\n        case 1:\n          TsDemuxer.CAT(stream, ts, frags);\n          break;\n        case 2:\n          TsDemuxer.TSDT(stream, ts, frags);\n          break;\n        case 0x1fff:\n          break;\n        default:\n          // TODO: some的写法不太好，得改\n          if (frags.pat.some(item => {\n            return item.pid === pid;\n          })) {\n            TsDemuxer.PMT(stream, ts, frags);\n          } else {\n            let sts = frags.pmt ? frags.pmt.filter(item => item.pid === pid) : [];\n            if (sts.length > 0) {\n              TsDemuxer.Media(stream, ts, StreamType[sts[0].streamType][0]);\n            } else {\n              ts.unknownPIDs = true;\n            };\n          }\n      }\n    }\n  }, {\n    key: 'readHeader',\n    value: function readHeader(stream, ts) {\n      let header = {};\n      header.sync = stream.readUint8();\n      let next = stream.readUint16();\n      header.error = next >>> 15;\n      header.payload = next >>> 14 & 1;\n      header.priority = next >>> 13 & 1;\n      header.pid = next & 0x1fff;\n\n      next = stream.readUint8();\n\n      header.scrambling = next >> 6 & 0x3; // 是否加密，00表示不加密\n\n      /**\n       * 00 ISO/IEC未来使用保留\n       * 01 没有调整字段，仅含有184B有效净荷\n       * 02 没有有效净荷，仅含有183B调整字段\n       * 03 0~182B调整字段后为有效净荷\n       */\n      header.adaptation = next >> 4 & 0x3;\n      header.continuity = next & 15;\n      header.packet = header.pid === 0 ? 'PAT' : 'MEDIA';\n      ts.header = header;\n    }\n  }, {\n    key: 'PAT',\n    value: function PAT(stream, ts, frags) {\n      let ret = {};\n      let next = stream.readUint8();\n      stream.skip(next);\n      next = stream.readUint8();\n      ret.tabelID = next;\n      next = stream.readUint16();\n      ret.error = next >>> 7;\n      ret.zero = next >>> 6 & 1;\n      ret.sectionLength = next & 0xfff;\n      ret.streamID = stream.readUint16();\n      ret.current = stream.readUint8() & 1;\n      ret.sectionNumber = stream.readUint8();\n      ret.lastSectionNumber = stream.readUint8();\n      let N = (ret.sectionLength - 9) / 4;\n      let list = [];\n      for (let i = 0; i < N; i++) {\n        let programNumber = stream.readUint16();\n        let pid = stream.readUint16() & 0x1fff;\n        list.push({\n          program: programNumber,\n          pid,\n          type: programNumber === 0 ? 'network' : 'mapPID'\n        });\n      }\n      if (list.length > 0) {\n        frags.pat = frags.pat.concat(list);\n      }\n      ret.list = list;\n      ret.program = stream.readUint16();\n      ret.pid = stream.readUint16() & 0x1fff;\n      ts.payload = ret;\n      // TODO CRC\n    }\n  }, {\n    key: 'PMT',\n    value: function PMT(stream, ts, frags) {\n      let ret = {};\n      let header = ts.header;\n      header.packet = 'PMT';\n      let next = stream.readUint8();\n      stream.skip(next);\n      next = stream.readUint8();\n      ret.tableID = next;\n      next = stream.readUint16();\n      ret.sectionLength = next & 0xfff;\n      ret.program = stream.readUint16();\n      ret.current = stream.readUint8() & 1;\n      ret.order = stream.readUint8();\n      ret.lastOrder = stream.readUint8();\n      ret.PCR_PID = stream.readUint16() & 0x1fff;\n      ret.programLength = stream.readUint16() & 0xfff;\n      let N = (ret.sectionLength - 13) / 5;\n      let list = [];\n      for (let i = 0; i < N; i++) {\n        list.push({\n          streamType: stream.readUint8(),\n          pid: stream.readUint16() & 0x1fff, // 0x07e5 视频，0x07e6\n          es: stream.readUint16() & 0xfff\n        });\n      }\n      ret.list = list;\n      if (!this.pmt) {\n        this.pmt = [];\n      }\n      frags.pmt = this.pmt.concat(list.map(item => {\n        return {\n          pid: item.pid,\n          es: item.es,\n          streamType: item.streamType,\n          program: ret.program\n        };\n      }));\n      ts.payload = ret;\n    }\n  }, {\n    key: 'Media',\n    value: function Media(stream, ts, type) {\n      let header = ts.header;\n      let payload = {};\n      header.type = type;\n      if (header.adaptation === 0x03) {\n        payload.adaptationLength = stream.readUint8();\n        if (payload.adaptationLength > 0) {\n          let next = stream.readUint8();\n          payload.discontinue = next >>> 7;\n          payload.access = next >>> 6 & 0x01;\n          payload.priority = next >>> 5 & 0x01;\n          payload.PCR = next >>> 4 & 0x01;\n          payload.OPCR = next >>> 3 & 0x01;\n          payload.splicePoint = next >>> 2 & 0x01;\n          payload.transportPrivate = next >>> 1 & 0x01;\n          payload.adaptationField = next & 0x01;\n          let _start = stream.position;\n          if (payload.PCR === 1) {\n            payload.programClockBase = stream.readUint32() << 1;\n            next = stream.readUint16();\n            payload.programClockBase |= next >>> 15;\n            payload.programClockExtension = next & 0x1ff;\n          }\n          if (payload.OPCR === 1) {\n            payload.originProgramClockBase = stream.readUint32() << 1;\n            next = stream.readUint16();\n            payload.originProgramClockBase += next >>> 15;\n            payload.originProgramClockExtension = next & 0x1ff;\n          }\n          if (payload.splicePoint === 1) {\n            payload.spliceCountdown = stream.readUint8();\n          }\n          if (payload.transportPrivate === 1) {\n            let length = stream.readUint8();\n            let transportPrivateData = [];\n            for (let i = 0; i < length; i++) {\n              transportPrivateData.push(stream.readUint8());\n            }\n          }\n          if (payload.adaptationField === 1) {\n            let length = stream.readUint8();\n            let next = stream.readUint8();\n            let start = stream.position;\n            let ltw = next >>> 7;\n            let piecewise = next >>> 6 & 0x1;\n            let seamless = next >>> 5 & 0x1;\n            if (ltw === 1) {\n              next = stream.readUint16();\n              payload.ltwValid = next >>> 15;\n              payload.ltwOffset = next & 0xefff;\n            }\n            if (piecewise === 1) {\n              next = stream.readUint24();\n              payload.piecewiseRate = next & 0x3fffff;\n            }\n            if (seamless === 1) {\n              next = stream.readInt8();\n              payload.spliceType = next >>> 4;\n              payload.dtsNextAU1 = next >>> 1 & 0x7;\n              payload.marker1 = next & 0x1;\n              next = stream.readUint16();\n              payload.dtsNextAU2 = next >>> 1;\n              payload.marker2 = next & 0x1;\n              next = stream.readUint16();\n              payload.dtsNextAU3 = next;\n            }\n            stream.skip(length - 1 - (stream.position - start));\n          }\n          let lastStuffing = payload.adaptationLength - 1 - (stream.position - _start);\n          stream.skip(lastStuffing);\n        }\n      }\n      payload.stream = new _xgplayerUtils.Stream(stream.buffer.slice(stream.position));\n      ts.payload = payload;\n    }\n  }, {\n    key: 'PES',\n    value: function PES(ts) {\n      let ret = {};\n      let buffer = ts.payload.stream;\n\n      let next = buffer.readUint24();\n      if (next !== 1) {\n        ret.ES = {};\n        ret.ES.buffer = buffer;\n      } else {\n        let streamID = buffer.readUint8();\n        if (streamID >= 0xe0 && streamID <= 0xef) {\n          ret.type = 'video';\n        }\n        if (streamID >= 0xc0 && streamID <= 0xdf) {\n          ret.type = 'audio';\n        }\n        let packetLength = buffer.readUint16();\n        ret.packetLength = packetLength;\n        if (ret.type === 'video' || ret.type === 'audio') {\n          let next = buffer.readUint8();\n          let first = next >>> 6;\n          if (first !== 0x02) {\n            throw new Error('error when parse pes header');\n          }\n          next = buffer.readUint8();\n          ret.ptsDTSFlag = next >>> 6;\n          ret.escrFlag = next >>> 5 & 0x01;\n          ret.esRateFlag = next >>> 4 & 0x01;\n          ret.dsmFlag = next >>> 3 & 0x01;\n          ret.additionalFlag = next >>> 2 & 0x01;\n          ret.crcFlag = next >>> 1 & 0x01;\n          ret.extensionFlag = next & 0x01;\n          ret.pesHeaderLength = buffer.readUint8();\n          let N1 = ret.pesHeaderLength;\n\n          if (ret.ptsDTSFlag === 2) {\n            let pts = [];\n            next = buffer.readUint8();\n            pts.push(next >>> 1 & 0x07);\n            next = buffer.readUint16();\n            pts.push(next >>> 1);\n            next = buffer.readUint16();\n            pts.push(next >>> 1);\n            ret.pts = pts[0] << 30 | pts[1] << 15 | pts[2];\n            N1 -= 5;\n            // 视频如果没有dts用pts\n            if (ret.type === 'video') {\n              ret.dts = ret.pts;\n            }\n          }\n          if (ret.ptsDTSFlag === 3) {\n            let pts = [];\n            next = buffer.readUint8();\n            pts.push(next >>> 1 & 0x07);\n            next = buffer.readUint16();\n            pts.push(next >>> 1);\n            next = buffer.readUint16();\n            pts.push(next >>> 1);\n            ret.pts = pts[0] << 30 | pts[1] << 15 | pts[2];\n            let dts = [];\n            next = buffer.readUint8();\n            dts.push(next >>> 1 & 0x07);\n            next = buffer.readUint16();\n            dts.push(next >>> 1);\n            next = buffer.readUint16();\n            dts.push(next >>> 1);\n            ret.dts = dts[0] << 30 | dts[1] << 15 | dts[2];\n            N1 -= 10;\n          }\n          if (ret.escrFlag === 1) {\n            let escr = [];\n            let ex = [];\n            next = buffer.readUint8();\n            escr.push(next >>> 3 & 0x07);\n            escr.push(next & 0x03);\n            next = buffer.readUint16();\n            escr.push(next >>> 13);\n            escr.push(next & 0x03);\n            next = buffer.readUint16();\n            escr.push(next >>> 13);\n            ex.push(next & 0x03);\n            next = buffer.readUint8();\n            ex.push(next >>> 1);\n            ret.escr = (escr[0] << 30 | escr[1] << 28 | escr[2] << 15 | escr[3] << 13 | escr[4]) * 300 + (ex[0] << 7 | ex[1]);\n            N1 -= 6;\n          }\n          if (ret.esRateFlag === 1) {\n            next = buffer.readUint24();\n            ret.esRate = next >>> 1 & 0x3fffff;\n            N1 -= 3;\n          }\n          if (ret.dsmFlag === 1) {\n            throw new Error('not support DSM_trick_mode');\n          }\n          if (ret.additionalFlag === 1) {\n            next = buffer.readUint8();\n            ret.additionalCopyInfo = next & 0x7f;\n            N1 -= 1;\n          }\n          if (ret.crcFlag === 1) {\n            ret.pesCRC = buffer.readUint16();\n            N1 -= 2;\n          }\n          if (ret.extensionFlag === 1) {\n            throw new Error('not support extension');\n          }\n          if (N1 > 0) {\n            buffer.skip(N1);\n          }\n          ret.ES = TsDemuxer.ES(buffer, ret.type);\n        } else {\n          throw new Error('format is not supported');\n        }\n      }\n      return ret;\n    }\n  }, {\n    key: 'ES',\n    value: function ES(buffer, type) {\n      let next;\n      let ret = {};\n      if (type === 'video') {\n        next = buffer.readUint32();\n        if (next !== 1) {\n          buffer.back(4);\n          next = buffer.readUint24();\n          if (next !== 1) {\n            throw new Error('h264 nal header parse failed');\n          }\n        }\n        buffer.skip(2); // 09 F0\n        // TODO readnalu\n        ret.buffer = buffer;\n      } else if (type === 'audio') {\n        next = buffer.readUint16();\n        // adts的同步字节，12位\n        if (next >>> 4 !== 0xfff) {\n          throw new Error('aac ES parse Error');\n        }\n        const fq = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n        ret.id = (next >>> 3 & 0x01) === 0 ? 'MPEG-4' : 'MPEG-2';\n        ret.layer = next >>> 1 & 0x03;\n        ret.absent = next & 0x01;\n        next = buffer.readUint16();\n        ret.audioObjectType = (next >>> 14 & 0x03) + 1;\n        ret.profile = ret.audioObjectType - 1;\n        ret.frequencyIndex = next >>> 10 & 0x0f;\n        ret.frequence = fq[ret.frequencyIndex];\n        ret.channel = next >>> 6 & 0x07;\n        ret.frameLength = (next & 0x03) << 11 | buffer.readUint16() >>> 5;\n        TsDemuxer.getAudioConfig(ret);\n        buffer.skip(1);\n        ret.buffer = buffer;\n      } else {\n        throw new Error(`ES ${type} is not supported`);\n      }\n\n      return ret;\n    }\n  }, {\n    key: 'TSDT',\n    value: function TSDT(stream, ts, frags) {\n      // TODO\n      ts.payload = {};\n    }\n  }, {\n    key: 'CAT',\n    value: function CAT(stream, ts, frags) {\n      let ret = {};\n      ret.tableID = stream.readUint8();\n      let next = stream.readUint16();\n      ret.sectionIndicator = next >>> 7;\n      ret.sectionLength = next & 0x0fff;\n      stream.skip(2);\n      next = stream.readUint8();\n      ret.version = next >>> 3;\n      ret.currentNextIndicator = next & 0x01;\n      ret.sectionNumber = stream.readUint8();\n      ret.lastSectionNumber = stream.readUint8();\n      let N = (this.sectionLength - 9) / 4;\n      let list = [];\n      for (let i = 0; i < N; i++) {\n        list.push({});\n      }\n      ret.crc32 = stream.readUint32();\n      ts.payload = ret;\n    }\n  }, {\n    key: 'getAudioConfig',\n    value: function getAudioConfig(ret) {\n      let userAgent = navigator.userAgent.toLowerCase();\n      let config;\n      let extensionSampleIndex;\n      if (/firefox/i.test(userAgent)) {\n        if (ret.frequencyIndex >= 6) {\n          ret.audioObjectType = 5;\n          config = new Array(4);\n          extensionSampleIndex = ret.frequencyIndex - 3;\n        } else {\n          ret.audioObjectType = 2;\n          config = new Array(2);\n          extensionSampleIndex = ret.frequencyIndex;\n        }\n      } else if (userAgent.indexOf('android') !== -1) {\n        ret.audioObjectType = 2;\n        config = new Array(2);\n        extensionSampleIndex = ret.frequencyIndex;\n      } else {\n        ret.audioObjectType = 5;\n        config = new Array(4);\n        if (ret.frequencyIndex >= 6) {\n          extensionSampleIndex = ret.frequencyIndex - 3;\n        } else {\n          if (ret.channel === 1) {\n            ret.audioObjectType = 2;\n            config = new Array(2);\n          }\n          extensionSampleIndex = ret.frequencyIndex;\n        }\n      }\n\n      config[0] = ret.audioObjectType << 3;\n      config[0] |= (ret.frequencyIndex & 0x0e) >> 1;\n      config[1] = (ret.frequencyIndex & 0x01) << 7;\n      config[1] |= ret.channel << 3;\n      if (ret.audioObjectType === 5) {\n        config[1] |= (extensionSampleIndex & 0x0e) >> 1;\n        config[2] = (extensionSampleIndex & 0x01) << 7;\n        config[2] |= 2 << 2;\n        config[3] = 0;\n      }\n      ret.audioConfig = config;\n    }\n  }]);\n\n  return TsDemuxer;\n}();\n\nexports.default = TsDemuxer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/hls/demuxer/ts.js?")},"../xgplayer-demux/src/hls/playlist.js":
/*!*********************************************!*\
  !*** ../xgplayer-demux/src/hls/playlist.js ***!
  \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet Playlist = function () {\n  function Playlist(configs) {\n    _classCallCheck(this, Playlist);\n\n    this._baseURL = '';\n    this._list = {};\n    this._ts = {};\n    this.version = 0;\n    this.sequence = -1;\n    this.targetduration = 0;\n    this.duration = 0;\n    this.fragLength = 0;\n    this._lastget = undefined;\n    this._audoclear = configs.autoclear || false;\n  }\n\n  _createClass(Playlist, [{\n    key: 'push',\n    value: function push(ts, duration, discontinue) {\n      if (!this._ts[ts]) {\n        this._ts[ts] = { duration: duration,\n          downloaded: false,\n          downloading: false,\n          start: this.duration,\n          discontinue: discontinue ? true : false\n        };\n        this._list[this.duration] = ts;\n        this.duration += duration;\n        this.fragLength += 1;\n      }\n    }\n  }, {\n    key: 'deleteFrag',\n    value: function deleteFrag(url) {\n      if (this._ts[url]) {\n        if (this._ts[url].start > this._lastget.time) {\n          this._lastget = {\n            duration: this._ts[url].duration,\n            time: this._ts[url].start,\n            downloaded: false,\n            downloading: false,\n            url: url\n          };\n        }\n        delete this._list[this._ts[url].start];\n        delete this._ts[url];\n        this.fragLength -= 1;\n      }\n    }\n  }, {\n    key: 'pushM3U8',\n    value: function pushM3U8(data, deletepre) {\n      // 常规信息替换\n      if (!data) {\n        throw new Error(`No m3u8 data received.`);\n        return;\n      }\n      this.version = data.version;\n      this.targetduration = data.targetduration;\n      if (data.encrypt && !this.encrypt) {\n        this.encrypt = data.encrypt;\n      }\n      // 新分片信息\n      if (data.sequence > this.sequence) {\n        this.sequence = data.sequence;\n        let newfraglist = [];\n        for (let i = 0; i < data.frags.length; i++) {\n          let frag = data.frags[i];\n          if (!this._ts[frag.url]) {\n            newfraglist.push(frag.url);\n            this.push(frag.url, frag.duration, frag.discontinue);\n          }\n        }\n\n        if (newfraglist.length < 1) {\n          throw new Error(`Can not read ts file list.`);\n        }\n\n        if (deletepre) {\n          let tslist = this.getTsList();\n          for (let i = 0; i < tslist.length; i++) {\n            if (newfraglist.indexOf(tslist[i]) < 0) {\n              this.deleteFrag(tslist[i]);\n            }\n          }\n        }\n      } else {\n        throw new Error(`Old m3u8 file received, ${data.sequence}`);\n      }\n    }\n  }, {\n    key: 'getTsList',\n    value: function getTsList() {\n      return Object.keys(this._ts);\n    }\n  }, {\n    key: 'downloaded',\n    value: function downloaded(tsname, isloaded) {\n      let ts = this._ts[tsname];\n      if (ts) {\n        ts.downloaded = isloaded;\n      }\n    }\n  }, {\n    key: 'downloading',\n    value: function downloading(tsname, loading) {\n      let ts = this._ts[tsname];\n      if (ts) {\n        ts.downloading = loading;\n      }\n    }\n  }, {\n    key: 'getTsByName',\n    value: function getTsByName(name) {\n      return this._ts[name];\n    }\n  }, {\n    key: 'getTs',\n    value: function getTs(time) {\n      let timelist = Object.keys(this._list);\n      let ts;\n\n      if (time === undefined) {\n        if (this._lastget) {\n          time = this._lastget.time + this._lastget.duration;\n        } else {\n          time = 0;\n        }\n      }\n\n      if (timelist.length < 1 || time >= this.duration) {\n        return undefined;\n      }\n      timelist.sort((a, b) => {\n        return parseFloat(a) - parseFloat(b);\n      });\n      for (let i = 0; i < timelist.length; i++) {\n        if (time >= parseInt(timelist[i])) {\n          let url = this._list[timelist[i]];\n          let downloaded = this._ts[url].downloaded;\n          let downloading = this._ts[url].downloading;\n          ts = { url, downloaded, downloading, time: parseInt(timelist[i]), duration: parseInt(this._ts[url].duration) };\n          if (this.autoclear) {\n            delete this._ts[this._lastget.url];\n            delete this._list[this._lastget.time];\n          }\n          this._lastget = ts;\n        } else {\n          break;\n        }\n      }\n      return ts;\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this._baseURL = '';\n      this._list = {};\n      this._ts = {};\n      this.version = 0;\n      this.sequence = -1;\n      this.targetduration = 0;\n      this.duration = 0;\n    }\n  }, {\n    key: 'clearDownloaded',\n    value: function clearDownloaded() {\n      for (let i = 0, l = Object.keys(this._ts).length; i < l; i++) {\n        let ts = this._ts[Object.keys(this._ts)[i]];\n        ts.downloaded = false;\n        ts.downloading = false;\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._baseURL = '';\n      this._list = {};\n      this._ts = {};\n      this.version = 0;\n      this.sequence = -1;\n      this.targetduration = 0;\n      this.duration = 0;\n      this.fragLength = 0;\n      this._lastget = undefined;\n      this._audoclear = false;\n    }\n  }, {\n    key: 'list',\n    get: function () {\n      return this._list;\n    }\n  }, {\n    key: 'baseURL',\n    set: function (baseURL) {\n      if (this.baseURL !== baseURL) {\n        this.clear();\n        this._baseURL = baseURL;\n      }\n    },\n    get: function () {\n      return this._baseURL;\n    }\n  }]);\n\n  return Playlist;\n}();\n\nexports.default = Playlist;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/hls/playlist.js?")},"../xgplayer-loader/index.js":
/*!***********************************!*\
  !*** ../xgplayer-loader/index.js ***!
  \***********************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = {\n  FetchLoader: __webpack_require__(/*! ./src/fetch-loader */ "../xgplayer-loader/src/fetch-loader.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-loader/index.js?')},"../xgplayer-loader/src/fetch-loader.js":
/*!**********************************************!*\
  !*** ../xgplayer-loader/src/fetch-loader.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nconst LOADER_EVENTS = _xgplayerUtils.EVENTS.LOADER_EVENTS;\nconst READ_STREAM = 0;\nconst READ_TEXT = 1;\nconst READ_JSON = 2;\nconst READ_BUFFER = 3;\n\nlet FetchLoader = function () {\n  function FetchLoader(configs) {\n    _classCallCheck(this, FetchLoader);\n\n    this.configs = Object.assign({}, configs);\n    this.url = null;\n    this.status = 0;\n    this.error = null;\n    this._reader = null;\n    this._canceled = false;\n    this._destroyed = false;\n    this.readtype = this.configs.readtype;\n    this.buffer = this.configs.buffer || 'LOADER_BUFFER';\n    this._loaderTaskNo = 0;\n  }\n\n  _createClass(FetchLoader, [{\n    key: 'init',\n    value: function init() {\n      this.on(LOADER_EVENTS.LADER_START, this.load.bind(this));\n    }\n  }, {\n    key: 'load',\n    value: function load(url, opts) {\n      let _this = this;\n      this.url = url;\n      this._canceled = false;\n\n      // TODO: Add Ranges\n      let params = this.getParams(opts);\n      _this.loading = true;\n      return fetch(this.url, params).then(function (response) {\n        if (response.ok) {\n          _this.status = response.status;\n          return _this._onFetchResponse(response);\n        }\n        _this.loading = false;\n        _this.emit(LOADER_EVENTS.LOADER_ERROR, _this.TAG, new Error(`invalid response.`));\n      }).catch(function (error) {\n        _this.loading = false;\n        _this.emit(LOADER_EVENTS.LOADER_ERROR, _this.TAG, error);\n        throw new Error(error.message);\n      });\n    }\n  }, {\n    key: '_onFetchResponse',\n    value: function _onFetchResponse(response) {\n      let _this = this;\n      let buffer = this._context.getInstance(this.buffer);\n      this._loaderTaskNo++;\n      let taskno = this._loaderTaskNo;\n      if (response.ok === true) {\n        switch (this.readtype) {\n          case READ_JSON:\n            response.json().then(data => {\n              _this.loading = false;\n              if (!_this._canceled && !_this._destroyed) {\n                if (buffer) {\n                  buffer.push(data);\n                  _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n                } else {\n                  _this.emit(LOADER_EVENTS.LOADER_COMPLETE, data);\n                }\n              }\n            });\n            break;\n          case READ_TEXT:\n            response.text().then(data => {\n              _this.loading = false;\n              if (!_this._canceled && !_this._destroyed) {\n                if (buffer) {\n                  buffer.push(data);\n                  _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n                } else {\n                  _this.emit(LOADER_EVENTS.LOADER_COMPLETE, data);\n                }\n              }\n            });\n            break;\n          case READ_BUFFER:\n            response.arrayBuffer().then(data => {\n              _this.loading = false;\n              if (!_this._canceled && !_this._destroyed) {\n                if (buffer) {\n                  buffer.push(new Uint8Array(data));\n                  _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n                } else {\n                  _this.emit(LOADER_EVENTS.LOADER_COMPLETE, data);\n                }\n              }\n            });\n            break;\n          case READ_STREAM:\n          default:\n            return this._onReader(response.body.getReader(), taskno);\n        }\n      }\n    }\n  }, {\n    key: '_onReader',\n    value: function _onReader(reader, taskno) {\n      let buffer = this._context.getInstance(this.buffer);\n      if (!buffer && this._reader || this._destroyed) {\n        try {\n          this._reader.cancel();\n        } catch (e) {\n          // DO NOTHING\n        }\n      }\n\n      this._reader = reader;\n      if (this.loading === false) {\n        return;\n      }\n\n      let _this = this;\n      // reader read function returns a Promise. get data when callback and has value.done when disconnected.\n      // read方法返回一个Promise. 回调中可以获取到数据。当value.done存在时，说明链接断开。\n      this._reader && this._reader.read().then(function (val) {\n        if (val.done) {\n          // TODO: 完成处理\n          _this.loading = false;\n          _this.status = 0;\n          _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n          return;\n        }\n\n        if (_this._canceled || _this._destroyed) {\n          if (_this._reader) {\n            try {\n              _this._reader.cancel();\n            } catch (e) {\n              // DO NOTHING\n            }\n          }\n\n          return;\n        }\n        buffer.push(val.value);\n        _this.emit(LOADER_EVENTS.LOADER_DATALOADED, buffer);\n        return _this._onReader(reader, taskno);\n      }).catch(error => {\n        _this.loading = false;\n        _this.emit(LOADER_EVENTS.LOADER_ERROR, _this.TAG, error);\n      });\n    }\n  }, {\n    key: 'getParams',\n    value: function getParams(opts) {\n      let options = Object.assign({}, opts);\n      let headers = new Headers();\n\n      let params = {\n        method: 'GET',\n        headers: headers,\n        mode: 'cors',\n        cache: 'default'\n\n        // add custmor headers\n        // 添加自定义头\n      };if (typeof this.configs.headers === 'object') {\n        let configHeaders = this.configs.headers;\n        for (let key in configHeaders) {\n          if (configHeaders.hasOwnProperty(key)) {\n            headers.append(key, configHeaders[key]);\n          }\n        }\n      }\n\n      if (typeof options.headers === 'object') {\n        let optHeaders = options.headers;\n        for (let key in optHeaders) {\n          if (optHeaders.hasOwnProperty(key)) {\n            headers.append(key, optHeaders[key]);\n          }\n        }\n      }\n\n      if (options.cors === false) {\n        params.mode = 'same-origin';\n      }\n\n      // withCredentials is disabled by default\n      // withCredentials 在默认情况下不被使用。\n      if (options.withCredentials) {\n        params.credentials = 'include';\n      }\n\n      // TODO: Add ranges;\n      return params;\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      if (this._reader) {\n        try {\n          this._reader.cancel();\n        } catch (e) {\n          // 防止failed: 200错误被打印到控制台上\n        }\n        this._reader = null;\n        this.loading = false;\n        this._canceled = true;\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._destroyed = true;\n      this.cancel();\n    }\n  }], [{\n    key: 'type',\n    get: function () {\n      return 'loader';\n    }\n  }]);\n\n  return FetchLoader;\n}();\n\nexports.default = FetchLoader;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-loader/src/fetch-loader.js?")},"../xgplayer-remux/index.js":
/*!**********************************!*\
  !*** ../xgplayer-remux/index.js ***!
  \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = {\n  Mp4Remuxer: __webpack_require__(/*! ./src/mp4 */ "../xgplayer-remux/src/mp4/index.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-remux/index.js?')},"../xgplayer-remux/src/mp4/fmp4.js":
/*!*****************************************!*\
  !*** ../xgplayer-remux/src/mp4/fmp4.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// const UINT32_MAX = Math.pow(2, 32) - 1;\nlet Fmp4 = function () {\n  function Fmp4() {\n    _classCallCheck(this, Fmp4);\n  }\n\n  _createClass(Fmp4, null, [{\n    key: 'size',\n    value: function size(value) {\n      return _xgplayerUtils.Buffer.writeUint32(value);\n    }\n  }, {\n    key: 'initBox',\n    value: function initBox(size, name) {\n      const buffer = new _xgplayerUtils.Buffer();\n\n      for (var _len = arguments.length, content = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        content[_key - 2] = arguments[_key];\n      }\n\n      buffer.write.apply(buffer, [Fmp4.size(size), Fmp4.type(name)].concat(content));\n      return buffer.buffer;\n    }\n  }, {\n    key: 'extension',\n    value: function extension(version, flag) {\n      return new Uint8Array([version, flag >> 16 & 0xff, flag >> 8 & 0xff, flag & 0xff]);\n    }\n  }, {\n    key: 'ftyp',\n    value: function ftyp() {\n      return Fmp4.initBox(24, 'ftyp', new Uint8Array([0x69, 0x73, 0x6F, 0x6D, // isom,\n      0x0, 0x0, 0x00, 0x01, // minor_version: 0x01\n      0x69, 0x73, 0x6F, 0x6D, // isom\n      0x61, 0x76, 0x63, 0x31 // avc1\n      ]));\n    }\n  }, {\n    key: 'moov',\n    value: function moov(_ref) {\n      let { type, meta } = _ref;\n\n      let size = 8;\n      let mvhd = Fmp4.mvhd(meta.duration, meta.timescale);\n      let trak;\n\n      if (type === 'video') {\n        trak = Fmp4.videoTrak(meta);\n      } else {\n        trak = Fmp4.audioTrak(meta);\n      }\n\n      let mvex = Fmp4.mvex(meta.duration, meta.timescale || 1000, meta.id);\n      [mvhd, trak, mvex].forEach(item => {\n        size += item.byteLength;\n      });\n      return Fmp4.initBox(size, 'moov', mvhd, trak, mvex);\n    }\n  }, {\n    key: 'mvhd',\n    value: function mvhd(duration) {\n      let timescale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n\n      // duration *= timescale;\n      let bytes = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags     1位的box版本+3位flags   box版本，0或1，一般为0。（以下字节数均按version=0）\n      0x00, 0x00, 0x00, 0x00, // creation_time    创建时间  （相对于UTC时间1904-01-01零点的秒数）\n      0x00, 0x00, 0x00, 0x00, // modification_time   修改时间\n\n      /**\n             * timescale: 4 bytes文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n             */\n      timescale >>> 24 & 0xFF, timescale >>> 16 & 0xFF, timescale >>> 8 & 0xFF, timescale & 0xFF,\n\n      /**\n             * duration: 4 bytes该track的时间长度，用duration和time scale值可以计算track时长，比如audio track的time scale = 8000,\n             * duration = 560128，时长为70.016，video track的time scale = 600, duration = 42000，时长为70\n             */\n      duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x00, 0x01, 0x00, 0x00, // Preferred rate: 1.0   推荐播放速率，高16位和低16位分别为小数点整数部分和小数部分，即[16.16] 格式，该值为1.0（0x00010000）表示正常前向播放\n      /**\n             * PreferredVolume(1.0, 2bytes) + reserved(2bytes)\n             * 与rate类似，[8.8] 格式，1.0（0x0100）表示最大音量\n             */\n      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //  reserved: 4 + 4 bytes保留位\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 视频变换矩阵   线性代数\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n      0x00, 0x00, 0x00, 0x00, // ----begin pre_defined 6 * 4 bytes----\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre-defined 保留位\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ----end pre_defined 6 * 4 bytes----\n      0xFF, 0xFF, 0xFF, 0xFF // next_track_ID 下一个track使用的id号\n      ]);\n      return Fmp4.initBox(8 + bytes.length, 'mvhd', new Uint8Array(bytes));\n    }\n  }, {\n    key: 'videoTrak',\n    value: function videoTrak(data) {\n      let size = 8;\n\n      let tkhd = Fmp4.tkhd({\n        id: 1,\n        duration: data.duration,\n        timescale: data.timescale || 1000,\n        width: data.presentWidth,\n        height: data.presentHeight,\n        type: 'video'\n      });\n      let mdia = Fmp4.mdia({\n        type: 'video',\n        timescale: data.timescale || 1000,\n        duration: data.duration,\n        avcc: data.avcc,\n        parRatio: data.parRatio,\n        width: data.presentWidth,\n        height: data.presentHeight\n      });\n      [tkhd, mdia].forEach(item => {\n        size += item.byteLength;\n      });\n      return Fmp4.initBox(size, 'trak', tkhd, mdia);\n    }\n  }, {\n    key: 'audioTrak',\n    value: function audioTrak(data) {\n      let size = 8;\n      let tkhd = Fmp4.tkhd({\n        id: 2,\n        duration: data.duration,\n        timescale: data.timescale || 1000,\n        width: 0,\n        height: 0,\n        type: 'audio'\n      });\n      let mdia = Fmp4.mdia({\n        type: 'audio',\n        timescale: data.timescale || 1000,\n        duration: data.duration,\n        channelCount: data.channelCount,\n        samplerate: data.sampleRate,\n        config: data.config\n      });\n      [tkhd, mdia].forEach(item => {\n        size += item.byteLength;\n      });\n      return Fmp4.initBox(size, 'trak', tkhd, mdia);\n    }\n  }, {\n    key: 'tkhd',\n    value: function tkhd(data) {\n      let id = data.id;\n      let duration = data.duration;\n      let width = data.width;\n      let height = data.height;\n      let content = new Uint8Array([0x00, 0x00, 0x00, 0x07, // version(0) + flags 1位版本 box版本，0或1，一般为0。（以下字节数均按version=0）按位或操作结果值，预定义如下：\n      // 0x000001 track_enabled，否则该track不被播放；\n      // 0x000002 track_in_movie，表示该track在播放中被引用；\n      // 0x000004 track_in_preview，表示该track在预览时被引用。\n      // 一般该值为7，1+2+4 如果一个媒体所有track均未设置track_in_movie和track_in_preview，将被理解为所有track均设置了这两项；对于hint track，该值为0\n      // hint track 这个特殊的track并不包含媒体数据，而是包含了一些将其他数据track打包成流媒体的指示信息。\n      0x00, 0x00, 0x00, 0x00, // creation_time创建时间（相对于UTC时间1904-01-01零点的秒数）\n      0x00, 0x00, 0x00, 0x00, // modification time 修改时间\n      id >>> 24 & 0xFF, // track_ID: 4 bytes id号，不能重复且不能为0\n      id >>> 16 & 0xFF, id >>> 8 & 0xFF, id & 0xFF, 0x00, 0x00, 0x00, 0x00, // reserved: 4 bytes    保留位\n      duration >>> 24 & 0xFF, // duration: 4 bytes track的时间长度\n      duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x00, 0x00, 0x00, 0x00, // reserved: 2 * 4 bytes    保留位\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // layer(2bytes) + alternate_group(2bytes)  视频层，默认为0，值小的在上层.track分组信息，默认为0表示该track未与其他track有群组关系\n      0x00, 0x00, 0x00, 0x00, // volume(2bytes) + reserved(2bytes)    [8.8] 格式，如果为音频track，1.0（0x0100）表示最大音量；否则为0   +保留位\n      0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, // 视频变换矩阵\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n      width >>> 8 & 0xFF, // //宽度\n      width & 0xFF, 0x00, 0x00, height >>> 8 & 0xFF, // 高度\n      height & 0xFF, 0x00, 0x00]);\n      return Fmp4.initBox(8 + content.byteLength, 'tkhd', content);\n    }\n  }, {\n    key: 'edts',\n    value: function edts(data) {\n      let buffer = new _xgplayerUtils.Buffer();\n      let duration = data.duration;\n      let mediaTime = data.mediaTime;\n      buffer.write(Fmp4.size(36), Fmp4.type('edts'));\n      // elst\n      buffer.write(Fmp4.size(28), Fmp4.type('elst'));\n      buffer.write(new Uint8Array([0x00, 0x00, 0x00, 0x01, // entry count\n      duration >> 24 & 0xff, duration >> 16 & 0xff, duration >> 8 & 0xff, duration & 0xff, mediaTime >> 24 & 0xff, mediaTime >> 16 & 0xff, mediaTime >> 8 & 0xff, mediaTime & 0xff, 0x00, 0x00, 0x00, 0x01 // media rate\n      ]));\n      return buffer.buffer;\n    }\n  }, {\n    key: 'mdia',\n    value: function mdia(data) {\n      let size = 8;\n      let mdhd = Fmp4.mdhd(data.timescale, data.duration);\n      let hdlr = Fmp4.hdlr(data.type);\n      let minf = Fmp4.minf(data);\n      [mdhd, hdlr, minf].forEach(item => {\n        size += item.byteLength;\n      });\n      return Fmp4.initBox(size, 'mdia', mdhd, hdlr, minf);\n    }\n  }, {\n    key: 'mdhd',\n    value: function mdhd() {\n      let timescale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n      let duration = arguments[1];\n\n      let content = new Uint8Array([0x00, 0x00, 0x00, 0x00, // creation_time    创建时间\n      0x00, 0x00, 0x00, 0x00, // modification_time修改时间\n      timescale >>> 24 & 0xFF, // timescale: 4 bytes    文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n      timescale >>> 16 & 0xFF, timescale >>> 8 & 0xFF, timescale & 0xFF, duration >>> 24 & 0xFF, // duration: 4 bytes  track的时间长度\n      duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x55, 0xC4, // language: und (undetermined) 媒体语言码。最高位为0，后面15位为3个字符（见ISO 639-2/T标准中定义）\n      0x00, 0x00 // pre_defined = 0\n      ]);\n      return Fmp4.initBox(12 + content.byteLength, 'mdhd', Fmp4.extension(0, 0), content);\n    }\n  }, {\n    key: 'hdlr',\n    value: function hdlr(type) {\n      let value = [0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n      ];\n      if (type === 'audio') {\n        value.splice.apply(value, [8, 4].concat([0x73, 0x6f, 0x75, 0x6e]));\n        value.splice.apply(value, [24, 13].concat([0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00]));\n      }\n      return Fmp4.initBox(8 + value.length, 'hdlr', new Uint8Array(value));\n    }\n  }, {\n    key: 'minf',\n    value: function minf(data) {\n      let size = 8;\n      let vmhd = data.type === 'video' ? Fmp4.vmhd() : Fmp4.smhd();\n      let dinf = Fmp4.dinf();\n      let stbl = Fmp4.stbl(data);\n      [vmhd, dinf, stbl].forEach(item => {\n        size += item.byteLength;\n      });\n      return Fmp4.initBox(size, 'minf', vmhd, dinf, stbl);\n    }\n  }, {\n    key: 'vmhd',\n    value: function vmhd() {\n      return Fmp4.initBox(20, 'vmhd', new Uint8Array([0x00, // version\n      0x00, 0x00, 0x01, // flags\n      0x00, 0x00, // graphicsmode\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n      ]));\n    }\n  }, {\n    key: 'smhd',\n    value: function smhd() {\n      return Fmp4.initBox(16, 'smhd', new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, // balance\n      0x00, 0x00 // reserved\n      ]));\n    }\n  }, {\n    key: 'dinf',\n    value: function dinf() {\n      let buffer = new _xgplayerUtils.Buffer();\n      let dref = [0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // entry_count\n      0x00, 0x00, 0x00, 0x0c, // entry_size\n      0x75, 0x72, 0x6c, 0x20, // 'url' type\n      0x00, // version 0\n      0x00, 0x00, 0x01 // entry_flags\n      ];\n      buffer.write(Fmp4.size(36), Fmp4.type('dinf'), Fmp4.size(28), Fmp4.type('dref'), new Uint8Array(dref));\n      return buffer.buffer;\n    }\n  }, {\n    key: 'stbl',\n    value: function stbl(data) {\n      let size = 8;\n      let stsd = Fmp4.stsd(data);\n      let stts = Fmp4.stts();\n      let stsc = Fmp4.stsc();\n      let stsz = Fmp4.stsz();\n      let stco = Fmp4.stco();\n      [stsd, stts, stsc, stsz, stco].forEach(item => {\n        size += item.byteLength;\n      });\n      return Fmp4.initBox(size, 'stbl', stsd, stts, stsc, stsz, stco);\n    }\n  }, {\n    key: 'stsd',\n    value: function stsd(data) {\n      let content;\n      if (data.type === 'audio') {\n        // if (!data.isAAC && data.codec === 'mp4') {\n        //     content = FMP4.mp3(data);\n        // } else {\n        //\n        // }\n        // 支持mp4a\n        content = Fmp4.mp4a(data);\n      } else {\n        content = Fmp4.avc1(data);\n      }\n      return Fmp4.initBox(16 + content.byteLength, 'stsd', Fmp4.extension(0, 0), new Uint8Array([0x00, 0x00, 0x00, 0x01]), content);\n    }\n  }, {\n    key: 'mp4a',\n    value: function mp4a(data) {\n      let content = new Uint8Array([0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, data.channelCount, // channelcount\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00, // reserved2\n      data.samplerate >> 8 & 0xff, data.samplerate & 0xff, //\n      0x00, 0x00]);\n      let esds = Fmp4.esds(data.config);\n      return Fmp4.initBox(8 + content.byteLength + esds.byteLength, 'mp4a', content, esds);\n    }\n  }, {\n    key: 'esds',\n    value: function esds() {\n      let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [43, 146, 8, 0];\n\n      const configlen = config.length;\n      let buffer = new _xgplayerUtils.Buffer();\n      let content = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n\n      0x03, // descriptor_type\n      0x17 + configlen, // length\n      0x00, 0x01, // es_id\n      0x00, // stream_priority\n\n      0x04, // descriptor_type\n      0x0f + configlen, // length\n      0x40, // codec : mpeg4_audio\n      0x15, // stream_type\n      0x00, 0x00, 0x00, // buffer_size\n      0x00, 0x00, 0x00, 0x00, // maxBitrate\n      0x00, 0x00, 0x00, 0x00, // avgBitrate\n\n      0x05 // descriptor_type\n      ].concat([configlen]).concat(config).concat([0x06, 0x01, 0x02]));\n      buffer.write(Fmp4.size(8 + content.byteLength), Fmp4.type('esds'), content);\n      return buffer.buffer;\n    }\n  }, {\n    key: 'avc1',\n    value: function avc1(data) {\n      let buffer = new _xgplayerUtils.Buffer();\n      let size = 40; // 8(avc1)+8(avcc)+8(btrt)+16(pasp)\n      // let sps = data.sps\n      // let pps = data.pps\n      let width = data.width;\n      let height = data.height;\n      let hSpacing = data.parRatio.height;\n      let vSpacing = data.parRatio.width;\n      // let avccBuffer = new Buffer()\n      // avccBuffer.write(new Uint8Array([\n      //   0x01, // version\n      //   sps[1], // profile\n      //   sps[2], // profile compatible\n      //   sps[3], // level\n      //   0xfc | 3,\n      //   0xE0 | 1 // 目前只处理一个sps\n      // ].concat([sps.length >>> 8 & 0xff, sps.length & 0xff])))\n      // avccBuffer.write(sps, new Uint8Array([1, pps.length >>> 8 & 0xff, pps.length & 0xff]), pps)\n\n      let avcc = data.avcc;\n      let avc1 = new Uint8Array([0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n      width >> 8 & 0xff, width & 0xff, // width\n      height >> 8 & 0xff, height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x12, 0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js\n      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11]); // pre_defined = -1\n      let btrt = new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n      0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\n      ]);\n      let pasp = new Uint8Array([hSpacing >> 24, // hSpacing\n      hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24, // vSpacing\n      vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff]);\n\n      buffer.write(Fmp4.size(size + avc1.byteLength + avcc.byteLength + btrt.byteLength), Fmp4.type('avc1'), avc1, Fmp4.size(8 + avcc.byteLength), Fmp4.type('avcC'), avcc, Fmp4.size(20), Fmp4.type('btrt'), btrt, Fmp4.size(16), Fmp4.type('pasp'), pasp);\n      return buffer.buffer;\n    }\n  }, {\n    key: 'stts',\n    value: function stts() {\n      let content = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00 // entry_count\n      ]);\n      return Fmp4.initBox(16, 'stts', content);\n    }\n  }, {\n    key: 'stsc',\n    value: function stsc() {\n      let content = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00 // entry_count\n      ]);\n      return Fmp4.initBox(16, 'stsc', content);\n    }\n  }, {\n    key: 'stco',\n    value: function stco() {\n      let content = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00 // entry_count\n      ]);\n      return Fmp4.initBox(16, 'stco', content);\n    }\n  }, {\n    key: 'stsz',\n    value: function stsz() {\n      let content = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // sample_size\n      0x00, 0x00, 0x00, 0x00 // sample_count\n      ]);\n      return Fmp4.initBox(20, 'stsz', content);\n    }\n  }, {\n    key: 'mvex',\n    value: function mvex(duration) {\n      let timescale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n      let trackID = arguments[2];\n\n      let buffer = new _xgplayerUtils.Buffer();\n      let mehd = _xgplayerUtils.Buffer.writeUint32(duration);\n      buffer.write(Fmp4.size(56), Fmp4.type('mvex'), Fmp4.size(16), Fmp4.type('mehd'), Fmp4.extension(0, 0), mehd, Fmp4.trex(trackID));\n      return buffer.buffer;\n    }\n  }, {\n    key: 'trex',\n    value: function trex(id) {\n      let content = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n      ]);\n      return Fmp4.initBox(8 + content.byteLength, 'trex', content);\n    }\n  }, {\n    key: 'moof',\n    value: function moof(data) {\n      let size = 8;\n      let mfhd = Fmp4.mfhd();\n      let traf = Fmp4.traf(data);\n      [mfhd, traf].forEach(item => {\n        size += item.byteLength;\n      });\n      return Fmp4.initBox(size, 'moof', mfhd, traf);\n    }\n  }, {\n    key: 'mfhd',\n    value: function mfhd() {\n      let content = _xgplayerUtils.Buffer.writeUint32(Fmp4.sequence);\n      Fmp4.sequence += 1;\n      return Fmp4.initBox(16, 'mfhd', Fmp4.extension(0, 0), content);\n    }\n  }, {\n    key: 'traf',\n    value: function traf(data) {\n      let size = 8;\n      let tfhd = Fmp4.tfhd(data.id);\n      let tfdt = Fmp4.tfdt(data.time);\n      let sdtp = Fmp4.sdtp(data);\n      let trun = Fmp4.trun(data, sdtp.byteLength);\n\n      [tfhd, tfdt, trun, sdtp].forEach(item => {\n        size += item.byteLength;\n      });\n      return Fmp4.initBox(size, 'traf', tfhd, tfdt, trun, sdtp);\n    }\n  }, {\n    key: 'tfhd',\n    value: function tfhd(id) {\n      let content = _xgplayerUtils.Buffer.writeUint32(id);\n      return Fmp4.initBox(16, 'tfhd', Fmp4.extension(0, 0), content);\n    }\n  }, {\n    key: 'tfdt',\n    value: function tfdt(time) {\n      // let upper = Math.floor(time / (UINT32_MAX + 1)),\n      //     lower = Math.floor(time % (UINT32_MAX + 1));\n      return Fmp4.initBox(16, 'tfdt', Fmp4.extension(0, 0), _xgplayerUtils.Buffer.writeUint32(time));\n    }\n  }, {\n    key: 'trun',\n    value: function trun(data, sdtpLength) {\n      // let id = data.id;\n      // let ceil = id === 1 ? 16 : 12;\n      let buffer = new _xgplayerUtils.Buffer();\n      let sampleCount = _xgplayerUtils.Buffer.writeUint32(data.samples.length);\n      // mdat-header 8\n      // moof-header 8\n      // mfhd 16\n      // traf-header 8\n      // thhd 16\n      // tfdt 20\n      // trun-header 12\n      // sampleCount 4\n      // data-offset 4\n      // samples.length\n      let offset = _xgplayerUtils.Buffer.writeUint32(8 + 8 + 16 + 8 + 16 + 16 + 12 + 4 + 4 + 16 * data.samples.length + sdtpLength);\n      buffer.write(Fmp4.size(20 + 16 * data.samples.length), Fmp4.type('trun'), new Uint8Array([0x00, 0x00, 0x0F, 0x01]), sampleCount, offset);\n\n      // let size = buffer.buffer.byteLength\n      // let writeOffset = 0\n      // data.samples.forEach(() => {\n      //   size += 16\n      // })\n      //\n      // let trunBox = new Uint8Array(size)\n\n      // trunBox.set(buffer.buffer, 0)\n\n      data.samples.forEach(item => {\n        const flags = item.flags;\n        // console.log(item.type, item.dts, item.duration)\n\n        buffer.write(new Uint8Array([item.duration >>> 24 & 0xFF, // sample_duration\n        item.duration >>> 16 & 0xFF, item.duration >>> 8 & 0xFF, item.duration & 0xFF, item.size >>> 24 & 0xFF, // sample_size\n        item.size >>> 16 & 0xFF, item.size >>> 8 & 0xFF, item.size & 0xFF, flags.isLeading << 2 | flags.dependsOn, // sample_flags\n        flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.isNonSync, 0x00, 0x00, // sample_degradation_priority\n        item.cts >>> 24 & 0xFF, // sample_composition_time_offset\n        item.cts >>> 16 & 0xFF, item.cts >>> 8 & 0xFF, item.cts & 0xFF]));\n        // writeOffset += 16\n        // buffer.write(Buffer.writeUint32(0));\n      });\n      return buffer.buffer;\n    }\n  }, {\n    key: 'sdtp',\n    value: function sdtp(data) {\n      let buffer = new _xgplayerUtils.Buffer();\n      buffer.write(Fmp4.size(12 + data.samples.length), Fmp4.type('sdtp'), Fmp4.extension(0, 0));\n      data.samples.forEach(item => {\n        const flags = item.flags;\n        const num = flags.isLeading << 6 | // is_leading: 2 (bit)\n        flags.dependsOn << 4 | // sample_depends_on\n        flags.isDependedOn << 2 | // sample_is_depended_on\n        flags.hasRedundancy; // sample_has_redundancy\n\n        buffer.write(new Uint8Array([num]));\n      });\n      return buffer.buffer;\n    }\n  }, {\n    key: 'mdat',\n    value: function mdat(data) {\n      let buffer = new _xgplayerUtils.Buffer();\n      let size = 8;\n      data.samples.forEach(item => {\n        size += item.size;\n      });\n      buffer.write(Fmp4.size(size), Fmp4.type('mdat'));\n      let mdatBox = new Uint8Array(size);\n      let offset = 0;\n      mdatBox.set(buffer.buffer, offset);\n      offset += 8;\n      data.samples.forEach(item => {\n        item.buffer.forEach(unit => {\n          mdatBox.set(unit, offset);\n          offset += unit.byteLength;\n          // buffer.write(unit.data);\n        });\n      });\n      return mdatBox;\n    }\n  }]);\n\n  return Fmp4;\n}();\n\nFmp4.type = name => {\n  return new Uint8Array([name.charCodeAt(0), name.charCodeAt(1), name.charCodeAt(2), name.charCodeAt(3)]);\n};\nFmp4.sequence = 1;\n\nexports.default = Fmp4;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-remux/src/mp4/fmp4.js?")},"../xgplayer-remux/src/mp4/index.js":
/*!******************************************!*\
  !*** ../xgplayer-remux/src/mp4/index.js ***!
  \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _fmp = __webpack_require__(/*! ./fmp4 */ \"../xgplayer-remux/src/mp4/fmp4.js\");\n\nvar _fmp2 = _interopRequireDefault(_fmp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nconst REMUX_EVENTS = _xgplayerUtils.EVENTS.REMUX_EVENTS;\n\nlet Mp4Remuxer = function () {\n  function Mp4Remuxer() {\n    _classCallCheck(this, Mp4Remuxer);\n\n    this._dtsBase = 0;\n    this._isDtsBaseInited = false;\n\n    this.isFirstVideo = true;\n    this.isFirstAudio = true;\n\n    this.videoAllDuration = 0;\n    this.audioAllDuration = 0;\n  }\n\n  _createClass(Mp4Remuxer, [{\n    key: 'init',\n    value: function init() {\n      this.on(REMUX_EVENTS.REMUX_MEDIA, this.remux.bind(this));\n      this.on(REMUX_EVENTS.REMUX_METADATA, this.onMetaDataReady.bind(this));\n      this.on(REMUX_EVENTS.DETECT_CHANGE_STREAM, this.resetDtsBase.bind(this));\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._dtsBase = -1;\n      this._dtsBaseInited = false;\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this._dtsBase = 0;\n      this._isDtsBaseInited = false;\n    }\n  }, {\n    key: 'remux',\n    value: function remux() {\n      const { audioTrack, videoTrack } = this._context.getInstance('TRACKS');\n      !this._isDtsBaseInited && this.calcDtsBase(audioTrack, videoTrack);\n\n      this._remuxVideo(videoTrack);\n      this._remuxAudio(audioTrack);\n    }\n  }, {\n    key: 'resetDtsBase',\n    value: function resetDtsBase() {\n      // for hls 中途切换 meta后seek\n      this._dtsBase = 0;\n      this._dtsBaseInited = false;\n    }\n  }, {\n    key: 'seek',\n    value: function seek() {}\n  }, {\n    key: 'onMetaDataReady',\n    value: function onMetaDataReady(type) {\n      let track;\n\n      if (type === 'audio') {\n        const { audioTrack } = this._context.getInstance('TRACKS');\n        track = audioTrack;\n      } else {\n        const { videoTrack } = this._context.getInstance('TRACKS');\n        track = videoTrack;\n      }\n\n      let presourcebuffer = this._context.getInstance('PRE_SOURCE_BUFFER');\n      let source = presourcebuffer.getSource(type);\n      if (!source) {\n        source = presourcebuffer.createSource(type);\n      }\n\n      source.mimetype = track.meta.codec;\n      source.init = this.remuxInitSegment(type, track.meta);\n      // source.inited = false;\n\n      // this.resetDtsBase()\n      this.emit(REMUX_EVENTS.INIT_SEGMENT, type);\n    }\n  }, {\n    key: 'remuxInitSegment',\n    value: function remuxInitSegment(type, meta) {\n      let initSegment = new _xgplayerUtils.Buffer();\n      let ftyp = _fmp2.default.ftyp();\n      let moov = _fmp2.default.moov({ type, meta: meta });\n\n      initSegment.write(ftyp, moov);\n      return initSegment;\n    }\n  }, {\n    key: 'calcDtsBase',\n    value: function calcDtsBase(audioTrack, videoTrack) {\n      if (!audioTrack.samples.length && !videoTrack.samples.length) {\n        return;\n      }\n\n      let audioBase = Infinity;\n      let videoBase = Infinity;\n\n      if (audioTrack.samples && audioTrack.samples.length) {\n        audioBase = audioTrack.samples[0].dts;\n      }\n      if (videoTrack.samples && videoTrack.samples.length) {\n        videoBase = videoTrack.samples[0].dts;\n      }\n\n      this._dtsBase = Math.min(audioBase, videoBase);\n      this._isDtsBaseInited = true;\n    }\n  }, {\n    key: '_remuxVideo',\n    value: function _remuxVideo(videoTrack) {\n      const track = videoTrack;\n\n      if (!videoTrack.samples || !videoTrack.samples.length) {\n        return;\n      }\n\n      let { samples } = track;\n      let firstDts = -1;\n\n      let initSegment = null;\n      const mp4Samples = [];\n      const mdatBox = {\n        samples: []\n      };\n\n      while (samples.length) {\n        const avcSample = samples.shift();\n\n        const { isKeyframe, options } = avcSample;\n        if (!this.isFirstAudio && options && options.meta) {\n          initSegment = this.remuxInitSegment('video', options.meta);\n          options.meta = null;\n          samples.unshift(avcSample);\n          if (!options.isContinue) {\n            this.resetDtsBase();\n          }\n          break;\n        }\n\n        let dts = avcSample.dts - this._dtsBase;\n\n        if (firstDts === -1) {\n          firstDts = dts;\n        }\n\n        let cts;\n        let pts;\n        if (avcSample.pts !== undefined) {\n          pts = avcSample.pts - this._dtsBase;\n          cts = pts - dts;\n        }\n        if (avcSample.cts !== undefined) {\n          pts = avcSample.cts + dts;\n          cts = avcSample.cts;\n        }\n\n        let mdatSample = {\n          buffer: [],\n          size: 0\n        };\n        mdatBox.samples.push(mdatSample);\n        mdatSample.buffer.push(avcSample.data);\n        mdatSample.size += avcSample.data.byteLength;\n\n        let sampleDuration = 0;\n        if (samples.length >= 1) {\n          const nextDts = samples[0].dts - this._dtsBase;\n          sampleDuration = nextDts - dts;\n        } else {\n          if (mp4Samples.length >= 1) {\n            // lastest sample, use second last duration\n            sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n          } else {\n            // the only one sample, use reference duration\n            sampleDuration = this.videoMeta.refSampleDuration;\n          }\n        }\n        this.videoAllDuration += sampleDuration;\n        // console.log(`dts ${dts}`, `pts ${pts}`, `cts: ${cts}`, `duration: ${sampleDuration}`, avcSample)\n        mp4Samples.push({\n          dts,\n          cts,\n          pts,\n          data: avcSample.data,\n          size: avcSample.data.byteLength,\n          isKeyframe,\n          duration: sampleDuration,\n          flags: {\n            isLeading: 0,\n            dependsOn: isKeyframe ? 2 : 1,\n            isDependedOn: isKeyframe ? 1 : 0,\n            hasRedundancy: 0,\n            isNonSync: isKeyframe ? 0 : 1\n          },\n          originDts: dts,\n          type: 'video'\n        });\n      }\n\n      let moofMdat = new _xgplayerUtils.Buffer();\n      if (mp4Samples.length) {\n        const moof = _fmp2.default.moof({\n          id: track.meta.id,\n          time: firstDts,\n          samples: mp4Samples\n        });\n        const mdat = _fmp2.default.mdat(mdatBox);\n        moofMdat.write(moof, mdat);\n\n        this.writeToSource('video', moofMdat);\n      }\n\n      if (initSegment) {\n        this.writeToSource('video', initSegment);\n\n        if (samples.length) {\n          // second part of stream change\n          track.samples = samples;\n          return this._remuxVideo(track);\n        }\n      }\n\n      this.isFirstVideo = false;\n      this.emit(REMUX_EVENTS.MEDIA_SEGMENT, 'video');\n\n      const lastSample = mp4Samples[mp4Samples.length - 1];\n      this._videoNextDts = lastSample.dts + lastSample.duration;\n      track.samples = [];\n      track.length = 0;\n    }\n  }, {\n    key: '_remuxAudio',\n    value: function _remuxAudio(track) {\n      const { samples } = track;\n      let firstDts = -1;\n      let mp4Samples = [];\n\n      let initSegment = null;\n      const mdatBox = {\n        samples: []\n      };\n      if (!samples || !samples.length) {\n        return;\n      }\n      let isFirstDtsInited = false;\n      while (samples.length) {\n        let sample = samples.shift();\n        const { data, options } = sample;\n        if (!this.isFirstAudio && options && options.meta) {\n          initSegment = this.remuxInitSegment('audio', options.meta);\n          options.meta = null;\n          samples.unshift(sample);\n          if (!options.isContinue) {\n            this.resetDtsBase();\n          }\n          break;\n        }\n\n        let dts = sample.dts - this._dtsBase;\n        const originDts = dts;\n        if (!isFirstDtsInited) {\n          firstDts = dts;\n          isFirstDtsInited = true;\n        }\n\n        let sampleDuration = 0;\n\n        if (this.audioMeta.refSampleDurationFixed) {\n          sampleDuration = this.audioMeta.refSampleDurationFixed;\n        } else if (samples.length >= 1) {\n          const nextDts = samples[0].dts - this._dtsBase;\n          sampleDuration = nextDts - dts;\n        } else {\n          if (mp4Samples.length >= 1) {\n            // use second last sample duration\n            sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n          } else {\n            // the only one sample, use reference sample duration\n            sampleDuration = this.audioMeta.refSampleDuration;\n          }\n        }\n\n        // console.log('remux audio ', dts)\n        this.audioAllDuration += sampleDuration;\n        const mp4Sample = {\n          dts,\n          pts: dts,\n          cts: 0,\n          size: data.byteLength,\n          duration: sample.duration ? sample.duration : sampleDuration,\n          flags: {\n            isLeading: 0,\n            dependsOn: 2,\n            isDependedOn: 1,\n            hasRedundancy: 0,\n            isNonSync: 0\n          },\n          isKeyframe: true,\n          originDts,\n          type: 'audio'\n        };\n\n        let mdatSample = {\n          buffer: [],\n          size: 0\n        };\n        mdatSample.buffer.push(data);\n        mdatSample.size += data.byteLength;\n\n        mdatBox.samples.push(mdatSample);\n\n        mp4Samples.push(mp4Sample);\n      }\n\n      const moofMdat = new _xgplayerUtils.Buffer();\n\n      if (mp4Samples.length) {\n        const moof = _fmp2.default.moof({\n          id: track.meta.id,\n          time: firstDts,\n          samples: mp4Samples\n        });\n        const mdat = _fmp2.default.mdat(mdatBox);\n        moofMdat.write(moof, mdat);\n\n        this.writeToSource('audio', moofMdat);\n      }\n\n      if (initSegment) {\n        this.writeToSource('audio', initSegment);\n        if (samples.length) {\n          // second part of stream change\n          track.samples = samples;\n          return this._remuxAudio(track);\n        }\n      }\n\n      this.isFirstAudio = false;\n      this.emit(REMUX_EVENTS.MEDIA_SEGMENT, 'audio', moofMdat);\n\n      const lastSample = mp4Samples[mp4Samples.length - 1];\n      this._videoNextDts = lastSample.dts + lastSample.duration;\n      track.samples = [];\n      track.length = 0;\n    }\n  }, {\n    key: 'writeToSource',\n    value: function writeToSource(type, buffer) {\n      let presourcebuffer = this._context.getInstance('PRE_SOURCE_BUFFER');\n      let source = presourcebuffer.getSource(type);\n      if (!source) {\n        source = presourcebuffer.createSource(type);\n      }\n\n      source.data.push(buffer);\n    }\n  }, {\n    key: 'initSilentAudio',\n    value: function initSilentAudio(dts, duration) {\n      const unit = Mp4Remuxer.getSilentFrame(this.audioMeta.channelCount);\n      return {\n        dts,\n        pts: dts,\n        cts: 0,\n        duration,\n        unit,\n        size: unit.byteLength,\n        originDts: dts,\n        type: 'video'\n      };\n    }\n  }, {\n    key: 'videoMeta',\n    get: function () {\n      return this._context.getInstance('TRACKS').videoTrack.meta;\n    }\n  }, {\n    key: 'audioMeta',\n    get: function () {\n      return this._context.getInstance('TRACKS').audioTrack.meta;\n    }\n  }], [{\n    key: 'getSilentFrame',\n    value: function getSilentFrame(channelCount) {\n      if (channelCount === 1) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n      } else if (channelCount === 2) {\n        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n      } else if (channelCount === 3) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n      } else if (channelCount === 4) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n      } else if (channelCount === 5) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n      } else if (channelCount === 6) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n      }\n      return null;\n    }\n  }]);\n\n  return Mp4Remuxer;\n}();\n\nexports.default = Mp4Remuxer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-remux/src/mp4/index.js?")},"../xgplayer-render/src/filter.js":
/*!****************************************!*\
  !*** ../xgplayer-render/src/filter.js ***!
  \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Filter = function Filter() {\n  _classCallCheck(this, Filter);\n\n  this.inputTextures = [];\n};\n\nexports.default = Filter;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-render/src/filter.js?')},"../xgplayer-render/src/filter/basic.js":
/*!**********************************************!*\
  !*** ../xgplayer-render/src/filter/basic.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _filter = __webpack_require__(/*! ../filter */ \"../xgplayer-render/src/filter.js\");\n\nvar _filter2 = _interopRequireDefault(_filter);\n\nvar _glutil = __webpack_require__(/*! ../glutil */ \"../xgplayer-render/src/glutil.js\");\n\nvar _glutil2 = _interopRequireDefault(_glutil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Basic = function (_Filter) {\n  _inherits(Basic, _Filter);\n\n  function Basic(config) {\n    _classCallCheck(this, Basic);\n\n    var _this = _possibleConstructorReturn(this, (Basic.__proto__ || Object.getPrototypeOf(Basic)).call(this));\n\n    _this.vShader = ['attribute vec4 vertexPos;', 'attribute vec2 texturePos;', 'varying vec2 textureCoord;', 'void main()', '{', '  gl_Position = vertexPos;', '  textureCoord = texturePos;', '}'].join('\\n');\n    _this.fShader = ['precision highp float;', 'varying highp vec2 textureCoord;', 'uniform highp float opacity;', 'uniform sampler2D sampler;', 'uniform highp float flipx;', 'uniform highp float flipy;', 'void main(void) {', '  float cordx = textureCoord.x;', '  if(flipx > 0.5) {', '     cordx = 1.0 - textureCoord.x;', '  }', '  float cordy = 1.0 - textureCoord.y;', '  if(flipy > 0.5) {', '    cordy = textureCoord.y;', '  }', '  vec4 color = texture2D(sampler,vec2(cordx, cordy));', '  gl_FragColor = vec4(color[0],color[1],color[2],opacity);', '}'].join('\\n');\n\n    _this.opacity = config.opacity === undefined ? 1 : config.opacity;\n    _this.flip = config.flip;\n    return _this;\n  }\n\n  _createClass(Basic, [{\n    key: 'init',\n    value: function init(render) {\n      this.rend = render;\n      this.canvas = render.canvas;\n      var gl = this.gl = render.gl;\n      this.pw = _glutil2.default.createProgram(gl, this.vShader, this.fShader);\n      this.program = this.pw.program;\n      gl.useProgram(this.program);\n\n      // vertexPos\n      var vertexPosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]));\n      _glutil2.default.bindAttribute(gl, vertexPosBuffer, this.pw.vertexPos, 2);\n\n      // texturePos\n      var texturePosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]));\n      _glutil2.default.bindAttribute(gl, texturePosBuffer, this.pw.texturePos, 2);\n\n      _glutil2.default.createTexture(gl, gl.LINEAR);\n      gl.uniform1i(this.pw.sampler, 0);\n\n      gl.uniform1f(this.pw.opacity, this.opacity);\n\n      var flipx = 0;\n      var flipy = 0;\n\n      if (this.flip === 'x' || this.flip === 'xy') {\n        flipx = 1;\n      }\n\n      if (this.flip === 'y' || this.flip === 'xy') {\n        flipy = 1;\n      }\n\n      gl.uniform1f(this.pw.flipx, flipx);\n      gl.uniform1f(this.pw.flipy, flipy);\n    }\n  }, {\n    key: 'setFlip',\n    value: function setFlip(flip) {\n      var flipx = 0;\n      var flipy = 0;\n      this.flip = flip;\n      if (this.flip === 'x' || this.flip === 'xy') {\n        flipx = 1;\n      }\n\n      if (this.flip === 'y' || this.flip === 'xy') {\n        flipy = 1;\n      }\n\n      this.gl.uniform1f(this.pw.flipx, flipx);\n      this.gl.uniform1f(this.pw.flipy, flipy);\n    }\n  }, {\n    key: 'render',\n    value: function render(texture, width, height) {\n      var gl = this.gl;\n      var program = this.program;\n      gl.useProgram(program);\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n  }]);\n\n  return Basic;\n}(_filter2.default);\n\nexports.default = Basic;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-render/src/filter/basic.js?")},"../xgplayer-render/src/fmt/nv12.js":
/*!******************************************!*\
  !*** ../xgplayer-render/src/fmt/nv12.js ***!
  \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _filter = __webpack_require__(/*! ../filter */ \"../xgplayer-render/src/filter.js\");\n\nvar _filter2 = _interopRequireDefault(_filter);\n\nvar _glutil = __webpack_require__(/*! ../glutil */ \"../xgplayer-render/src/glutil.js\");\n\nvar _glutil2 = _interopRequireDefault(_glutil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Nv12 = function (_Filter) {\n  _inherits(Nv12, _Filter);\n\n  function Nv12(config) {\n    _classCallCheck(this, Nv12);\n\n    var _this = _possibleConstructorReturn(this, (Nv12.__proto__ || Object.getPrototypeOf(Nv12)).call(this));\n\n    _this.vShader = ['attribute vec4 vertexPos;', 'attribute vec2 yTexturePos;', 'attribute vec2 uvTexturePos;', 'varying vec2 yTextureCoord;', 'varying vec2 uvTextureCoord;', 'void main()', '{', '  gl_Position = vertexPos;', '  yTextureCoord = yTexturePos;', '  uvTextureCoord = uvTexturePos;', '}'].join('\\n');\n    _this.fShader = ['precision highp float;', 'varying highp vec2 yTextureCoord;', 'varying highp vec2 uvTextureCoord;', 'uniform sampler2D ySampler;', 'uniform sampler2D uvSampler;', 'uniform mat4 yuv2rgb;', 'void main(void) {', '  vec4 colory = texture2D(ySampler, vec2(yTextureCoord.x / 2.0, yTextureCoord.y));', '  vec4 coloruv = texture2D(uvSampler, vec2(uvTextureCoord.x / 2.0, uvTextureCoord.y));', '  gl_FragColor = vec4(colory[0], coloruv[0], coloruv[1], 1) * yuv2rgb;', '}'].join('\\n');\n    return _this;\n  }\n\n  _createClass(Nv12, [{\n    key: 'init',\n    value: function init(render) {\n      this.rend = render;\n      this.canvas = render.canvas;\n      var gl = this.gl = render.gl;\n      this.pw = _glutil2.default.createProgram(gl, this.vShader, this.fShader);\n      this.program = this.pw.program;\n      gl.useProgram(this.program);\n      // vertexPos\n      var vertexPosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]));\n      _glutil2.default.bindAttribute(gl, vertexPosBuffer, this.pw.vertexPos, 2);\n\n      // texturePos\n      var yTexturePosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]));\n      _glutil2.default.bindAttribute(gl, yTexturePosBuffer, this.pw.yTexturePos, 2);\n\n      var uvTexturePosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]));\n      _glutil2.default.bindAttribute(gl, uvTexturePosBuffer, this.pw.uvTexturePos, 2);\n\n      var yTextureRef = _glutil2.default.createTexture(gl, gl.LINEAR);\n      gl.uniform1i(this.pw.ySampler, 0);\n\n      this.inputTextures.push(yTextureRef);\n\n      var uvTextureRef = _glutil2.default.createTexture(gl, gl.LINEAR);\n      gl.uniform1i(this.pw.uvSampler, 1);\n\n      this.inputTextures.push(uvTextureRef);\n\n      var yuv2rgb = [1.16438, 0.00000, 1.59603, -0.87079, 1.16438, -0.39176, -0.81297, 0.52959, 1.16438, 2.01723, 0.00000, -1.08139, 0, 0, 0, 1];\n      gl.uniformMatrix4fv(this.pw.yuv2rgb, false, yuv2rgb);\n    }\n  }, {\n    key: 'render',\n    value: function render(data, width, height) {\n      var ydata = data[0];\n      var uvdata = data[1];\n      var gl = this.gl;\n      var program = this.program;\n      var yTextureRef = this.inputTextures[0];\n      var uvTextureRef = this.inputTextures[1];\n\n      this.outputTexuture = _glutil2.default.createTexture(gl, gl.LINEAR, new Uint8Array(width * height * 4), width, height);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.outputTexuture, 0);\n\n      gl.useProgram(program);\n      gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, yTextureRef);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width / 2, height / 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, ydata);\n\n      gl.activeTexture(gl.TEXTURE1);\n      gl.bindTexture(gl.TEXTURE_2D, uvTextureRef);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width / 2, height / 4, 0, gl.RGBA, gl.UNSIGNED_BYTE, uvdata);\n\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n      return this.outputTexuture;\n    }\n  }]);\n\n  return Nv12;\n}(_filter2.default);\n\nexports.default = Nv12;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-render/src/fmt/nv12.js?")},"../xgplayer-render/src/fmt/rgb.js":
/*!*****************************************!*\
  !*** ../xgplayer-render/src/fmt/rgb.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _filter = __webpack_require__(/*! ../filter */ \"../xgplayer-render/src/filter.js\");\n\nvar _filter2 = _interopRequireDefault(_filter);\n\nvar _glutil = __webpack_require__(/*! ../glutil */ \"../xgplayer-render/src/glutil.js\");\n\nvar _glutil2 = _interopRequireDefault(_glutil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Rgb = function (_Filter) {\n  _inherits(Rgb, _Filter);\n\n  function Rgb(config) {\n    _classCallCheck(this, Rgb);\n\n    var _this = _possibleConstructorReturn(this, (Rgb.__proto__ || Object.getPrototypeOf(Rgb)).call(this));\n\n    _this.vShader = ['attribute vec4 vertexPos;', 'attribute vec2 texturePos;', 'varying vec2 textureCoord;', 'void main()', '{', '  gl_Position = vertexPos;', '  textureCoord = texturePos;', '}'].join('\\n');\n    _this.fShader = ['precision highp float;', 'varying highp vec2 textureCoord;', 'uniform sampler2D sampler;', 'uniform vec2 outerSize;', 'uniform mat4 YUV2RGB;', 'void main(void) {', '  float my = floor(mod(textureCoord.y * outerSize.y, 4.0));', '  float cy = 1.0 / outerSize.y;', '  float mx = floor(mod(outerSize.x, 4.0));', '  float cx = 1.0 / outerSize.x;', '  float width =  outerSize.x + mx;', '  float x = textureCoord.x + (mx * cx * textureCoord.y * outerSize.y);', '  x = cx * mod(x * outerSize.x, width);', '  float bdata, gdata, rdata;', '  vec4 color = texture2D(sampler, vec2(x, textureCoord.y));', '  rdata = color[0];', '  gdata = color[1];', '  bdata = color[2];', '  gl_FragColor = vec4(rdata, gdata, bdata, 1);', '}'].join('\\n');\n\n    return _this;\n  }\n\n  _createClass(Rgb, [{\n    key: 'init',\n    value: function init(render) {\n      this.rend = render;\n      this.canvas = render.canvas;\n      var gl = this.gl = render.gl;\n      this.pw = _glutil2.default.createProgram(gl, this.vShader, this.fShader);\n      this.program = this.pw.program;\n      gl.useProgram(this.program);\n      // vertexPos\n      var vertexPosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]));\n      _glutil2.default.bindAttribute(gl, vertexPosBuffer, this.pw.vertexPos, 2);\n\n      // texturePos\n      this.texturePosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]));\n      _glutil2.default.bindAttribute(gl, this.texturePosBuffer, this.pw.texturePos, 2);\n\n      var textureRef = _glutil2.default.createTexture(gl, gl.LINEAR);\n      gl.uniform1i(this.pw.sampler, 0);\n      this.inputTextures.push(textureRef);\n    }\n  }, {\n    key: 'render',\n    value: function render(data, width, height) {\n      data = data[0];\n      var gl = this.gl;\n      var program = this.program;\n      var textureRef = this.inputTextures[0];\n\n      this.outputTexuture = _glutil2.default.createTexture(gl, gl.LINEAR, new Uint8Array(width * height * 4), width, height);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.rend.fb);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.outputTexuture, 0);\n\n      gl.useProgram(program);\n      gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\n      var outerSizeRef = gl.getUniformLocation(program, 'outerSize');\n      gl.uniform2fv(outerSizeRef, [width, height]);\n\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, textureRef);\n      var inputx = width - width % 4;\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, inputx, height, 0, gl.RGB, gl.UNSIGNED_BYTE, data);\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n  }]);\n\n  return Rgb;\n}(_filter2.default);\n\nexports.default = Rgb;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-render/src/fmt/rgb.js?")},"../xgplayer-render/src/fmt/rgb24.js":
/*!*******************************************!*\
  !*** ../xgplayer-render/src/fmt/rgb24.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _filter = __webpack_require__(/*! ../filter */ \"../xgplayer-render/src/filter.js\");\n\nvar _filter2 = _interopRequireDefault(_filter);\n\nvar _glutil = __webpack_require__(/*! ../glutil */ \"../xgplayer-render/src/glutil.js\");\n\nvar _glutil2 = _interopRequireDefault(_glutil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Rgb24 = function (_Filter) {\n  _inherits(Rgb24, _Filter);\n\n  function Rgb24(config) {\n    _classCallCheck(this, Rgb24);\n\n    var _this = _possibleConstructorReturn(this, (Rgb24.__proto__ || Object.getPrototypeOf(Rgb24)).call(this));\n\n    _this.vShader = ['attribute vec4 vertexPos;', 'attribute vec2 texturePos;', 'varying vec2 textureCoord;', 'void main()', '{', '  gl_Position = vertexPos;', '  textureCoord = texturePos;', '}'].join('\\n');\n    _this.fShader = ['precision highp float;', 'varying highp vec2 textureCoord;', 'uniform sampler2D sampler;', 'uniform vec2 outerSize;', 'uniform mat4 YUV2RGB;', 'void main(void) {', '  float my = floor(mod(textureCoord.y * outerSize.y, 4.0));', '  float cy = 1.0 / outerSize.y;', '  float mx = floor(mod(outerSize.x, 4.0));', '  float cx = 1.0 / outerSize.x;', '  float width =  outerSize.x + mx;', '  float x = textureCoord.x + (mx * cx * textureCoord.y * outerSize.y);', '  x = cx * mod(x * outerSize.x, width);', '  float bdata, gdata, rdata;', '  vec4 color = texture2D(sampler, vec2(x, textureCoord.y));', '  rdata = color[0];', '  gdata = color[1];', '  bdata = color[2];', '  gl_FragColor = vec4(bdata, gdata, rdata, 1);', '}'].join('\\n');\n\n    return _this;\n  }\n\n  _createClass(Rgb24, [{\n    key: 'init',\n    value: function init(render) {\n      this.rend = render;\n      this.canvas = render.canvas;\n      var gl = this.gl = render.gl;\n      this.pw = _glutil2.default.createProgram(gl, this.vShader, this.fShader);\n      this.program = this.pw.program;\n      gl.useProgram(this.program);\n      // vertexPos\n      var vertexPosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]));\n      _glutil2.default.bindAttribute(gl, vertexPosBuffer, this.pw.vertexPos, 2);\n\n      // texturePos\n      this.texturePosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]));\n      _glutil2.default.bindAttribute(gl, this.texturePosBuffer, this.pw.texturePos, 2);\n\n      var textureRef = _glutil2.default.createTexture(gl, gl.LINEAR);\n      gl.uniform1i(this.pw.sampler, 0);\n      this.inputTextures.push(textureRef);\n    }\n  }, {\n    key: 'render',\n    value: function render(data, width, height) {\n      data = data[0];\n      var gl = this.gl;\n      var program = this.program;\n      var textureRef = this.inputTextures[0];\n\n      gl.useProgram(program);\n      gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\n      var outerSizeRef = gl.getUniformLocation(program, 'outerSize');\n      gl.uniform2fv(outerSizeRef, [width, height]);\n\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, textureRef);\n      var inputx = width - width % 4;\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, inputx, height, 0, gl.RGB, gl.UNSIGNED_BYTE, data);\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n  }]);\n\n  return Rgb24;\n}(_filter2.default);\n\nexports.default = Rgb24;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-render/src/fmt/rgb24.js?")},"../xgplayer-render/src/fmt/rgb32.js":
/*!*******************************************!*\
  !*** ../xgplayer-render/src/fmt/rgb32.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _filter = __webpack_require__(/*! ../filter */ \"../xgplayer-render/src/filter.js\");\n\nvar _filter2 = _interopRequireDefault(_filter);\n\nvar _glutil = __webpack_require__(/*! ../glutil */ \"../xgplayer-render/src/glutil.js\");\n\nvar _glutil2 = _interopRequireDefault(_glutil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Rgb32 = function (_Filter) {\n  _inherits(Rgb32, _Filter);\n\n  function Rgb32(config) {\n    _classCallCheck(this, Rgb32);\n\n    var _this = _possibleConstructorReturn(this, (Rgb32.__proto__ || Object.getPrototypeOf(Rgb32)).call(this));\n\n    _this.vShader = ['attribute vec4 vertexPos;', 'attribute vec2 texturePos;', 'varying vec2 textureCoord;', 'void main()', '{', '  gl_Position = vertexPos;', '  textureCoord = texturePos;', '}'].join('\\n');\n    _this.fShader = ['precision highp float;', 'varying highp vec2 textureCoord;', 'uniform sampler2D sampler;', 'void main(void) {', '  vec4 color = texture2D(sampler, textureCoord);', '  gl_FragColor = vec4(color[2],color[1],color[0],color[3]);', '}'].join('\\n');\n    return _this;\n  }\n\n  _createClass(Rgb32, [{\n    key: 'init',\n    value: function init(render) {\n      this.rend = render;\n      this.canvas = render.canvas;\n      var gl = this.gl = render.gl;\n      this.pw = _glutil2.default.createProgram(gl, this.vShader, this.fShader);\n      this.program = this.pw.program;\n\n      gl.useProgram(this.program);\n      // vertexPos\n      var vertexPosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]));\n      _glutil2.default.bindAttribute(gl, vertexPosBuffer, this.pw.vertexPos, 2);\n\n      // texturePos\n      this.texturePosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]));\n      _glutil2.default.bindAttribute(gl, this.texturePosBuffer, this.pw.texturePos, 2);\n\n      var textureRef = _glutil2.default.createTexture(gl, gl.LINEAR);\n      gl.uniform1i(this.pw.sampler, 0);\n\n      this.inputTextures.push(textureRef);\n    }\n  }, {\n    key: 'render',\n    value: function render(data, width, height) {\n      data = data[0];\n      var gl = this.gl;\n      var program = this.program;\n      var textureRef = this.inputTextures[0];\n\n      this.outputTexuture = _glutil2.default.createTexture(gl, gl.LINEAR, new Uint8Array(width * height * 4), width, height);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.rend.fb);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.outputTexuture, 0);\n\n      gl.useProgram(program);\n      gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, textureRef);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\n      return this.outputTexuture;\n    }\n  }]);\n\n  return Rgb32;\n}(_filter2.default);\n\nexports.default = Rgb32;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-render/src/fmt/rgb32.js?")},"../xgplayer-render/src/fmt/rgba.js":
/*!******************************************!*\
  !*** ../xgplayer-render/src/fmt/rgba.js ***!
  \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _filter = __webpack_require__(/*! ../filter */ \"../xgplayer-render/src/filter.js\");\n\nvar _filter2 = _interopRequireDefault(_filter);\n\nvar _glutil = __webpack_require__(/*! ../glutil */ \"../xgplayer-render/src/glutil.js\");\n\nvar _glutil2 = _interopRequireDefault(_glutil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Rgba = function (_Filter) {\n  _inherits(Rgba, _Filter);\n\n  function Rgba(config) {\n    _classCallCheck(this, Rgba);\n\n    var _this = _possibleConstructorReturn(this, (Rgba.__proto__ || Object.getPrototypeOf(Rgba)).call(this));\n\n    _this.vShader = ['attribute vec4 vertexPos;', 'attribute vec2 texturePos;', 'varying vec2 textureCoord;', 'void main()', '{', '  gl_Position = vertexPos;', '  textureCoord = texturePos;', '}'].join('\\n');\n    _this.fShader = ['precision highp float;', 'varying highp vec2 textureCoord;', 'uniform sampler2D sampler;', 'void main(void) {', '  vec4 color = texture2D(sampler, textureCoord);', '  gl_FragColor = vec4(color[0],color[1],color[2],color[3]);', '}'].join('\\n');\n    return _this;\n  }\n\n  _createClass(Rgba, [{\n    key: 'init',\n    value: function init(render) {\n      this.rend = render;\n      this.canvas = render.canvas;\n      var gl = this.gl = render.gl;\n      this.pw = _glutil2.default.createProgram(gl, this.vShader, this.fShader);\n      this.program = this.pw.program;\n\n      gl.useProgram(this.program);\n      // vertexPos\n      var vertexPosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]));\n      _glutil2.default.bindAttribute(gl, vertexPosBuffer, this.pw.vertexPos, 2);\n\n      // texturePos\n      this.texturePosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]));\n      _glutil2.default.bindAttribute(gl, this.texturePosBuffer, this.pw.texturePos, 2);\n\n      var textureRef = _glutil2.default.createTexture(gl, gl.LINEAR);\n      gl.uniform1i(this.pw.sampler, 0);\n\n      this.inputTextures.push(textureRef);\n    }\n  }, {\n    key: 'render',\n    value: function render(data, width, height) {\n      data = data[0];\n      var gl = this.gl;\n      var program = this.program;\n      var textureRef = this.inputTextures[0];\n\n      this.outputTexuture = _glutil2.default.createTexture(gl, gl.LINEAR, new Uint8Array(width * height * 4), width, height);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.rend.fb);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.outputTexuture, 0);\n\n      gl.useProgram(program);\n      gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, textureRef);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\n      return this.outputTexuture;\n    }\n  }]);\n\n  return Rgba;\n}(_filter2.default);\n\nexports.default = Rgba;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-render/src/fmt/rgba.js?")},"../xgplayer-render/src/fmt/yuv420.js":
/*!********************************************!*\
  !*** ../xgplayer-render/src/fmt/yuv420.js ***!
  \********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _filter = __webpack_require__(/*! ../filter */ \"../xgplayer-render/src/filter.js\");\n\nvar _filter2 = _interopRequireDefault(_filter);\n\nvar _glutil = __webpack_require__(/*! ../glutil */ \"../xgplayer-render/src/glutil.js\");\n\nvar _glutil2 = _interopRequireDefault(_glutil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Yuv420 = function (_Filter) {\n  _inherits(Yuv420, _Filter);\n\n  function Yuv420(render, config) {\n    _classCallCheck(this, Yuv420);\n\n    var _this = _possibleConstructorReturn(this, (Yuv420.__proto__ || Object.getPrototypeOf(Yuv420)).call(this));\n\n    _this.vShader = ['attribute vec4 vertexPos;', 'attribute vec2 yTexturePos;', 'attribute vec2 uTexturePos;', 'attribute vec2 vTexturePos;', 'varying vec2 yTextureCoord;', 'varying vec2 uTextureCoord;', 'varying vec2 vTextureCoord;', 'void main()', '{', '  gl_Position = vertexPos;', '  yTextureCoord = yTexturePos;', '  uTextureCoord = uTexturePos;', '  vTextureCoord = vTexturePos;', '}'].join('\\n');\n    _this.fShader = ['precision highp float;', 'varying highp vec2 yTextureCoord;', 'varying highp vec2 uTextureCoord;', 'varying highp vec2 vTextureCoord;', 'uniform sampler2D ySampler;', 'uniform sampler2D uSampler;', 'uniform sampler2D vSampler;', 'uniform mat4 yuv2rgb;', 'void main(void) {', '  highp float y = texture2D(ySampler,  yTextureCoord).r;', '  highp float u = texture2D(uSampler,  uTextureCoord).r;', '  highp float v = texture2D(vSampler,  vTextureCoord).r;', '  gl_FragColor = vec4(y, u, v, 1) * yuv2rgb;', '}'].join('\\n');\n    return _this;\n  }\n\n  _createClass(Yuv420, [{\n    key: 'init',\n    value: function init(render) {\n      this.rend = render;\n      this.canvas = render.canvas;\n      var gl = this.gl = render.gl;\n      this.pw = _glutil2.default.createProgram(gl, this.vShader, this.fShader);\n      this.program = this.pw.program;\n      gl.useProgram(this.program);\n      // vertexPos\n      var vertexPosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]));\n      _glutil2.default.bindAttribute(gl, vertexPosBuffer, this.pw.vertexPos, 2);\n\n      // texturePos\n      var yTexturePosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]));\n      _glutil2.default.bindAttribute(gl, yTexturePosBuffer, this.pw.yTexturePos, 2);\n\n      var uTexturePosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]));\n      _glutil2.default.bindAttribute(gl, uTexturePosBuffer, this.pw.uTexturePos, 2);\n\n      var vTexturePosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]));\n      _glutil2.default.bindAttribute(gl, vTexturePosBuffer, this.pw.vTexturePos, 2);\n\n      var yTextureRef = _glutil2.default.createTexture(gl, gl.LINEAR);\n      gl.uniform1i(this.pw.ySampler, 0);\n\n      this.inputTextures.push(yTextureRef);\n\n      var uTextureRef = _glutil2.default.createTexture(gl, gl.LINEAR);\n      gl.uniform1i(this.pw.uSampler, 1);\n\n      this.inputTextures.push(uTextureRef);\n\n      var vTextureRef = _glutil2.default.createTexture(gl, gl.LINEAR);\n      gl.uniform1i(this.pw.vSampler, 2);\n\n      this.inputTextures.push(vTextureRef);\n\n      var yuv2rgb = [1.16438, 0.00000, 1.59603, -0.87079, 1.16438, -0.39176, -0.81297, 0.52959, 1.16438, 2.01723, 0.00000, -1.08139, 0, 0, 0, 1];\n      gl.uniformMatrix4fv(this.pw.yuv2rgb, false, yuv2rgb);\n    }\n  }, {\n    key: 'render',\n    value: function render(data, width, height) {\n      var ydata = data[0];\n      var udata = data[1];\n      var vdata = data[2];\n      var gl = this.gl;\n      var program = this.program;\n      var yTextureRef = this.inputTextures[0];\n      var uTextureRef = this.inputTextures[1];\n      var vTextureRef = this.inputTextures[2];\n\n      this.outputTexuture = _glutil2.default.createTexture(gl, gl.LINEAR, new Uint8Array(width * height * 4), width, height);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.rend.fb);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.outputTexuture, 0);\n\n      gl.useProgram(program);\n      gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\n      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, yTextureRef);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, ydata);\n\n      gl.activeTexture(gl.TEXTURE1);\n      gl.bindTexture(gl.TEXTURE_2D, uTextureRef);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width / 2, height / 2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, udata);\n\n      gl.activeTexture(gl.TEXTURE2);\n      gl.bindTexture(gl.TEXTURE_2D, vTextureRef);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width / 2, height / 2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, vdata);\n\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\n      return this.outputTexuture;\n    }\n  }]);\n\n  return Yuv420;\n}(_filter2.default);\n\nexports.default = Yuv420;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-render/src/fmt/yuv420.js?")},"../xgplayer-render/src/fmt/yuyv422.js":
/*!*********************************************!*\
  !*** ../xgplayer-render/src/fmt/yuyv422.js ***!
  \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _filter = __webpack_require__(/*! ../filter */ \"../xgplayer-render/src/filter.js\");\n\nvar _filter2 = _interopRequireDefault(_filter);\n\nvar _glutil = __webpack_require__(/*! ../glutil */ \"../xgplayer-render/src/glutil.js\");\n\nvar _glutil2 = _interopRequireDefault(_glutil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Yuyv422 = function (_Filter) {\n  _inherits(Yuyv422, _Filter);\n\n  function Yuyv422(config) {\n    _classCallCheck(this, Yuyv422);\n\n    var _this = _possibleConstructorReturn(this, (Yuyv422.__proto__ || Object.getPrototypeOf(Yuyv422)).call(this));\n\n    _this.vShader = ['attribute vec4 vertexPos;', 'attribute vec2 texturePos;', 'varying vec2 textureCoord;', 'void main()', '{', '  gl_Position = vertexPos;', '  textureCoord = texturePos;', '}'].join('\\n');\n    _this.fShader = ['precision highp float;', 'varying highp vec2 textureCoord;', 'uniform sampler2D sampler;', 'uniform vec2 outerSize;', 'uniform mat4 yuv2rgb;', 'void main(void) {', '  float cx = 1.0 / outerSize.x;', '  float odd = floor(mod(textureCoord.x * outerSize.x, 2.0));', '  float x = textureCoord.x + 0.5 * cx - odd * cx;', '  vec4 color = texture2D(sampler, vec2(x, textureCoord.y));', '  float ydata = odd < 0.5?color[0]:color[2];', '  float udata = color[1];', '  float vdata = color[3];', '  gl_FragColor = vec4(ydata, udata, vdata, 1) * yuv2rgb;', '}'].join('\\n');\n    return _this;\n  }\n\n  _createClass(Yuyv422, [{\n    key: 'init',\n    value: function init(render) {\n      this.rend = render;\n      this.canvas = render.canvas;\n      var gl = this.gl = render.gl;\n      this.pw = _glutil2.default.createProgram(gl, this.vShader, this.fShader);\n      this.program = this.pw.program;\n      gl.useProgram(this.program);\n      // vertexPos\n      var vertexPosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]));\n      _glutil2.default.bindAttribute(gl, vertexPosBuffer, this.pw.vertexPos, 2);\n\n      // texturePos\n      this.texturePosBuffer = _glutil2.default.createBuffer(gl, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]));\n      _glutil2.default.bindAttribute(gl, this.texturePosBuffer, this.pw.texturePos, 2);\n\n      var textureRef = _glutil2.default.createTexture(gl, gl.LINEAR);\n      gl.uniform1i(this.pw.sampler, 0);\n\n      this.inputTextures.push(textureRef);\n\n      var yuv2rgb = [1.16438, 0.00000, 1.59603, -0.87079, 1.16438, -0.39176, -0.81297, 0.52959, 1.16438, 2.01723, 0.00000, -1.08139, 0, 0, 0, 1];\n      gl.uniformMatrix4fv(this.pw.yuv2rgb, false, yuv2rgb);\n    }\n  }, {\n    key: 'render',\n    value: function render(data, width, height) {\n      data = data[0];\n      var gl = this.gl;\n      var program = this.program;\n      var textureRef = this.inputTextures[0];\n\n      this.outputTexuture = _glutil2.default.createTexture(gl, gl.LINEAR, new Uint8Array(width * height * 4), width, height);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.rend.fb);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.outputTexuture, 0);\n\n      gl.useProgram(program);\n      gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\n      gl.uniform2fv(this.pw.outerSize, [width, height]);\n\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, textureRef);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width / 2, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\n      return this.outputTexuture;\n    }\n  }]);\n\n  return Yuyv422;\n}(_filter2.default);\n\nexports.default = Yuyv422;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-render/src/fmt/yuyv422.js?")},"../xgplayer-render/src/glutil.js":
/*!****************************************!*\
  !*** ../xgplayer-render/src/glutil.js ***!
  \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar GLUtil = function () {\n  function GLUtil() {\n    _classCallCheck(this, GLUtil);\n  }\n\n  _createClass(GLUtil, null, [{\n    key: "createTexture",\n    value: function createTexture(gl, filter, data, width, height) {\n      var textureRef = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, textureRef);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      if (data instanceof Uint8Array) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      } else if (data instanceof HTMLVideoElement) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      } else if (data instanceof HTMLImageElement) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      }\n      gl.bindTexture(gl.TEXTURE_2D, null);\n      return textureRef;\n    }\n  }, {\n    key: "createBuffer",\n    value: function createBuffer(gl, data) {\n      var buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n      return buffer;\n    }\n  }, {\n    key: "createShader",\n    value: function createShader(gl, type, source) {\n      var shader = gl.createShader(type);\n      gl.shaderSource(shader, source);\n\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        throw new Error(gl.getShaderInfoLog(shader));\n      }\n\n      return shader;\n    }\n  }, {\n    key: "createProgram",\n    value: function createProgram(gl, vertexSource, fragmentSource) {\n      var program = gl.createProgram();\n\n      var vertexShader = GLUtil.createShader(gl, gl.VERTEX_SHADER, vertexSource);\n      var fragmentShader = GLUtil.createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        throw new Error(gl.getProgramInfoLog(program));\n      }\n\n      var wrapper = { program: program };\n\n      var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n      for (var i = 0; i < numAttributes; i++) {\n        var attribute = gl.getActiveAttrib(program, i);\n        wrapper[attribute.name] = gl.getAttribLocation(program, attribute.name);\n      }\n      var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n      for (var i$1 = 0; i$1 < numUniforms; i$1++) {\n        var uniform = gl.getActiveUniform(program, i$1);\n        wrapper[uniform.name] = gl.getUniformLocation(program, uniform.name);\n      }\n\n      return wrapper;\n    }\n  }, {\n    key: "bindAttribute",\n    value: function bindAttribute(gl, buffer, attribute, numComponents) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.enableVertexAttribArray(attribute);\n      gl.vertexAttribPointer(attribute, numComponents, gl.FLOAT, false, 0, 0);\n    }\n  }]);\n\n  return GLUtil;\n}();\n\nexports.default = GLUtil;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-render/src/glutil.js?')},"../xgplayer-render/src/index.js":
/*!***************************************!*\
  !*** ../xgplayer-render/src/index.js ***!
  \***************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _glutil = __webpack_require__(/*! ./glutil */ \"../xgplayer-render/src/glutil.js\");\n\nvar _glutil2 = _interopRequireDefault(_glutil);\n\nvar _basic = __webpack_require__(/*! ./filter/basic */ \"../xgplayer-render/src/filter/basic.js\");\n\nvar _basic2 = _interopRequireDefault(_basic);\n\nvar _yuyv = __webpack_require__(/*! ./fmt/yuyv422 */ \"../xgplayer-render/src/fmt/yuyv422.js\");\n\nvar _yuyv2 = _interopRequireDefault(_yuyv);\n\nvar _rgb = __webpack_require__(/*! ./fmt/rgb32 */ \"../xgplayer-render/src/fmt/rgb32.js\");\n\nvar _rgb2 = _interopRequireDefault(_rgb);\n\nvar _rgb3 = __webpack_require__(/*! ./fmt/rgb24 */ \"../xgplayer-render/src/fmt/rgb24.js\");\n\nvar _rgb4 = _interopRequireDefault(_rgb3);\n\nvar _nv = __webpack_require__(/*! ./fmt/nv12 */ \"../xgplayer-render/src/fmt/nv12.js\");\n\nvar _nv2 = _interopRequireDefault(_nv);\n\nvar _yuv = __webpack_require__(/*! ./fmt/yuv420 */ \"../xgplayer-render/src/fmt/yuv420.js\");\n\nvar _yuv2 = _interopRequireDefault(_yuv);\n\nvar _rgba = __webpack_require__(/*! ./fmt/rgba */ \"../xgplayer-render/src/fmt/rgba.js\");\n\nvar _rgba2 = _interopRequireDefault(_rgba);\n\nvar _rgb5 = __webpack_require__(/*! ./fmt/rgb */ \"../xgplayer-render/src/fmt/rgb.js\");\n\nvar _rgb6 = _interopRequireDefault(_rgb5);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Render = function () {\n  function Render(config) {\n    _classCallCheck(this, Render);\n\n    this.canvas = config.canvas;\n    // input\n    if (config.video) {\n      this.video = config.video;\n      config.flip = 'y';\n    } else if (config.image) {\n      this.image = config.image;\n    } else {\n      this._initFmt(config);\n    }\n\n    this.filters = [];\n\n    if (config.opacity !== undefined || !!config.flip) {\n      this.basicFilter = new _basic2.default({ opacity: config.opacity, flip: config.flip });\n    } else {\n      this.basicFilter = new _basic2.default({ opacity: 1 });\n    }\n\n    if (config.filters) {\n      for (var i = 0; i < config.filters.length; i++) {\n        this.filters.push(config.filters[i]);\n      }\n    }\n    this._init();\n  }\n\n  _createClass(Render, [{\n    key: '_initFmt',\n    value: function _initFmt(config) {\n      switch (config.format) {\n        case 'YUY2':\n          this.fmt = new _yuyv2.default(this);\n          break;\n        case 'RGBA':\n          this.fmt = new _rgba2.default(this);\n          break;\n        case 'RGB':\n          this.fmt = new _rgb6.default(this);\n          break;\n        case 'RGB32':\n          this.fmt = new _rgb2.default(this);\n          break;\n        case 'RGB24':\n          this.fmt = new _rgb4.default(this);\n          break;\n        case 'NV12':\n          this.fmt = new _nv2.default(this);\n          break;\n        case 'YUV420':\n          this.fmt = new _yuv2.default(this);\n          break;\n        default:\n          break;\n      }\n    }\n  }, {\n    key: '_initImage',\n    value: function _initImage() {}\n  }, {\n    key: '_init',\n    value: function _init() {\n      this._initContextGL();\n\n      if (!this.gl) {\n        throw new Error('fail to init gl');\n      }\n\n      var gl = this.gl;\n      this.fb = gl.createFramebuffer();\n\n      if (this.fmt) {\n        this.fmt.init(this);\n      } else if (this.video) {\n        var width = this.video.videoWidth;\n        var height = this.video.videoHeight;\n        var emptyPixels = new Uint8Array(width * height * 4);\n        this.videoTexture = _glutil2.default.createTexture(gl, gl.LINEAR, emptyPixels, width, height);\n      }\n      this.basicFilter.init(this);\n\n      for (var i = 0; i < this.filters.length; i++) {\n        var filter = this.filters[i];\n        filter.init(this);\n      }\n    }\n  }, {\n    key: '_initContextGL',\n    value: function _initContextGL() {\n      var canvas = this.canvas;\n      var gl = null;\n\n      var validContextNames = ['webgl', 'experimental-webgl', 'moz-webgl', 'webkit-3d'];\n      var nameIndex = 0;\n\n      while (!gl && nameIndex < validContextNames.length) {\n        var contextName = validContextNames[nameIndex];\n\n        try {\n          gl = canvas.getContext(contextName);\n        } catch (e) {\n          gl = null;\n        }\n\n        if (!gl || typeof gl.getParameter !== 'function') {\n          gl = null;\n        }\n\n        ++nameIndex;\n      };\n\n      this.gl = gl;\n    }\n  }, {\n    key: '_drawPicture',\n    value: function _drawPicture(data, width, height) {\n      var texture = this.fmt.render(data, width, height);\n      this._applyFilters(texture, width, height);\n    }\n  }, {\n    key: '_drawVideo',\n    value: function _drawVideo() {\n      var gl = this.gl;\n      gl.bindTexture(gl.TEXTURE_2D, this.videoTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);\n      this._applyFilters(this.videoTexture, this.video.videoWidth, this.video.videoHeight);\n    }\n  }, {\n    key: '_applyFilters',\n    value: function _applyFilters(texture, width, height) {\n      var gl = this.gl;\n      for (var i = 0; i < this.filters.length; i++) {\n        var filter = this.filters[i];\n        texture = filter.render(texture, width, height);\n      }\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      this.basicFilter.render(texture, width, height);\n    }\n  }, {\n    key: 'render',\n    value: function render(data, width, height) {\n      if (this.fmt) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this._drawPicture(data, width, height);\n      } else if (this.video) {\n        this.canvas.width = this.video.videoWidth;\n        this.canvas.height = this.video.videoHeight;\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this._drawVideo();\n      }\n    }\n  }]);\n\n  return Render;\n}();\n\nexports.default = Render;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-render/src/index.js?")},"../xgplayer-utils/index.js":
/*!**********************************!*\
  !*** ../xgplayer-utils/index.js ***!
  \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = {\n  Context: __webpack_require__(/*! ./src/context */ "../xgplayer-utils/src/context.js").default,\n\n  // Modules from constants\n  EVENTS: __webpack_require__(/*! ./src/constants/events */ "../xgplayer-utils/src/constants/events.js").default,\n  WORKER_COMMANDS: __webpack_require__(/*! ./src/constants/worker-commands */ "../xgplayer-utils/src/constants/worker-commands.js").default,\n\n  // Modules from env\n  sniffer: __webpack_require__(/*! ./src/env/sniffer */ "../xgplayer-utils/src/env/sniffer.js").default,\n  isLe: __webpack_require__(/*! ./src/env/isle */ "../xgplayer-utils/src/env/isle.js").default,\n  UTF8: __webpack_require__(/*! ./src/env/utf8 */ "../xgplayer-utils/src/env/utf8.js").default,\n  PageVisibility: __webpack_require__(/*! ./src/env/PageVisibility */ "../xgplayer-utils/src/env/PageVisibility.js").default,\n\n  // Models\n  MediaInfo: __webpack_require__(/*! ./src/models/media-info */ "../xgplayer-utils/src/models/media-info.js").default,\n  MediaSample: __webpack_require__(/*! ./src/models/media-sample */ "../xgplayer-utils/src/models/media-sample.js").default,\n  MediaSegment: __webpack_require__(/*! ./src/models/media-segment */ "../xgplayer-utils/src/models/media-segment.js").default,\n  MediaSegmentList: __webpack_require__(/*! ./src/models/media-segment-list */ "../xgplayer-utils/src/models/media-segment-list.js").default,\n  AudioTrackMeta: __webpack_require__(/*! ./src/models/track-meta */ "../xgplayer-utils/src/models/track-meta.js").AudioTrackMeta,\n  VideoTrackMeta: __webpack_require__(/*! ./src/models/track-meta */ "../xgplayer-utils/src/models/track-meta.js").VideoTrackMeta,\n  AudioTrackSample: __webpack_require__(/*! ./src/models/track-sample */ "../xgplayer-utils/src/models/track-sample.js").AudioTrackSample,\n  VideoTrackSample: __webpack_require__(/*! ./src/models/track-sample */ "../xgplayer-utils/src/models/track-sample.js").VideoTrackSample,\n\n  // Modules from mse\n  Mse: __webpack_require__(/*! ./src/mse/index */ "../xgplayer-utils/src/mse/index.js").default,\n\n  // Modules from write\n  Stream: __webpack_require__(/*! ./src/write/stream */ "../xgplayer-utils/src/write/stream.js").default,\n  Buffer: __webpack_require__(/*! ./src/write/buffer */ "../xgplayer-utils/src/write/buffer.js").default,\n\n  MobileVideo: __webpack_require__(/*! ./src/mobile/mobile-video */ "../xgplayer-utils/src/mobile/mobile-video.js"),\n  // Crypto\n  Crypto: __webpack_require__(/*! ./src/crypto */ "../xgplayer-utils/src/crypto/index.js").default\n\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/index.js?')},"../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js":
/*!***********************************************************************!*\
  !*** ../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nexports.default = function (ResultConstructor) {\n  var totalLength = 0;\n\n  for (var _len = arguments.length, arrays = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    arrays[_key - 1] = arguments[_key];\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = arrays[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var arr = _step.value;\n\n      totalLength += arr.length;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var result = new ResultConstructor(totalLength);\n  var offset = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = arrays[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _arr = _step2.value;\n\n      result.set(_arr, offset);\n      offset += _arr.length;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return result;\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js?')},"../xgplayer-utils/node_modules/concat-typed-array/lib/index.js":
/*!**********************************************************************!*\
  !*** ../xgplayer-utils/node_modules/concat-typed-array/lib/index.js ***!
  \**********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _concat = __webpack_require__(/*! ./concat */ "../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js");\n\nvar _concat2 = _interopRequireDefault(_concat);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nmodule.exports = _concat2.default;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/node_modules/concat-typed-array/lib/index.js?')},"../xgplayer-utils/node_modules/webworkify-webpack/index.js":
/*!******************************************************************!*\
  !*** ../xgplayer-utils/node_modules/webworkify-webpack/index.js ***!
  \******************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction webpackBootstrapFunc(modules) {\n  /******/ // The module cache\n  /******/var installedModules = {};\n\n  /******/ // The require function\n  /******/function __webpack_require__(moduleId) {\n\n    /******/ // Check if module is in cache\n    /******/if (installedModules[moduleId])\n      /******/return installedModules[moduleId].exports;\n\n    /******/ // Create a new module (and put it into the cache)\n    /******/var module = installedModules[moduleId] = {\n      /******/i: moduleId,\n      /******/l: false,\n      /******/exports: {}\n      /******/ };\n\n    /******/ // Execute the module function\n    /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n    /******/ // Flag the module as loaded\n    /******/module.l = true;\n\n    /******/ // Return the exports of the module\n    /******/return module.exports;\n    /******/\n  }\n\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/__webpack_require__.m = modules;\n\n  /******/ // expose the module cache\n  /******/__webpack_require__.c = installedModules;\n\n  /******/ // identity function for calling harmony imports with the correct context\n  /******/__webpack_require__.i = function (value) {\n    return value;\n  };\n\n  /******/ // define getter function for harmony exports\n  /******/__webpack_require__.d = function (exports, name, getter) {\n    /******/if (!__webpack_require__.o(exports, name)) {\n      /******/Object.defineProperty(exports, name, {\n        /******/configurable: false,\n        /******/enumerable: true,\n        /******/get: getter\n        /******/ });\n      /******/\n    }\n    /******/\n  };\n\n  /******/ // define __esModule on exports\n  /******/__webpack_require__.r = function (exports) {\n    /******/Object.defineProperty(exports, '__esModule', { value: true });\n    /******/\n  };\n\n  /******/ // getDefaultExport function for compatibility with non-harmony modules\n  /******/__webpack_require__.n = function (module) {\n    /******/var getter = module && module.__esModule ?\n    /******/function getDefault() {\n      return module['default'];\n    } :\n    /******/function getModuleExports() {\n      return module;\n    };\n    /******/__webpack_require__.d(getter, 'a', getter);\n    /******/return getter;\n    /******/\n  };\n\n  /******/ // Object.prototype.hasOwnProperty.call\n  /******/__webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n\n  /******/ // __webpack_public_path__\n  /******/__webpack_require__.p = \"/\";\n\n  /******/ // on error function for async loading\n  /******/__webpack_require__.oe = function (err) {\n    console.error(err);throw err;\n  };\n\n  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE);\n  return f.default || f; // try to call default if defined to also support babel esmodule exports\n}\n\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+';\nvar dependencyRegExp = '\\\\(\\\\s*(\\/\\\\*.*?\\\\*\\/)?\\\\s*.*?(' + moduleNameReqExp + ').*?\\\\)'; // additional chars when output.pathinfo is true\n\n// http://stackoverflow.com/a/2593661/130442\nfunction quoteRegExp(str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&');\n}\n\nfunction isNumeric(n) {\n  return !isNaN(1 * n); // 1 * n converts integers, integers as string (\"123\"), 1e3 and \"1e3\" to integers and strings to NaN\n}\n\nfunction getModuleDependencies(sources, module, queueName) {\n  var retval = {};\n  retval[queueName] = [];\n\n  var fnString = module.toString();\n  var wrapperSignature = fnString.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/);\n  if (!wrapperSignature) return retval;\n  var webpackRequireName = wrapperSignature[1];\n\n  // main bundle deps\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g');\n  var match;\n  while (match = re.exec(fnString)) {\n    if (match[3] === 'dll-reference') continue;\n    retval[queueName].push(match[3]);\n  }\n\n  // dll deps\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g');\n  while (match = re.exec(fnString)) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1]);\n      sources[match[2]] = __webpack_require__(match[1]).m;\n    }\n    retval[match[2]] = retval[match[2]] || [];\n    retval[match[2]].push(match[4]);\n  }\n\n  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3\n  var keys = Object.keys(retval);\n  for (var i = 0; i < keys.length; i++) {\n    for (var j = 0; j < retval[keys[i]].length; j++) {\n      if (isNumeric(retval[keys[i]][j])) {\n        retval[keys[i]][j] = 1 * retval[keys[i]][j];\n      }\n    }\n  }\n\n  return retval;\n}\n\nfunction hasValuesInQueues(queues) {\n  var keys = Object.keys(queues);\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0;\n  }, false);\n}\n\nfunction getRequiredModules(sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  };\n  var requiredModules = {\n    main: []\n  };\n  var seenModules = {\n    main: {}\n  };\n\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue);\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i];\n      var queue = modulesQueue[queueName];\n      var moduleToCheck = queue.pop();\n      seenModules[queueName] = seenModules[queueName] || {};\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue;\n      seenModules[queueName][moduleToCheck] = true;\n      requiredModules[queueName] = requiredModules[queueName] || [];\n      requiredModules[queueName].push(moduleToCheck);\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);\n      var newModulesKeys = Object.keys(newModules);\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);\n      }\n    }\n  }\n\n  return requiredModules;\n}\n\nmodule.exports = function (moduleId, options) {\n  options = options || {};\n  var sources = {\n    main: __webpack_require__.m\n  };\n\n  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId);\n\n  var src = '';\n\n  Object.keys(requiredModules).filter(function (m) {\n    return m !== 'main';\n  }).forEach(function (module) {\n    var entryModule = 0;\n    while (requiredModules[module][entryModule]) {\n      entryModule++;\n    }\n    requiredModules[module].push(entryModule);\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })';\n    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) {\n      return '' + JSON.stringify(id) + ': ' + sources[module][id].toString();\n    }).join(',') + '});\\n';\n  });\n\n  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) {\n    return '' + JSON.stringify(id) + ': ' + sources.main[id].toString();\n  }).join(',') + '}))(self);';\n\n  var blob = new window.Blob([src], { type: 'text/javascript' });\n  if (options.bare) {\n    return blob;\n  }\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n  var workerUrl = URL.createObjectURL(blob);\n  var worker = new window.Worker(workerUrl);\n  worker.objectURL = workerUrl;\n\n  return worker;\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/node_modules/webworkify-webpack/index.js?")},"../xgplayer-utils/src/constants/events.js":
/*!*************************************************!*\
  !*** ../xgplayer-utils/src/constants/events.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst LOADER_EVENTS = {\n  LADER_START: 'LOADER_START',\n  LOADER_DATALOADED: 'LOADER_DATALOADED',\n  LOADER_COMPLETE: 'LOADER_COMPLETE',\n  LOADER_ERROR: 'LOADER_ERROR'\n};\n\nconst DEMUX_EVENTS = {\n  DEMUX_START: 'DEMUX_START',\n  DEMUX_COMPLETE: 'DEMUX_COMPLETE',\n  DEMUX_ERROR: 'DEMUX_ERROR',\n  METADATA_PARSED: 'METADATA_PARSED',\n  VIDEO_METADATA_CHANGE: 'VIDEO_METADATA_CHANGE',\n  AUDIO_METADATA_CHANGE: 'AUDIO_METADATA_CHANGE',\n  MEDIA_INFO: 'MEDIA_INFO'\n};\n\nconst REMUX_EVENTS = {\n  REMUX_METADATA: 'REMUX_METADATA',\n  REMUX_MEDIA: 'REMUX_MEDIA',\n  MEDIA_SEGMENT: 'MEDIA_SEGMENT',\n  REMUX_ERROR: 'REMUX_ERROR',\n  INIT_SEGMENT: 'INIT_SEGMENT',\n  DETECT_CHANGE_STREAM: 'DETECT_CHANGE_STREAM'\n};\n\nconst MSE_EVENTS = {\n  SOURCE_UPDATE_END: 'SOURCE_UPDATE_END'\n\n  // hls专有events\n};const HLS_EVENTS = {\n  RETRY_TIME_EXCEEDED: 'RETRY_TIME_EXCEEDED'\n};\n\nconst CRYTO_EVENTS = {\n  START_DECRYPT: 'START_DECRYPT',\n  DECRYPTED: 'DECRYPTED'\n};\n\nconst BROWSER_EVENTS = {\n  VISIBILITY_CHANGE: 'VISIBILITY_CHANGE'\n};\n\nconst ALLEVENTS = Object.assign({}, LOADER_EVENTS, DEMUX_EVENTS, REMUX_EVENTS, MSE_EVENTS, HLS_EVENTS, BROWSER_EVENTS);\n\nconst FlvAllowedEvents = [];\nconst HlsAllowedEvents = [];\n\nfor (let key in ALLEVENTS) {\n  if (ALLEVENTS.hasOwnProperty(key)) {\n    FlvAllowedEvents.push(ALLEVENTS[key]);\n  }\n}\n\nfor (let key in ALLEVENTS) {\n  if (ALLEVENTS.hasOwnProperty(key)) {\n    HlsAllowedEvents.push(ALLEVENTS[key]);\n  }\n}\n\nexports.default = {\n  ALLEVENTS,\n  HLS_EVENTS,\n  REMUX_EVENTS,\n  DEMUX_EVENTS,\n  MSE_EVENTS,\n  LOADER_EVENTS,\n  FlvAllowedEvents,\n  HlsAllowedEvents,\n  CRYTO_EVENTS,\n  BROWSER_EVENTS\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/constants/events.js?")},"../xgplayer-utils/src/constants/worker-commands.js":
/*!**********************************************************!*\
  !*** ../xgplayer-utils/src/constants/worker-commands.js ***!
  \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst CONTEXT_COMOMANDS = exports.CONTEXT_COMOMANDS = {\n  ON: 'on',\n  ONCE: 'once',\n  OFF: 'off',\n  EMIT: 'emit',\n  DESTROY: 'destroy'\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/constants/worker-commands.js?")},"../xgplayer-utils/src/context.js":
/*!****************************************!*\
  !*** ../xgplayer-utils/src/context.js ***!
  \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mediaInfo = __webpack_require__(/*! ./models/media-info */ \"../xgplayer-utils/src/models/media-info.js\");\n\nvar _mediaInfo2 = _interopRequireDefault(_mediaInfo);\n\nvar _events = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nconst DIRECT_EMIT_FLAG = '__TO__';\n\nlet Context = function () {\n  function Context() {\n    let allowedEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, Context);\n\n    this._emitter = new _events.EventEmitter();\n    this._instanceMap = {}; // 所有的解码流程实例\n    this._clsMap = {}; // 构造函数的map\n    this._inited = false;\n    this.mediaInfo = new _mediaInfo2.default();\n    this.allowedEvents = allowedEvents;\n    this._hooks = {}; // 注册在事件前/后的钩子，例如 before('DEMUX_COMPLETE')\n  }\n\n  /**\n   * 从上下文中获取解码流程实例，如果没有实例，构造一个\n   * @param tag\n   * @param args\n   * @returns {*}\n   */\n\n\n  _createClass(Context, [{\n    key: 'getInstance',\n    value: function getInstance(tag) {\n      const instance = this._instanceMap[tag];\n      if (instance) {\n        return instance;\n      } else {\n        // throw new Error(`${tag}实例尚未初始化`)\n        return null;\n      }\n    }\n\n    /**\n     * 初始化具体实例\n     * @param tag\n     * @param args\n     */\n\n  }, {\n    key: 'initInstance',\n    value: function initInstance(tag) {\n      if (this._clsMap[tag]) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        const newInstance = new (Function.prototype.bind.apply(this._clsMap[tag], [null].concat(args)))();\n        this._instanceMap[tag] = newInstance;\n        if (newInstance.init) {\n          newInstance.init(); // TODO: lifecircle\n        }\n        return newInstance;\n      } else {\n        throw new Error(`${tag}未在context中注册`);\n      }\n    }\n\n    /**\n     * 避免大量的initInstance调用，初始化所有的组件\n     * @param config\n     */\n\n  }, {\n    key: 'init',\n    value: function init(config) {\n      if (this._inited) {\n        return;\n      }\n      for (let tag in this._clsMap) {\n        // if not inited, init an instance\n        if (this._clsMap.hasOwnProperty(tag) && !this._instanceMap[tag]) {\n          this.initInstance(tag, config);\n        }\n      }\n      this._inited = true;\n    }\n\n    /**\n     * 注册一个上下文流程，提供安全的事件发送机制\n     * @param tag\n     * @param cls\n     */\n\n  }, {\n    key: 'registry',\n    value: function registry(tag, cls) {\n      var _this2 = this;\n\n      const emitter = this._emitter;\n      const checkMessageName = this._isMessageNameValid.bind(this);\n      const self = this;\n      const enhanced = function (_cls) {\n        _inherits(enhanced, _cls);\n\n        function enhanced() {\n          var _ref;\n\n          _classCallCheck(this, enhanced);\n\n          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          var _this = _possibleConstructorReturn(this, (_ref = enhanced.__proto__ || Object.getPrototypeOf(enhanced)).call.apply(_ref, [this].concat(args)));\n\n          _this.listeners = {};\n          _this.onceListeners = {};\n          _this.TAG = tag;\n          _this._context = self;\n          return _this;\n        }\n\n        _createClass(enhanced, [{\n          key: 'on',\n          value: function on(messageName, callback) {\n            checkMessageName(messageName);\n\n            if (this.listeners[messageName]) {\n              this.listeners[messageName].push(callback);\n            } else {\n              this.listeners[messageName] = [callback];\n            }\n\n            emitter.on(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback); // 建立定向通信监听\n            return emitter.on(messageName, callback);\n          }\n\n          /**\n           * 在某个事件触发前执行\n           * @param messageName\n           * @param callback\n           */\n\n        }, {\n          key: 'before',\n          value: function before(messageName, callback) {\n            checkMessageName(messageName);\n            if (self._hooks[messageName]) {\n              self._hooks[messageName].push(callback);\n            } else {\n              self._hooks[messageName] = [callback];\n            }\n          }\n        }, {\n          key: 'once',\n          value: function once(messageName, callback) {\n            checkMessageName(messageName);\n\n            if (this.onceListeners[messageName]) {\n              this.onceListeners[messageName].push(callback);\n            } else {\n              this.onceListeners[messageName] = [callback];\n            }\n\n            emitter.once(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback);\n            return emitter.once(messageName, callback);\n          }\n        }, {\n          key: 'emit',\n          value: function emit(messageName) {\n            checkMessageName(messageName);\n\n            const beforeList = self._hooks ? self._hooks[messageName] : null;\n\n            if (beforeList) {\n              for (let i = 0, len = beforeList.length; i < len; i++) {\n                const callback = beforeList[i];\n                callback();\n              }\n            }\n\n            for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n              args[_key3 - 1] = arguments[_key3];\n            }\n\n            return emitter.emit.apply(emitter, [messageName].concat(args));\n          }\n\n          /**\n           * 定向发送给某个组件单例的消息\n           * @param messageName\n           * @param args\n           */\n\n        }, {\n          key: 'emitTo',\n          value: function emitTo(tag, messageName) {\n            checkMessageName(messageName);\n\n            for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n              args[_key4 - 2] = arguments[_key4];\n            }\n\n            return emitter.emit.apply(emitter, [`${messageName}${DIRECT_EMIT_FLAG}${tag}`].concat(args));\n          }\n        }, {\n          key: 'off',\n          value: function off(messageName, callback) {\n            checkMessageName(messageName);\n            return emitter.off(messageName, callback);\n          }\n        }, {\n          key: 'removeListeners',\n          value: function removeListeners() {\n            const hasOwn = Object.prototype.hasOwnProperty.bind(this.listeners);\n\n            for (let messageName in this.listeners) {\n              if (hasOwn(messageName)) {\n                const callbacks = this.listeners[messageName] || [];\n                for (let i = 0; i < callbacks.length; i++) {\n                  const callback = callbacks[i];\n                  emitter.off(messageName, callback);\n                  emitter.off(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback);\n                }\n              }\n            }\n\n            for (let messageName in this.onceListeners) {\n              if (hasOwn(messageName)) {\n                const callbacks = this.onceListeners[messageName] || [];\n                for (let i = 0; i < callbacks.length; i++) {\n                  const callback = callbacks[i];\n                  emitter.off(messageName, callback);\n                  emitter.off(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback);\n                }\n              }\n            }\n          }\n\n          /**\n           * 在组件销毁时，默认将它注册的事件全部卸载，确保不会造成内存泄漏\n           */\n\n        }, {\n          key: 'destroy',\n          value: function destroy() {\n            // step1 unlisten events\n            this.removeListeners();\n            this.listeners = {};\n\n            // step2 release from context\n            delete self._instanceMap[tag];\n            if (_get(enhanced.prototype.__proto__ || Object.getPrototypeOf(enhanced.prototype), 'destroy', this)) {\n              return _get(enhanced.prototype.__proto__ || Object.getPrototypeOf(enhanced.prototype), 'destroy', this).call(this);\n            }\n          }\n        }]);\n\n        return enhanced;\n      }(cls);\n      this._clsMap[tag] = enhanced;\n\n      /**\n       * get instance immediately\n       * e.g const instance = context.registry(tag, Cls)(config)\n       * */\n      return function () {\n        for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n\n        return _this2.initInstance.apply(_this2, [tag].concat(args));\n      };\n    }\n\n    /**\n     * 对存在的实例进行\n     */\n\n  }, {\n    key: 'destroyInstances',\n    value: function destroyInstances() {\n      Object.keys(this._instanceMap).forEach(tag => {\n        if (this._instanceMap[tag].destroy) {\n          this._instanceMap[tag].destroy();\n        }\n      });\n    }\n\n    /**\n     * 编解码流程无需关注事件的解绑\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._emitter = null;\n      this.allowedEvents = [];\n      this._clsMap = null;\n      this._context = null;\n      this._hooks = null;\n      this.destroyInstances();\n    }\n\n    /**\n     * 对信道进行收拢\n     * @param messageName\n     * @private\n     */\n\n  }, {\n    key: '_isMessageNameValid',\n    value: function _isMessageNameValid(messageName) {\n      if (!this.allowedEvents.indexOf(messageName) < 0) {\n        throw new Error(`unregistered message name: ${messageName}`);\n      }\n    }\n  }]);\n\n  return Context;\n}();\n\nexports.default = Context;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/context.js?")},"../xgplayer-utils/src/crypto/index.js":
/*!*********************************************!*\
  !*** ../xgplayer-utils/src/crypto/index.js ***!
  \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(/*! ../constants/events */ \"../xgplayer-utils/src/constants/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nconst CRYTO_EVENTS = _events2.default.CRYTO_EVENTS;\n\nlet Crypto = function () {\n    function Crypto(config) {\n        _classCallCheck(this, Crypto);\n\n        this.inputBuffer = config.inputbuffer;\n        this.outputBuffer = config.outputbuffer;\n        this.key = config.key;\n        this.iv = config.iv;\n        this.method = config.method;\n\n        this.crypto = window.crypto || window.msCrypto;\n    }\n\n    _createClass(Crypto, [{\n        key: 'init',\n        value: function init() {\n            this.on(CRYTO_EVENTS.START_DECRYPT, this.decript.bind(this));\n        }\n    }, {\n        key: 'decript',\n        value: function decript() {\n            if (!this.aeskey) {\n                let sbkey = this.crypto.subtle.importKey('raw', this.key.buffer, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);\n                sbkey.then(key => {\n                    this.aeskey = key;\n                    this.decriptData();\n                });\n            } else {\n                this.decriptData();\n            }\n        }\n    }, {\n        key: 'decriptData',\n        value: function decriptData() {\n            let inputbuffer = this._context.getInstance(this.inputBuffer);\n            let outputbuffer = this._context.getInstance(this.outputBuffer);\n            let data = inputbuffer.shift();\n            if (data) {\n                this.crypto.subtle.decrypt({ name: 'AES-CBC', iv: this.iv.buffer }, this.aeskey, data).then(res => {\n                    outputbuffer.push(new Uint8Array(res));\n                    this.emit(CRYTO_EVENTS.DECRYPTED);\n                    this.decriptData(data);\n                });\n            }\n        }\n    }]);\n\n    return Crypto;\n}();\n\nexports.default = Crypto;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/crypto/index.js?")},"../xgplayer-utils/src/env/PageVisibility.js":
/*!***************************************************!*\
  !*** ../xgplayer-utils/src/env/PageVisibility.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(/*! ../constants/events */ \"../xgplayer-utils/src/constants/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nconst BROWSER_EVENTS = _events2.default.BROWSER_EVENTS;\n\nlet hidden;\nlet visibilityChange;\nif (typeof document.hidden !== 'undefined') {\n  // Opera 12.10 and Firefox 18 and later support\n  hidden = 'hidden';\n  visibilityChange = 'visibilitychange';\n} else if (typeof document.msHidden !== 'undefined') {\n  hidden = 'msHidden';\n  visibilityChange = 'msvisibilitychange';\n} else if (typeof document.webkitHidden !== 'undefined') {\n  hidden = 'webkitHidden';\n  visibilityChange = 'webkitvisibilitychange';\n}\n\nlet PageVisibility = function () {\n  function PageVisibility() {\n    _classCallCheck(this, PageVisibility);\n\n    this.callbacks = {\n      onShow: [],\n      onHidden: []\n    };\n    this.handleVisibilityChange = this.handleVisibilityChange.bind(this);\n    this.init();\n  }\n\n  _createClass(PageVisibility, [{\n    key: 'init',\n    value: function init() {\n      document.addEventListener(visibilityChange, this.handleVisibilityChange, false);\n    }\n  }, {\n    key: 'handleVisibilityChange',\n    value: function handleVisibilityChange() {\n      this.emit(BROWSER_EVENTS.VISIBILITY_CHANGE, document[hidden]);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      document.removeEventListener(visibilityChange, this.handleVisibilityChange);\n    }\n  }]);\n\n  return PageVisibility;\n}();\n\nexports.default = PageVisibility;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/env/PageVisibility.js?")},"../xgplayer-utils/src/env/isle.js":
/*!*****************************************!*\
  !*** ../xgplayer-utils/src/env/isle.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nconst le = function () {\n  const buf = new ArrayBuffer(2);\n  new DataView(buf).setInt16(0, 256, true); // little-endian write\n  return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n}();\n\nexports.default = le;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/env/isle.js?')},"../xgplayer-utils/src/env/sniffer.js":
/*!********************************************!*\
  !*** ../xgplayer-utils/src/env/sniffer.js ***!
  \********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst le = function () {\n  const buf = new ArrayBuffer(2);\n  new DataView(buf).setInt16(0, 256, true); // little-endian write\n  return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n}();\n\nconst sniffer = {\n  get device() {\n    let r = sniffer.os;\n    return r.isPc ? 'pc' : r.isTablet ? 'tablet' : 'mobile';\n  },\n  get browser() {\n    let ua = navigator.userAgent.toLowerCase();\n    let reg = {\n      ie: /rv:([\\d.]+)\\) like gecko/,\n      firfox: /firefox\\/([\\d.]+)/,\n      chrome: /chrome\\/([\\d.]+)/,\n      opera: /opera.([\\d.]+)/,\n      safari: /version\\/([\\d.]+).*safari/\n    };\n    return [].concat(Object.keys(reg).filter(key => reg[key].test(ua)))[0];\n  },\n  get os() {\n    let ua = navigator.userAgent;\n    let isWindowsPhone = /(?:Windows Phone)/.test(ua);\n    let isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone;\n    let isAndroid = /(?:Android)/.test(ua);\n    let isFireFox = /(?:Firefox)/.test(ua);\n    let isTablet = /(?:iPad|PlayBook)/.test(ua) || isAndroid && !/(?:Mobile)/.test(ua) || isFireFox && /(?:Tablet)/.test(ua);\n    let isPhone = /(?:iPhone)/.test(ua) && !isTablet;\n    let isPc = !isPhone && !isAndroid && !isSymbian;\n    return {\n      isTablet,\n      isPhone,\n      isAndroid,\n      isPc,\n      isSymbian,\n      isWindowsPhone,\n      isFireFox\n    };\n  },\n\n  get isLe() {\n    return le;\n  }\n};\n\nexports.default = sniffer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/env/sniffer.js?")},"../xgplayer-utils/src/env/utf8.js":
/*!*****************************************!*\
  !*** ../xgplayer-utils/src/env/utf8.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet UTF8 = function () {\n  function UTF8() {\n    _classCallCheck(this, UTF8);\n  }\n\n  _createClass(UTF8, null, [{\n    key: 'decode',\n    value: function decode(uint8array) {\n      const out = [];\n      const input = uint8array;\n      let i = 0;\n      const length = uint8array.length;\n\n      while (i < length) {\n        if (input[i] < 0x80) {\n          out.push(String.fromCharCode(input[i]));\n          ++i;\n          continue;\n        } else if (input[i] < 0xC0) {\n          // fallthrough\n        } else if (input[i] < 0xE0) {\n          if (UTF8._checkContinuation(input, i, 1)) {\n            const ucs4 = (input[i] & 0x1F) << 6 | input[i + 1] & 0x3F;\n            if (ucs4 >= 0x80) {\n              out.push(String.fromCharCode(ucs4 & 0xFFFF));\n              i += 2;\n              continue;\n            }\n          }\n        } else if (input[i] < 0xF0) {\n          if (UTF8._checkContinuation(input, i, 2)) {\n            const ucs4 = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;\n            if (ucs4 >= 0x800 && (ucs4 & 0xF800) !== 0xD800) {\n              out.push(String.fromCharCode(ucs4 & 0xFFFF));\n              i += 3;\n              continue;\n            }\n          }\n        } else if (input[i] < 0xF8) {\n          if (UTF8._checkContinuation(input, i, 3)) {\n            let ucs4 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 | (input[i + 2] & 0x3F) << 6 | input[i + 3] & 0x3F;\n            if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n              ucs4 -= 0x10000;\n              out.push(String.fromCharCode(ucs4 >>> 10 | 0xD800));\n              out.push(String.fromCharCode(ucs4 & 0x3FF | 0xDC00));\n              i += 4;\n              continue;\n            }\n          }\n        }\n        out.push(String.fromCharCode(0xFFFD));\n        ++i;\n      }\n\n      return out.join('');\n    }\n  }, {\n    key: '_checkContinuation',\n    value: function _checkContinuation(uint8array, start, checkLength) {\n      let array = uint8array;\n      if (start + checkLength < array.length) {\n        while (checkLength--) {\n          if ((array[++start] & 0xC0) !== 0x80) {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }]);\n\n  return UTF8;\n}();\n\nexports.default = UTF8;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/env/utf8.js?")},"../xgplayer-utils/src/mobile/audio-context.js":
/*!*****************************************************!*\
  !*** ../xgplayer-utils/src/mobile/audio-context.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nlet AudioCtx = function (_EventEmitter) {\n  _inherits(AudioCtx, _EventEmitter);\n\n  function AudioCtx(config) {\n    _classCallCheck(this, AudioCtx);\n\n    var _this2 = _possibleConstructorReturn(this, (AudioCtx.__proto__ || Object.getPrototypeOf(AudioCtx)).call(this));\n\n    _this2.config = Object.assign({}, config);\n    let AudioContext = window.AudioContext || window.webkitAudioContext;\n    _this2.context = new AudioContext();\n    _this2.gainNode = _this2.context.createGain();\n    _this2.gainNode.connect(_this2.context.destination);\n    _this2.meta = undefined;\n    _this2.samples = [];\n    _this2.preloadTime = _this2.config.preloadTime || 3;\n    _this2.duration = 0;\n\n    _this2._currentBuffer = undefined;\n    _this2._nextBuffer = undefined;\n    _this2._lastpts = undefined;\n    _this2._preDecode = [];\n    _this2._currentTime = 0;\n    _this2._decoding = false;\n    _this2._volume = _this2.config.volume || 0.6;\n    // 记录外部传输的状态\n    _this2._played = false;\n    _this2.playFinish = null; // pending play task\n    _this2.waitNextID = null; // audio source end and next source not loaded\n    return _this2;\n  }\n\n  _createClass(AudioCtx, [{\n    key: 'decodeAudio',\n    value: function decodeAudio(audioTrack) {\n      let { samples } = audioTrack;\n      let data = samples;\n      audioTrack.samples = [];\n      this.setAudioData(data);\n    }\n  }, {\n    key: 'setAudioData',\n    value: function setAudioData(data) {\n      for (let i = 0; i < data.length; i++) {\n        data[i].pts = data[i].pts === undefined ? data[i].dts : data[i].pts;\n        this._preDecode.push(data[i]);\n      }\n      if (this._preDecode.length > 0) {\n        if (this._lastpts === undefined) {\n          this._lastpts = this._preDecode[0].pts;\n        }\n        if ((this._preDecode[this._preDecode.length - 1].pts - this._lastpts) / 1000 > this.preloadTime) {\n          this.decodeAAC();\n        }\n      }\n    }\n  }, {\n    key: 'decodeAAC',\n    value: function decodeAAC() {\n      if (this._decoding) {\n        return;\n      }\n      this._decoding = true;\n      let data = this._preDecode;\n      let samples = [];\n      let _this = this;\n      let sample = data.shift();\n      while (sample) {\n        let sampleData = AudioCtx.getAACData(this.meta, sample);\n        samples.push(sampleData);\n        this._lastpts = sample.pts;\n        sample = data.shift();\n      }\n      let buffer = AudioCtx.combileData(samples);\n      try {\n        this.context.decodeAudioData(buffer.buffer, function (buffer) {\n          let audioSource = _this.context.createBufferSource();\n          audioSource.buffer = buffer;\n          // audioSource.onended = _this.onSourceEnded.bind(_this);\n          _this.samples.push({\n            time: _this.duration,\n            duration: buffer.duration,\n            data: audioSource\n          });\n\n          _this.duration += buffer.duration;\n\n          if (!_this._currentBuffer) {\n            _this._currentBuffer = _this.getTimeBuffer(_this.currentTime);\n          }\n\n          if (!_this._nextBuffer && _this._currentBuffer) {\n            _this._nextBuffer = _this.getTimeBuffer(_this.currentTime + _this._currentBuffer.duration);\n          }\n          _this._decoding = false;\n\n          if ((_this._preDecode.length > 0 && _this._preDecode[_this._preDecode.length - 1].pts - _this._lastpts) / 1000 >= _this.preloadTime) {\n            _this.decodeAAC();\n          }\n\n          if (_this.playFinish) {\n            _this.playFinish();\n          }\n        }, e => {\n          console.error(e);\n        });\n      } catch (err) {\n        console.error(err);\n      }\n    }\n  }, {\n    key: 'onSourceEnded',\n    value: function onSourceEnded() {\n      if (!this._nextBuffer || !this._played) {\n        this.waitNextID = setTimeout(() => {\n          this.onSourceEnded();\n        }, 200);\n        return;\n      }\n      let audioSource = this._nextBuffer.data;\n      audioSource.start();\n      audioSource.connect(this.gainNode);\n      let _this = this;\n      setTimeout(() => {\n        _this.onSourceEnded.call(this);\n      }, audioSource.buffer.duration * 1000 - 10);\n      this._currentBuffer = this._nextBuffer;\n      this._currentTime = this._currentBuffer.time;\n      this._nextBuffer = this.getTimeBuffer(this.currentTime);\n      if (this._currentBuffer) {\n        this._nextBuffer = this.getTimeBuffer(this.currentTime + this._currentBuffer.duration);\n      }\n      this.emit('AUDIO_SOURCE_END');\n    }\n  }, {\n    key: 'play',\n    value: function play() {\n      if (this.playFinish) {\n        return;\n      }\n      this._played = true;\n      if (this.context.state === 'suspended') {\n        this.context.resume();\n      }\n      let _this = this;\n      const playStart = () => {\n        let audioSource = this._currentBuffer.data;\n        audioSource.connect(this.gainNode);\n        audioSource.start();\n        setTimeout(() => {\n          _this.onSourceEnded.call(this);\n        }, audioSource.buffer.duration * 1000 - 10);\n      };\n\n      if (!this._currentBuffer) {\n        return new Promise(resolve => {\n          this.playFinish = resolve;\n        }).then(() => {\n          this.playFinish = null;\n          playStart();\n        });\n      } else {\n        playStart();\n        return Promise.resolve();\n      }\n    }\n  }, {\n    key: 'pause',\n    value: function pause() {\n      const audioCtx = this.context;\n      if (audioCtx.state === 'running') {\n        audioCtx.suspend();\n      }\n    }\n  }, {\n    key: 'getTimeBuffer',\n    value: function getTimeBuffer(time) {\n      let ret;\n      for (let i = 0; i < this.samples.length; i++) {\n        let sample = this.samples[i];\n        if (sample.time <= time && sample.time + sample.duration > time) {\n          ret = sample;\n          break;\n        }\n      }\n      return ret;\n    }\n  }, {\n    key: 'setAudioMetaData',\n    value: function setAudioMetaData(meta) {\n      this.meta = meta;\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this.waitNextID) {\n        window.clearTimeout(this.waitNextID);\n      }\n      this.context.close();\n    }\n  }, {\n    key: 'currentTime',\n    get: function () {\n      return this._currentTime;\n    }\n  }, {\n    key: 'muted',\n    set: function (val) {\n      if (val) {\n        this.gainNode.gain.value = 0;\n      } else {\n        this.gainNode.gain.value = this._volume;\n      }\n    }\n  }, {\n    key: 'volume',\n    get: function () {\n      return this._volume;\n    },\n    set: function (val) {\n      if (val < 0) {\n        this._volume = 0;\n        this.gainNode.gain.value = 0;\n        return;\n      } else if (val > 1) {\n        this._volume = 1;\n        this.gainNode.gain.value = 1;\n        return;\n      }\n\n      this._volume = val;\n      this.gainNode.gain.value = val;\n    }\n  }], [{\n    key: 'getAACData',\n    value: function getAACData(meta, sample) {\n      let buffer = new Uint8Array(sample.data.byteLength + 7);\n      let adts = AudioCtx.getAdts(meta, sample.data);\n      buffer.set(adts);\n      buffer.set(sample.data, 7);\n      return buffer;\n    }\n  }, {\n    key: 'combileData',\n    value: function combileData(samples) {\n      // get length\n      let length = 0;\n      for (let i = 0, k = samples.length; i < k; i++) {\n        length += samples[i].byteLength;\n      }\n\n      let ret = new Uint8Array(length);\n      let offset = 0;\n      // combile data;\n      for (let i = 0, k = samples.length; i < k; i++) {\n        ret.set(samples[i], offset);\n        offset += samples[i].byteLength;\n      }\n      return ret;\n    }\n  }, {\n    key: 'getAdts',\n    value: function getAdts(meta, data) {\n      let adts = new Uint8Array(7);\n\n      // 设置同步位 0xfff 12bit\n      adts[0] = 0xff;\n      adts[1] = 0xf0;\n\n      // Object data (没什么人用MPEG-2了，HLS和FLV也全是MPEG-4，这里直接0)  1bit\n      // Level always 00 2bit\n      // CRC always 1 1bit\n      adts[1] = adts[1] | 0x01;\n\n      // profile 2bit\n      adts[2] = 0xc0 & meta.objectType - 1 << 6;\n\n      // sampleFrequencyIndex\n      adts[2] = adts[2] | 0x3c & meta.sampleRateIndex << 2;\n\n      // private bit 0 1bit\n      // chanel configuration 3bit\n      adts[2] = adts[2] | 0x01 & meta.channelCount >> 2;\n      adts[3] = 0xc0 & meta.channelCount << 6;\n\n      // original_copy: 0 1bit\n      // home: 0 1bit\n\n      // adts_variable_header()\n      // copyrighted_id_bit 0 1bit\n      // copyrighted_id_start 0 1bit\n\n      // aac_frame_length 13bit;\n      let aacframelength = data.byteLength + 7;\n\n      adts[3] = adts[3] | 0x03 & aacframelength >> 11;\n      adts[4] = 0xff & aacframelength >> 3;\n      adts[5] = 0xe0 & aacframelength << 5;\n\n      // adts_buffer_fullness 0x7ff 11bit\n      adts[5] = adts[5] | 0x1f;\n      adts[6] = 0xfc;\n\n      // number_of_raw_data_blocks_in_frame 0 2bit;\n      return adts;\n    }\n  }]);\n\n  return AudioCtx;\n}(_events2.default);\n\nexports.default = AudioCtx;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/audio-context.js?")},"../xgplayer-utils/src/mobile/mobile-video.js":
/*!****************************************************!*\
  !*** ../xgplayer-utils/src/mobile/mobile-video.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _videoContext = __webpack_require__(/*! ./video-context */ \"../xgplayer-utils/src/mobile/video-context.js\");\n\nvar _videoContext2 = _interopRequireDefault(_videoContext);\n\nvar _audioContext = __webpack_require__(/*! ./audio-context */ \"../xgplayer-utils/src/mobile/audio-context.js\");\n\nvar _audioContext2 = _interopRequireDefault(_audioContext);\n\nvar _ticker = __webpack_require__(/*! ./ticker */ \"../xgplayer-utils/src/mobile/ticker.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * 音画同步调和器\n */\nlet AVReconciler = function () {\n  function AVReconciler(props) {\n    _classCallCheck(this, AVReconciler);\n\n    this.aCtx = props.aCtx;\n    this.vCtx = props.vCtx;\n    this.video = props.video;\n    this.timeoutId = null;\n    this.start = null;\n  }\n\n  _createClass(AVReconciler, [{\n    key: 'doReconcile',\n    value: function doReconcile() {\n      const vCurTime = this.vCtx.currentTime || 0;\n      const aCurTime = (this.aCtx.currentTime || 0) * 1000;\n\n      const gap = vCurTime - aCurTime;\n      if (this.timeoutId) {\n        return;\n      }\n      if (gap > 200) {\n        // audio delayed for more than 100ms\n        this.video.start += gap;\n        this.vCtx.pause();\n        this.timeoutId = setTimeout(() => {\n          this.vCtx.play();\n          this.timeoutId = null;\n        }, gap);\n      } else if (gap < -120) {\n        this.video.start += gap;\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.start = null;\n      this.aCtx = null;\n      this.vCtx = null;\n    }\n  }]);\n\n  return AVReconciler;\n}();\n\n// eslint-disable-next-line no-undef\n\n\nlet MobileVideo = function (_HTMLElement) {\n  _inherits(MobileVideo, _HTMLElement);\n\n  function MobileVideo() {\n    _classCallCheck(this, MobileVideo);\n\n    var _this = _possibleConstructorReturn(this, (MobileVideo.__proto__ || Object.getPrototypeOf(MobileVideo)).call(this));\n\n    _this._canvas = document.createElement('canvas');\n    _this.handleAudioSourceEnd = _this.handleAudioSourceEnd.bind(_this);\n    _this.played = false;\n    _this.pendingPlayTask = null;\n    _this._paused = true;\n    _this.videoMetaInited = false;\n    _this.audioMetaInited = false;\n    _this.init();\n    return _this;\n  }\n\n  _createClass(MobileVideo, [{\n    key: 'init',\n    value: function init() {\n      this.vCtx = new _videoContext2.default(Object.assign({\n        canvas: this._canvas\n      }, { style: { width: this.width, height: this.height } }));\n      this.aCtx = new _audioContext2.default({});\n      this.ticker = new ((0, _ticker.getTicker)())();\n      this.reconciler = new AVReconciler({\n        vCtx: this.vCtx,\n        aCtx: this.aCtx,\n        video: this\n      });\n      this.vCtx.oncanplay = () => {\n        if (!this.played) {\n          this.appendChild(this._canvas);\n        }\n        this.dispatchEvent(new Event('canplay'));\n      };\n\n      this.aCtx.on('AUDIO_SOURCE_END', this.handleAudioSourceEnd);\n    }\n  }, {\n    key: 'handleAudioSourceEnd',\n    value: function handleAudioSourceEnd() {\n      this.reconciler.doReconcile();\n      this.vCtx.cleanBuffer();\n    }\n  }, {\n    key: '_cleanBuffer',\n    value: function _cleanBuffer() {\n      this.vCtx.cleanBuffer();\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.aCtx.destroy();\n      this.vCtx.destroy();\n      this.ticker.stop();\n      this.start = null;\n      this.reconciler.destroy();\n      this.aCtx = null;\n      this.vCtx = null;\n      this.ticker = null;\n    }\n  }, {\n    key: 'onDemuxComplete',\n    value: function onDemuxComplete(videoTrack, audioTrack) {\n      this.aCtx.decodeAudio(audioTrack);\n      this.vCtx.decodeVideo(videoTrack);\n    }\n  }, {\n    key: 'setAudioMeta',\n    value: function setAudioMeta(meta) {\n      if (this.audioMetaInited) {\n        this.aCtx.destroy();\n        this.aCtx = new _audioContext2.default({});\n      }\n      this.aCtx.setAudioMetaData(meta);\n      this.audioMetaInited = true;\n    }\n  }, {\n    key: 'setVideoMeta',\n    value: function setVideoMeta(meta) {\n      if (this.videoMetaInited) {\n        this.vCtx.destroy();\n        this.vCtx = new _videoContext2.default(Object.assign({\n          canvas: this._canvas\n        }, { style: { width: this.width, height: this.height } }));\n      }\n      this.vCtx.setVideoMetaData(meta);\n      this.videoMetaInited = true;\n    }\n  }, {\n    key: 'play',\n    value: function play() {\n      if (this.pendingPlayTask) {\n        return;\n      }\n\n      if (this.played) {\n        this.destroy();\n        this.init();\n      }\n      this.pendingPlayTask = Promise.all([this.vCtx.play(), this.aCtx.play().then(() => {\n        this.aCtx.muted = true;\n      })]).then(() => {\n        this.aCtx.muted = false;\n        this.ticker.start(() => {\n          if (!this.start) {\n            this.start = Date.now();\n          }\n          this._currentTime = Date.now() - this.start;\n          this.vCtx._onTimer(this._currentTime);\n        });\n\n        this.pendingPlayTask = null;\n        this.played = true;\n        this.dispatchEvent(new Event('play'));\n        this._paused = false;\n      });\n    }\n  }, {\n    key: 'pause',\n    value: function pause() {\n      this._paused = true;\n      this.aCtx.pause();\n      this.vCtx.pause();\n\n      this.dispatchEvent(new Event('pause'));\n    }\n  }, {\n    key: 'width',\n    get: function () {\n      return this.getAttribute('width') || this.videoWidth;\n    },\n    set: function (val) {\n      this.style.display = 'inline-block';\n      const pxVal = typeof val === 'number' ? `${val}px` : val;\n      this.setAttribute('width', pxVal);\n      this.style.width = pxVal;\n      this._canvas.width = val;\n    }\n  }, {\n    key: 'height',\n    get: function () {\n      return this.getAttribute('height');\n    },\n    set: function (val) {\n      this.style.display = 'inline-block';\n      const pxVal = typeof val === 'number' ? `${val}px` : val;\n      this.setAttribute('height', pxVal);\n      this.style.height = pxVal;\n      this._canvas.height = val;\n    }\n  }, {\n    key: 'videoWidth',\n    get: function () {\n      if (this.vCtx && this.vCtx.videoWidth) {\n        return this.vCtx.videoWidth;\n      }\n      return 0;\n    }\n  }, {\n    key: 'videoHeight',\n    get: function () {\n      if (this.vCtx && this.vCtx.videoHeight) {\n        return this.vCtx.videoHeight;\n      }\n      return 0;\n    }\n  }, {\n    key: 'src',\n    get: function () {\n      return this.getAttribute('src');\n    },\n    set: function (val) {\n      this.setAttribute('src', val);\n    }\n  }, {\n    key: 'readyState',\n    get: function () {\n      return this.videoMetaInited ? this.vCtx.readyState : 0;\n    }\n  }, {\n    key: 'seeking',\n    get: function () {\n      return this.videoMetaInited ? this.vCtx.seeking : false;\n    }\n  }, {\n    key: 'currentTime',\n    get: function () {\n      return this.videoMetaInited ? this.vCtx.currentTime / 1000 : 0;\n    }\n  }, {\n    key: 'duration',\n    get: function () {\n      return this.audioMetaInited ? this.aCtx.duration : 0;\n    }\n  }, {\n    key: 'paused',\n    get: function () {\n      return this._paused;\n    }\n  }, {\n    key: 'playbackRate',\n    get: function () {\n      if (this.hasAttribute('playbackRate')) {\n        return this.getAttribute('playbackRate');\n      } else {\n        return 1.0;\n      }\n    },\n    set: function (val) {\n      this.setAttribute('playbackrate', val);\n      this.aCtx.playbackRate = val;\n      this.vCtx.playbackRate = val;\n\n      this.dispatchEvent(new Event('ratechange'));\n    }\n  }, {\n    key: 'ended',\n    get: function () {\n      if (this.audioMetaInited) {\n        return this.aCtx.ended;\n      }\n      return false;\n    }\n  }, {\n    key: 'autoplay',\n    get: function () {\n      if (this.hasAttribute('autoplay')) {\n        return this.getAttribute('autoplay');\n      } else {\n        return false;\n      }\n    },\n    set: function (value) {\n      this.setAttribute('autoplay', value);\n    }\n  }, {\n    key: 'volume',\n    get: function () {\n      return this.aCtx.volume;\n    },\n    set: function (vol) {\n      this.setAttribute('volume', vol);\n      this.aCtx.volume = vol;\n    }\n  }, {\n    key: 'muted',\n    get: function () {\n      const attrMuted = this.getAttribute('muted') === 'true';\n      if (attrMuted !== undefined) {\n        return attrMuted;\n      } else if (this.getAttribute('volume')) {\n        return Number.parseInt(this.getAttribute('volume')) === 0;\n      } else {\n        return false;\n      }\n    },\n    set: function (val) {\n      this.setAttribute('muted', val);\n      if (!val) {\n        this.aCtx.muted = false;\n      } else {\n        this.aCtx.muted = true;\n      }\n    }\n  }, {\n    key: 'error',\n    get: function () {\n      return this.vCtx.error || this.aCtx.error;\n    }\n  }, {\n    key: 'buffered',\n    get: function () {\n      return this.vCtx.buffered;\n    }\n  }]);\n\n  return MobileVideo;\n}(HTMLElement);\n// eslint-disable-next-line no-undef\n\n\ncustomElements.define('mobile-video', MobileVideo);\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/mobile-video.js?")},"../xgplayer-utils/src/mobile/sourcebuffer.js":
/*!****************************************************!*\
  !*** ../xgplayer-utils/src/mobile/sourcebuffer.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet SourceBuffer = function () {\n  function SourceBuffer(config) {\n    _classCallCheck(this, SourceBuffer);\n\n    this.config = Object.assign({}, config);\n    this.type = this.config.type;\n    this.buffer = [];\n    this.currentGop = undefined;\n    this._lastGet = undefined;\n  }\n\n  _createClass(SourceBuffer, [{\n    key: 'push',\n    value: function push(frame) {\n      if (this.type === 'video') {\n        if (frame.isKeyframe) {\n          let currentGop = {\n            samples: [],\n            start: frame.dts,\n            end: frame.dts,\n            nextGop: undefined\n          };\n          if (this.currentGop) {\n            this.currentGop.nextGop = currentGop;\n          }\n          this.currentGop = currentGop;\n          this.buffer.push(this.currentGop);\n        }\n\n        if (this.currentGop) {\n          this.currentGop.samples.push(frame);\n\n          if (frame.dts < this.currentGop.start) {\n            this.currentGop.start = frame.dts;\n          }\n\n          if (frame.dts > this.currentGop.end) {\n            this.currentGop.end = frame.dts;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'get',\n    value: function get(time) {\n      if (this.type === 'video') {\n        if (this.buffer.length < 1) {\n          return;\n        }\n\n        if (time === undefined) {\n          let sample = this._getNext();\n          return sample;\n        }\n      }\n    }\n  }, {\n    key: '_getNext',\n    value: function _getNext() {\n      if (!this._lastGet) {\n        let gop = this.buffer[0];\n        if (gop.samples.length < 1) {\n          return;\n        }\n\n        this._lastGet = {\n          gop,\n          index: 0\n        };\n        return gop.samples[0];\n      } else {\n        let gop = this._lastGet.gop;\n        let sample = gop.samples[this._lastGet.index + 1];\n        if (sample) {\n          this._lastGet.index = this._lastGet.index + 1;\n          return sample;\n        } else {\n          gop = gop.nextGop;\n          if (!gop || gop.samples.length < 1) {\n            return;\n          }\n          sample = gop.samples[0];\n          this._lastGet = {\n            gop,\n            index: 0\n          };\n          return sample;\n        }\n      }\n    }\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      if (this.buffer.length < 0) {\n        return;\n      }\n\n      let i = 0;\n      let gop = this.buffer[0];\n      while (gop) {\n        if (gop.end < end && gop.start >= start) {\n          this.buffer.splice(i, 1);\n          gop = this.buffer[i];\n        } else {\n          i += 1;\n          gop = this.buffer[i];\n        }\n      }\n    }\n  }]);\n\n  return SourceBuffer;\n}();\n\nexports.default = SourceBuffer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/sourcebuffer.js?")},"../xgplayer-utils/src/mobile/ticker.js":
/*!**********************************************!*\
  !*** ../xgplayer-utils/src/mobile/ticker.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * @author fuyuhao@bytedance.com\n */\n\nlet Ticker = function () {\n  function Ticker(options) {\n    _classCallCheck(this, Ticker);\n\n    this.options = Object.assign({}, options || {}, {\n      interval: 16\n    });\n\n    this.callbacks = [];\n  }\n\n  _createClass(Ticker, [{\n    key: "start",\n    value: function start() {\n      for (var _len = arguments.length, callbacks = Array(_len), _key = 0; _key < _len; _key++) {\n        callbacks[_key] = arguments[_key];\n      }\n\n      this.callbacks = callbacks;\n    }\n  }, {\n    key: "onTick",\n    value: function onTick() {\n      for (let i = 0, len = this.callbacks.length; i < len; i++) {\n        const callback = this.callbacks[i];\n        callback();\n      }\n    }\n  }, {\n    key: "setInterval",\n    value: function setInterval(interval) {\n      this.options.interval = interval;\n      return this;\n    }\n  }]);\n\n  return Ticker;\n}();\n\n/**\n * ticker use requestAnimationFrame\n */\n\n\nlet RafTicker = function (_Ticker) {\n  _inherits(RafTicker, _Ticker);\n\n  function RafTicker(props) {\n    _classCallCheck(this, RafTicker);\n\n    var _this = _possibleConstructorReturn(this, (RafTicker.__proto__ || Object.getPrototypeOf(RafTicker)).call(this, props));\n\n    _this.prev = null;\n    _this.timerId = null;\n    _this._subTimerId = null;\n\n    _this._tickFunc = RafTicker.getTickFunc();\n    _this.tick = _this.tick.bind(_this);\n    return _this;\n  }\n\n  _createClass(RafTicker, [{\n    key: "start",\n    value: function start() {\n      var _get2;\n\n      for (var _len2 = arguments.length, callbacks = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        callbacks[_key2] = arguments[_key2];\n      }\n\n      (_get2 = _get(RafTicker.prototype.__proto__ || Object.getPrototypeOf(RafTicker.prototype), "start", this)).call.apply(_get2, [this].concat(callbacks));\n      this.tick();\n    }\n  }, {\n    key: "tick",\n    value: function tick() {\n      this.nextTick();\n      this.onTick();\n    }\n  }, {\n    key: "nextTick",\n    value: function nextTick() {\n      const { _tickFunc } = this;\n      this.timerId = _tickFunc(this.tick);\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      if (this.timerId) {\n        const cancelFunc = RafTicker.getCancelFunc();\n\n        cancelFunc(this.timerId);\n      }\n    }\n  }, {\n    key: "resume",\n    value: function resume() {\n      this.nextTick();\n    }\n  }], [{\n    key: "getTickFunc",\n    value: function getTickFunc() {\n      return window.requestAnimationFrame || window.webkitRequestAnimationFrame;\n    }\n  }, {\n    key: "getCancelFunc",\n    value: function getCancelFunc() {\n      return window.cancelAnimationFrame || window.webkitCancelAnimationFrame;\n    }\n  }, {\n    key: "isSupported",\n    value: function isSupported() {\n      return RafTicker.getTickFunc() !== undefined;\n    }\n  }]);\n\n  return RafTicker;\n}(Ticker);\n\n/**\n * use setTimeout for browsers without raf support\n */\n\n\nlet TimeoutTicker = function (_Ticker2) {\n  _inherits(TimeoutTicker, _Ticker2);\n\n  function TimeoutTicker(config) {\n    _classCallCheck(this, TimeoutTicker);\n\n    var _this2 = _possibleConstructorReturn(this, (TimeoutTicker.__proto__ || Object.getPrototypeOf(TimeoutTicker)).call(this, config));\n\n    _this2.timeoutId = null;\n    return _this2;\n  }\n\n  _createClass(TimeoutTicker, [{\n    key: "start",\n    value: function start() {\n      var _get3;\n\n      for (var _len3 = arguments.length, callbacks = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        callbacks[_key3] = arguments[_key3];\n      }\n\n      (_get3 = _get(TimeoutTicker.prototype.__proto__ || Object.getPrototypeOf(TimeoutTicker.prototype), "nextTick", this)).call.apply(_get3, [this].concat(callbacks));\n      this.timeoutId = window.setInterval(() => {\n        this.onTick();\n      }, this.options.interval || 16);\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      if (this.timeoutId) {\n        window.clearInterval(this.timeoutId);\n      }\n    }\n  }]);\n\n  return TimeoutTicker;\n}(Ticker);\n\n/**\n * 返回Ticker构造函数\n * @returns {Ticker}\n */\n\n\nconst getTicker = exports.getTicker = () => {\n  if (RafTicker.isSupported()) {\n    return RafTicker;\n  } else {\n    return TimeoutTicker;\n  }\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/ticker.js?')},"../xgplayer-utils/src/mobile/video-context.js":
/*!*****************************************************!*\
  !*** ../xgplayer-utils/src/mobile/video-context.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _webworkifyWebpack = __webpack_require__(/*! webworkify-webpack */ \"../xgplayer-utils/node_modules/webworkify-webpack/index.js\");\n\nvar _webworkifyWebpack2 = _interopRequireDefault(_webworkifyWebpack);\n\nvar _stream = __webpack_require__(/*! ../write/stream */ \"../xgplayer-utils/src/write/stream.js\");\n\nvar _stream2 = _interopRequireDefault(_stream);\n\nvar _nalunit = __webpack_require__(/*! xgplayer-codec/src/h264/nalunit */ \"../xgplayer-codec/src/h264/nalunit/index.js\");\n\nvar _nalunit2 = _interopRequireDefault(_nalunit);\n\nvar _index = __webpack_require__(/*! xgplayer-render/src/index */ \"../xgplayer-render/src/index.js\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _sourcebuffer = __webpack_require__(/*! ./sourcebuffer */ \"../xgplayer-utils/src/mobile/sourcebuffer.js\");\n\nvar _sourcebuffer2 = _interopRequireDefault(_sourcebuffer);\n\nvar _TimeRanges = __webpack_require__(/*! ../models/TimeRanges */ \"../xgplayer-utils/src/models/TimeRanges.js\");\n\nvar _TimeRanges2 = _interopRequireDefault(_TimeRanges);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet VideoCanvas = function () {\n  function VideoCanvas(config) {\n    _classCallCheck(this, VideoCanvas);\n\n    this.config = Object.assign({}, config);\n    this.canvas = this.config.canvas ? this.config.canvas : document.createElement('canvas');\n    this.source = new _sourcebuffer2.default({ type: 'video' });\n    this.preloadTime = this.config.preloadTime || 3;\n    this.oncanplay = undefined;\n    this.onFirstFrame = undefined;\n    this.meta = undefined;\n    this.readyStatus = 0;\n    this.paused = true;\n    this.count = 0;\n    this.currentTime = 0;\n    this.lastPlayed = 0;\n\n    this._decoderInited = false;\n    this._avccpushed = false;\n    this._decodedFrames = {};\n    this._lastSampleDts = undefined;\n    this._baseDts = undefined;\n    this._lastRenderTime = null;\n    this.playFinish = null;\n\n    this.canvas.style.maxWidth = '100%';\n    this.canvas.style.maxHeight = '100%';\n    this.canvas.style.top = 0;\n    this.canvas.style.bottom = 0;\n    this.canvas.style.left = 0;\n    this.canvas.style.right = 0;\n    this.canvas.style.margin = 'auto';\n    this.canvas.style.position = 'absolute';\n  }\n\n  _createClass(VideoCanvas, [{\n    key: 'pause',\n    value: function pause() {\n      this.paused = true;\n    }\n  }, {\n    key: 'initWasmWorker',\n    value: function initWasmWorker() {\n      let _this = this;\n      this.wasmworker = (0, _webworkifyWebpack2.default)(/*require.resolve*/(/*! ./worker.js */ \"../xgplayer-utils/src/mobile/worker.js\"));\n      this.wasmworker.postMessage({\n        msg: 'init',\n        meta: this.meta\n      });\n      this.wasmworker.addEventListener('message', msg => {\n        switch (msg.data.msg) {\n          case 'DECODER_READY':\n            _this._decoderInited = true;\n            break;\n          case 'DECODED':\n            this._onDecoded(msg.data);\n            break;\n        }\n      });\n    }\n  }, {\n    key: 'setVideoMetaData',\n    value: function setVideoMetaData(meta) {\n      this.meta = meta;\n      if (!this._decoderInited) {\n        this.initWasmWorker();\n        return;\n      }\n      this._avccpushed = true;\n      let data = new Uint8Array(meta.sps.byteLength + 4);\n      data.set([0, 0, 0, 1]);\n      data.set(meta.sps, 4);\n      this.wasmworker.postMessage({\n        msg: 'decode',\n        data: data\n      });\n\n      data = new Uint8Array(meta.pps.byteLength + 4);\n      data.set([0, 0, 0, 1]);\n      data.set(meta.pps, 4);\n      this.wasmworker.postMessage({\n        msg: 'decode',\n        data: data\n      });\n\n      if (!this.yuvCanvas) {\n        let format = 'YUV420';\n        if (meta.chromaFormat === 422) {\n          format = 'YUV422P';\n        }\n        let config = Object.assign({ format, canvas: this.canvas }, this.config);\n        this.yuvCanvas = new _index2.default(config);\n      }\n      this.readyStatus = 1;\n    }\n  }, {\n    key: 'decodeVideo',\n    value: function decodeVideo(videoTrack) {\n      if (!this._decoderInited) {\n        return;\n      }\n\n      if (!this._avccpushed) {\n        this.setVideoMetaData(this.meta);\n      }\n      let { samples } = videoTrack;\n      let sample = samples.shift();\n\n      while (sample) {\n        if (!this._baseDts) {\n          this._baseDts = sample.dts;\n        }\n        this.source.push(sample);\n        sample = samples.shift();\n      }\n\n      this._preload();\n    }\n  }, {\n    key: '_preload',\n    value: function _preload() {\n      if (!this._lastSampleDts || this._lastSampleDts - this._baseDts < this.currentTime + this.preloadTime * 1000) {\n        let sample = this.source.get();\n        if (sample) {\n          this._lastSampleDts = sample.dts;\n          this._analyseNal(sample);\n        }\n\n        while (sample && this._lastSampleDts - this._baseDts < this.currentTime + this.preloadTime * 1000) {\n          sample = this.source.get();\n          if (sample) {\n            this._analyseNal(sample);\n            this._lastSampleDts = sample.dts;\n          }\n        }\n      }\n    }\n  }, {\n    key: '_analyseNal',\n    value: function _analyseNal(sample) {\n      let nals = _nalunit2.default.getAvccNals(new _stream2.default(sample.data.buffer));\n\n      let length = 0;\n      for (let i = 0; i < nals.length; i++) {\n        let nal = nals[i];\n        length += nal.body.byteLength + 4;\n      }\n      let offset = 0;\n      let data = new Uint8Array(length);\n      for (let i = 0; i < nals.length; i++) {\n        let nal = nals[i];\n        data.set([0, 0, 0, 1], offset);\n        offset += 4;\n        data.set(new Uint8Array(nal.body), offset);\n        offset += nal.body.byteLength;\n      }\n      this.wasmworker.postMessage({\n        msg: 'decode',\n        data: data,\n        info: {\n          dts: sample.dts,\n          pts: sample.pts ? sample.pts : sample.dts + sample.cts,\n          key: sample.isKeyframe\n        }\n      });\n    }\n  }, {\n    key: '_onDecoded',\n    value: function _onDecoded(data) {\n      let { dts } = data.info;\n      this._decodedFrames[dts] = data;\n      if (Object.keys(this._decodedFrames).length > 10) {\n        if (this.playFinish) {\n          this.playFinish();\n        }\n        if (this.oncanplay) {\n          this.oncanplay();\n        }\n      }\n    }\n  }, {\n    key: 'play',\n    value: function play() {\n      this.paused = false;\n      return new Promise(resolve => {\n        this.playFinish = resolve;\n      }).then(() => {\n        this.playFinish = null;\n      });\n    }\n  }, {\n    key: '_onTimer',\n    value: function _onTimer(currentTime) {\n      if (this.paused) {\n        return;\n      }\n\n      if (this.meta) {\n        if (this.meta.frameRate && this.meta.frameRate.fixed && this.meta.frameRate.fps) {}\n        let frameTimes = Object.keys(this._decodedFrames);\n        if (frameTimes.length > 0) {\n          this.currentTime = currentTime;\n          let frameTime = -1;\n          for (let i = 0; i < frameTimes.length && Number.parseInt(frameTimes[i]) - this._baseDts <= this.currentTime; i++) {\n            frameTime = Number.parseInt(frameTimes[i - 1]);\n          }\n\n          let frame = this._decodedFrames[frameTime];\n          if (frame) {\n            let buf = [];\n            if (this.meta.chromaFormat === 420) {\n\n              let buf0 = frame.buffer.slice(0, frame.yLinesize * frame.height);\n              let buf1 = frame.buffer.slice(frame.yLinesize * frame.height, frame.yLinesize * frame.height * 1.25);\n              let buf2 = frame.buffer.slice(frame.yLinesize * frame.height * 1.25, frame.yLinesize * frame.height * 1.5);\n              buf = [new Uint8Array(buf0), new Uint8Array(buf1), new Uint8Array(buf2)];\n            }\n            this.yuvCanvas.render(buf, frame.yLinesize, frame.height);\n          }\n          for (let i = 0; i < frameTimes.length; i++) {\n            if (Number.parseInt(frameTimes[i]) < frameTime) {\n              delete this._decodedFrames[frameTimes[i]];\n            }\n          }\n        }\n      }\n      this._lastRenderTime = Date.now();\n    }\n  }, {\n    key: 'cleanBuffer',\n    value: function cleanBuffer() {\n      if (this.currentTime > 1) {\n        this.source.remove(0, this.currentTime - 1);\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.wasmworker.postMessage({ msg: 'destroy' });\n      this.wasmworker = null;\n      this.canvas = null;\n      this.source = null;\n      this._decoderInited = false;\n    }\n  }, {\n    key: 'buffered',\n    get: function () {\n      const ranges = [];\n      let currentRange = {\n        start: null,\n        end: null\n      };\n      for (let i = 0; i < this.source.buffer.length; i++) {\n        const { start, end } = this.source.buffer[i];\n        if (!currentRange.start) {\n          currentRange.start = start;\n        }\n        if (!currentRange.end) {\n          currentRange.end = end;\n        }\n\n        if (start - currentRange.end > 1000) {\n          currentRange.start = currentRange.start / 1000;\n          currentRange.end = currentRange.end / 1000;\n          currentRange = {\n            start,\n            end\n          };\n        } else {\n          currentRange.end = end;\n        }\n      }\n\n      if (currentRange.start !== null && currentRange.end !== null) {\n        currentRange.start = currentRange.start / 1000;\n        currentRange.end = currentRange.end / 1000;\n        ranges.push(currentRange);\n      }\n\n      return new _TimeRanges2.default(ranges);\n    }\n  }]);\n\n  return VideoCanvas;\n}();\n\nexports.default = VideoCanvas;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/video-context.js?")},"../xgplayer-utils/src/mobile/worker.js":
/*!**********************************************!*\
  !*** ../xgplayer-utils/src/mobile/worker.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nconst MAX_STREAM_BUFFER_LENGTH = 1024 * 1024;\nvar Decoder = function (self) {\n  this.inited = false;\n  this.self = self;\n  this.meta = this.self.meta;\n  this.infolist = {};\n  self.par_broadwayOnBroadwayInited = this.broadwayOnBroadwayInited.bind(this);\n  self.par_broadwayOnPictureDecoded = this.broadwayOnPictureDecoded.bind(this);\n};\n\nDecoder.prototype.toU8Array = function (ptr, length) {\n  return this.self.HEAPU8.subarray(ptr, ptr + length);\n};\n\nDecoder.prototype.init = function () {\n  Module._broadwayInit();\n  this.streamBuffer = this.toU8Array(Module._broadwayCreateStream(MAX_STREAM_BUFFER_LENGTH), MAX_STREAM_BUFFER_LENGTH);\n};\n\nDecoder.prototype.broadwayOnPictureDecoded = function (offset, width, height, yLinesize, uvLinesize, infoid) {\n  let info = Object.assign({}, this.infolist[infoid]);\n  let yRowcount = height;\n  let uvRowcount = height / 2;\n  if (this.meta.chromaFormat === 444 || this.meta.chromaFormat === 422) {\n    uvRowcount = height;\n  }\n  let data = this.toU8Array(offset, yLinesize * yRowcount + 2 * (uvLinesize * uvRowcount));\n  this.infolist[infoid] = null;\n  let datetemp = new Uint8Array(data.length);\n  datetemp.set(data);\n  let buffer = datetemp.buffer;\n  this.self.postMessage({\n    msg: 'DECODED',\n    width,\n    height,\n    yLinesize,\n    uvLinesize,\n    info,\n    buffer\n  }, [buffer]);\n};\n\nDecoder.prototype.broadwayOnBroadwayInited = function () {\n  this.inited = true;\n  this.self.postMessage({ msg: 'DECODER_READY' });\n};\n\nDecoder.prototype.decode = function (data, info) {\n  let time = parseInt(new Date().getTime());\n  let infoid = time - Math.floor(time / 10e8) * 10e8;\n  this.infolist[infoid] = info;\n  this.streamBuffer.set(data);\n  Module._broadwayPlayStream(data.length, infoid);\n};\n\nDecoder.prototype.destroy = function () {\n  Module._broadwayExit();\n};\n\nvar decoder;\n\nfunction onPostRun() {\n  decoder = new Decoder(this);\n  decoder.init();\n}\n\nfunction init(meta) {\n  self.importScripts('https://sf1-vcloudcdn.pstatp.com/obj/ttfe/media/decoder/h264/decoder.js');\n  addOnPostRun(onPostRun.bind(self));\n}\n\nmodule.exports = function (self) {\n  self.addEventListener('message', function (e) {\n    var data = e.data;\n    if (!data.msg) {\n      self.postMessage({\n        msg: 'ERROR:invalid message'\n      });\n    } else {\n      switch (data.msg) {\n        case 'init':\n          console.log(data);\n          self.meta = data.meta;\n          init();\n          break;\n        case 'decode':\n          decoder.decode(data.data, data.info);\n          break;\n        case 'destory':\n          decoder.destroy();\n          break;\n        default:\n          break;\n      }\n    }\n  }, false);\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/worker.js?")},"../xgplayer-utils/src/models/TimeRanges.js":
/*!**************************************************!*\
  !*** ../xgplayer-utils/src/models/TimeRanges.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nlet TimeRanges = function () {\n  function TimeRanges(ranges) {\n    _classCallCheck(this, TimeRanges);\n\n    this.ranges = ranges || [];\n  }\n\n  _createClass(TimeRanges, [{\n    key: "start",\n    value: function start(idx) {\n      return this.ranges[idx] ? this.ranges[idx].start : 0;\n    }\n  }, {\n    key: "end",\n    value: function end(idx) {\n      return this.ranges[idx] ? this.ranges[idx].end : 0;\n    }\n  }, {\n    key: "add",\n    value: function add(range) {\n      this.ranges.push(range);\n    }\n  }, {\n    key: "length",\n    get: function () {\n      return this.ranges.length;\n    }\n  }]);\n\n  return TimeRanges;\n}();\n\nexports.default = TimeRanges;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/TimeRanges.js?')},"../xgplayer-utils/src/models/media-info.js":
/*!**************************************************!*\
  !*** ../xgplayer-utils/src/models/media-info.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nconst isObjectFilled = obj => {\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (obj[key] === null) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nlet MediaInfo = function () {\n  function MediaInfo() {\n    _classCallCheck(this, MediaInfo);\n\n    this.mimeType = null;\n    this.duration = null;\n\n    this.hasVideo = null;\n    this.video = {\n      codec: null,\n      width: null,\n      height: null,\n      profile: null,\n      level: null,\n      frameRate: {\n        fixed: true,\n        fps: 25,\n        fps_num: 25000,\n        fps_den: 1000\n      },\n      chromaFormat: null,\n      parRatio: {\n        width: 1,\n        height: 1\n      }\n    };\n\n    this.hasAudio = null;\n\n    this.audio = {\n      codec: null,\n      sampleRate: null,\n      sampleRateIndex: null,\n      channelCount: null\n    };\n  }\n\n  _createClass(MediaInfo, [{\n    key: "isComplete",\n    value: function isComplete() {\n      return MediaInfo.isBaseInfoReady(this) && MediaInfo.isVideoReady(this) && MediaInfo.isAudioReady(this);\n    }\n  }], [{\n    key: "isBaseInfoReady",\n    value: function isBaseInfoReady(mediaInfo) {\n      return isObjectFilled(mediaInfo);\n    }\n  }, {\n    key: "isVideoReady",\n    value: function isVideoReady(mediaInfo) {\n      if (!mediaInfo.hasVideo) {\n        return true;\n      }\n\n      return isObjectFilled(mediaInfo.video);\n    }\n  }, {\n    key: "isAudioReady",\n    value: function isAudioReady(mediaInfo) {\n      if (!mediaInfo.hasAudio) {\n        return true;\n      }\n\n      return isObjectFilled(mediaInfo.video);\n    }\n  }]);\n\n  return MediaInfo;\n}();\n\nexports.default = MediaInfo;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-info.js?')},"../xgplayer-utils/src/models/media-sample.js":
/*!****************************************************!*\
  !*** ../xgplayer-utils/src/models/media-sample.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nlet MediaSample = function () {\n  function MediaSample(info) {\n    _classCallCheck(this, MediaSample);\n\n    let _default = MediaSample.getDefaultInf();\n\n    if (!info || Object.prototype.toString.call(info) !== \'[object Object]\') {\n      return _default;\n    }\n    let sample = Object.assign({}, _default, info);\n\n    Object.entries(sample).forEach((_ref) => {\n      let [k, v] = _ref;\n\n      this[k] = v;\n    });\n  }\n\n  _createClass(MediaSample, null, [{\n    key: \'getDefaultInf\',\n    value: function getDefaultInf() {\n      return {\n        dts: null,\n        pts: null,\n        duration: null,\n        position: null,\n        isRAP: false, // is Random access point\n        originDts: null\n      };\n    }\n  }]);\n\n  return MediaSample;\n}();\n\nexports.default = MediaSample;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-sample.js?')},"../xgplayer-utils/src/models/media-segment-list.js":
/*!**********************************************************!*\
  !*** ../xgplayer-utils/src/models/media-segment-list.js ***!
  \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nlet MediaSegmentList = function () {\n    function MediaSegmentList(type) {\n        _classCallCheck(this, MediaSegmentList);\n\n        this._type = type;\n        this._list = [];\n        this._lastAppendLocation = -1; // cached last insert location\n    }\n\n    _createClass(MediaSegmentList, [{\n        key: "isEmpty",\n        value: function isEmpty() {\n            return this._list.length === 0;\n        }\n    }, {\n        key: "clear",\n        value: function clear() {\n            this._list = [];\n            this._lastAppendLocation = -1;\n        }\n    }, {\n        key: "_searchNearestSegmentBefore",\n        value: function _searchNearestSegmentBefore(beginDts) {\n            let list = this._list;\n            if (list.length === 0) {\n                return -2;\n            }\n            let last = list.length - 1;\n            let mid = 0;\n            let lbound = 0;\n            let ubound = last;\n\n            let idx = 0;\n\n            if (beginDts < list[0].originDts) {\n                idx = -1;\n                return idx;\n            }\n\n            while (lbound <= ubound) {\n                mid = lbound + Math.floor((ubound - lbound) / 2);\n                if (mid === last || beginDts > list[mid].lastSample.originDts && beginDts < list[mid + 1].originDts) {\n                    idx = mid;\n                    break;\n                } else if (list[mid].originDts < beginDts) {\n                    lbound = mid + 1;\n                } else {\n                    ubound = mid - 1;\n                }\n            }\n            return idx;\n        }\n    }, {\n        key: "_searchNearestSegmentAfter",\n        value: function _searchNearestSegmentAfter(beginDts) {\n            return this._searchNearestSegmentBefore(beginDts) + 1;\n        }\n    }, {\n        key: "append",\n        value: function append(segment) {\n            let list = this._list;\n            let lastAppendIdx = this._lastAppendLocation;\n            let insertIdx = 0;\n\n            if (lastAppendIdx !== -1 && lastAppendIdx < list.length && segment.originStartDts >= list[lastAppendIdx].lastSample.originDts && (lastAppendIdx === list.length - 1 || lastAppendIdx < list.length - 1 && segment.originStartDts < list[lastAppendIdx + 1].originStartDts)) {\n                insertIdx = lastAppendIdx + 1; // use cached location idx\n            } else {\n                if (list.length > 0) {\n                    insertIdx = this._searchNearestSegmentBefore(segment.originStartDts) + 1;\n                }\n            }\n\n            this._lastAppendLocation = insertIdx;\n            this._list.splice(insertIdx, 0, segment);\n        }\n    }, {\n        key: "getLastSegmentBefore",\n        value: function getLastSegmentBefore(beginDts) {\n            let idx = this._searchNearestSegmentBefore(beginDts);\n            if (idx >= 0) {\n                return this._list[idx];\n            } else {\n                // -1\n                return null;\n            }\n        }\n    }, {\n        key: "getLastSampleBefore",\n        value: function getLastSampleBefore(beginDts) {\n            let segment = this.getLastSegmentBefore(beginDts);\n            if (segment !== null) {\n                return segment.lastSample;\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: "getLastRAPBefore",\n        value: function getLastRAPBefore(beginDts) {\n            let segmentIdx = this._searchNearestSegmentBefore(beginDts);\n            let randomAccessPoints = this._list[segmentIdx].randomAccessPoints;\n            while (randomAccessPoints.length === 0 && segmentIdx > 0) {\n                segmentIdx--;\n                randomAccessPoints = this._list[segmentIdx].randomAccessPoints;\n            }\n            if (randomAccessPoints.length > 0) {\n                return randomAccessPoints[randomAccessPoints.length - 1];\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: "type",\n        get: function () {\n            return this._type;\n        }\n    }, {\n        key: "length",\n        get: function () {\n            return this._list.length;\n        }\n    }]);\n\n    return MediaSegmentList;\n}();\n\nexports.default = MediaSegmentList;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-segment-list.js?')},"../xgplayer-utils/src/models/media-segment.js":
/*!*****************************************************!*\
  !*** ../xgplayer-utils/src/models/media-segment.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nlet MediaSegment = function () {\n    function MediaSegment() {\n        _classCallCheck(this, MediaSegment);\n\n        this.startDts = -1;\n        this.endDts = -1;\n        this.startPts = -1;\n        this.endPts = -1;\n        this.originStartDts = -1;\n        this.originEndDts = -1;\n        this.randomAccessPoints = [];\n        this.firstSample = null;\n        this.lastSample = null;\n    }\n\n    _createClass(MediaSegment, [{\n        key: "addRAP",\n        value: function addRAP(sample) {\n            sample.isRAP = true;\n            this.randomAccessPoints.push(sample);\n        }\n    }]);\n\n    return MediaSegment;\n}();\n\nexports.default = MediaSegment;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-segment.js?')},"../xgplayer-utils/src/models/track-meta.js":
/*!**************************************************!*\
  !*** ../xgplayer-utils/src/models/track-meta.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet AudioTrackMeta = exports.AudioTrackMeta = function () {\n  function AudioTrackMeta(meta) {\n    _classCallCheck(this, AudioTrackMeta);\n\n    const _default = {\n      sampleRate: 48000,\n      channelCount: 2,\n      codec: 'mp4a.40.2',\n      config: [41, 401, 136, 0],\n      duration: 0,\n      id: 2,\n      refSampleDuration: 21,\n      sampleRateIndex: 3,\n      timescale: 1000,\n      type: 'audio'\n    };\n    if (meta) {\n      return Object.assign({}, _default, meta);\n    }\n    return _default;\n  }\n\n  _createClass(AudioTrackMeta, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.init = null;\n    }\n  }]);\n\n  return AudioTrackMeta;\n}();\n\nlet VideoTrackMeta = exports.VideoTrackMeta = function () {\n  function VideoTrackMeta(meta) {\n    _classCallCheck(this, VideoTrackMeta);\n\n    const _default = {\n      avcc: null,\n      sps: new Uint8Array(0),\n      pps: new Uint8Array(0),\n      chromaFormat: 420,\n      codec: 'avc1.640020',\n      codecHeight: 720,\n      codecWidth: 1280,\n      duration: 0,\n      frameRate: {\n        fixed: true,\n        fps: 25,\n        fps_num: 25000,\n        fps_den: 1000\n      },\n      id: 1,\n      level: '3.2',\n      presentHeight: 720,\n      presentWidth: 1280,\n      profile: 'High',\n      refSampleDuration: 40,\n      parRatio: {\n        height: 1,\n        width: 1\n      },\n      timescale: 1000,\n      type: 'video'\n    };\n\n    if (meta) {\n      return Object.assign({}, _default, meta);\n    }\n    return _default;\n  }\n\n  _createClass(VideoTrackMeta, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.init = null;\n      this.sps = null;\n      this.pps = null;\n    }\n  }]);\n\n  return VideoTrackMeta;\n}();\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/track-meta.js?")},"../xgplayer-utils/src/models/track-sample.js":
/*!****************************************************!*\
  !*** ../xgplayer-utils/src/models/track-sample.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nlet AudioTrackSample = exports.AudioTrackSample = function () {\n  function AudioTrackSample(info) {\n    _classCallCheck(this, AudioTrackSample);\n\n    let _default = AudioTrackSample.getDefault();\n    if (!info) {\n      return _default;\n    }\n    let sample = Object.assign({}, _default, info);\n\n    return sample;\n  }\n\n  _createClass(AudioTrackSample, null, [{\n    key: "getDefault",\n    value: function getDefault() {\n      return {\n        dts: null,\n        pts: null,\n        data: new Uint8Array()\n      };\n    }\n  }]);\n\n  return AudioTrackSample;\n}();\n\nlet VideoTrackSample = exports.VideoTrackSample = function () {\n  function VideoTrackSample(info) {\n    _classCallCheck(this, VideoTrackSample);\n\n    let _default = VideoTrackSample.getDefault();\n\n    if (!info) {\n      return _default;\n    }\n    let sample = Object.assign({}, _default, info);\n\n    return sample;\n  }\n\n  _createClass(VideoTrackSample, null, [{\n    key: "getDefault",\n    value: function getDefault() {\n      return {\n        dts: null,\n        pts: null,\n        isKeyframe: false, // is Random access point\n        originDts: null,\n        data: new Uint8Array()\n      };\n    }\n  }]);\n\n  return VideoTrackSample;\n}();\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/track-sample.js?')},"../xgplayer-utils/src/mse/index.js":
/*!******************************************!*\
  !*** ../xgplayer-utils/src/mse/index.js ***!
  \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet MSE = function () {\n  function MSE(configs) {\n    _classCallCheck(this, MSE);\n\n    this.configs = Object.assign({}, configs);\n    this.container = this.configs.container;\n    this.mediaSource = null;\n    this.sourceBuffers = {};\n    this.preloadTime = this.configs.preloadTime || 1;\n    this.onSourceOpen = this.onSourceOpen.bind(this);\n    this.onTimeUpdate = this.onTimeUpdate.bind(this);\n    this.onUpdateEnd = this.onUpdateEnd.bind(this);\n    this.onWaiting = this.onWaiting.bind(this);\n  }\n\n  _createClass(MSE, [{\n    key: 'init',\n    value: function init() {\n      // eslint-disable-next-line no-undef\n      this.mediaSource = new self.MediaSource();\n      this.mediaSource.addEventListener('sourceopen', this.onSourceOpen);\n      this.container.src = URL.createObjectURL(this.mediaSource);\n      this.url = this.container.src;\n      this.container.addEventListener('timeupdate', this.onTimeUpdate);\n      this.container.addEventListener('waiting', this.onWaiting);\n    }\n  }, {\n    key: 'onTimeUpdate',\n    value: function onTimeUpdate() {\n      this.emit('TIME_UPDATE', this.container);\n    }\n  }, {\n    key: 'onWaiting',\n    value: function onWaiting() {\n      this.emit('WAITING', this.container);\n    }\n  }, {\n    key: 'onSourceOpen',\n    value: function onSourceOpen() {\n      this.addSourceBuffers();\n    }\n  }, {\n    key: 'onUpdateEnd',\n    value: function onUpdateEnd() {\n      this.emit('SOURCE_UPDATE_END');\n      this.doAppend();\n    }\n  }, {\n    key: 'addSourceBuffers',\n    value: function addSourceBuffers() {\n      if (this.mediaSource.readyState !== 'open') {\n        return;\n      }\n      let sources = this._context.getInstance('PRE_SOURCE_BUFFER');\n      let tracks = this._context.getInstance('TRACKS');\n      let track;\n\n      sources = sources.sources;\n      let add = false;\n      for (let i = 0, k = Object.keys(sources).length; i < k; i++) {\n        let type = Object.keys(sources)[i];\n        if (type === 'audio') {\n          track = tracks.audioTrack;\n        } else if (type === 'video') {\n          track = tracks.videoTrack;\n          // return;\n        }\n        if (track) {\n          let dur = type === 'audio' ? 21 : 40;\n          if (track.meta && track.meta.refSampleDuration) dur = track.meta.refSampleDuration;\n          if (sources[type].data.length >= this.preloadTime / dur) {\n            add = true;\n          }\n        }\n      }\n\n      if (add) {\n        if (Object.keys(this.sourceBuffers).length > 0) {\n          return;\n        }\n        for (let i = 0, k = Object.keys(sources).length; i < k; i++) {\n          let type = Object.keys(sources)[i];\n          let source = sources[type];\n          let mime = type === 'video' ? 'video/mp4;codecs=' + source.mimetype : 'audio/mp4;codecs=' + source.mimetype;\n          let sourceBuffer = this.mediaSource.addSourceBuffer(mime);\n          this.sourceBuffers[type] = sourceBuffer;\n          sourceBuffer.addEventListener('updateend', this.onUpdateEnd);\n          this.doAppend();\n        }\n      }\n    }\n  }, {\n    key: 'doAppend',\n    value: function doAppend() {\n      let sources = this._context.getInstance('PRE_SOURCE_BUFFER');\n      if (sources) {\n        for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n          let type = Object.keys(this.sourceBuffers)[i];\n          let sourceBuffer = this.sourceBuffers[type];\n          if (!sourceBuffer.updating) {\n            let source = sources.sources[type];\n            if (source && !source.inited) {\n              // console.log('append initial segment')\n              sourceBuffer.appendBuffer(source.init.buffer.buffer);\n              source.inited = true;\n            } else if (source) {\n              let data = source.data.shift();\n              if (data) {\n                sourceBuffer.appendBuffer(data.buffer.buffer);\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'endOfStream',\n    value: function endOfStream() {\n      const { readyState, activeSourceBuffers } = this.mediaSource;\n      if (readyState === 'open' && activeSourceBuffers.length === 0) {\n        try {\n          this.mediaSource.endOfStream();\n        } catch (e) {\n          // log\n        }\n      }\n    }\n  }, {\n    key: 'remove',\n    value: function remove(end) {\n      let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n        let buffer = this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n        if (!buffer.updating) {\n          // console.log(start, end)\n          buffer.remove(start, end);\n        }\n      }\n    }\n  }, {\n    key: 'removeBuffers',\n    value: function removeBuffers() {\n      const taskList = [];\n      for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n        let buffer = this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n        buffer.removeEventListener('updateend', this.onUpdateEnd);\n\n        let task;\n        if (buffer.updating) {\n          task = new Promise(resolve => {\n            const doCleanBuffer = function () {\n              let retryTime = 3;\n\n              const clean = () => {\n                if (!buffer.updating) {\n                  MSE.clearBuffer(buffer);\n                  resolve();\n                } else if (retryTime > 0) {\n                  setTimeout(clean, 200);\n                  retryTime--;\n                } else {\n                  resolve();\n                }\n              };\n\n              setTimeout(clean, 200);\n              buffer.removeEventListener('updateend', doCleanBuffer);\n            };\n            buffer.addEventListener('updateend', doCleanBuffer);\n          });\n        } else {\n          MSE.clearBuffer(buffer);\n          task = Promise.resolve();\n        }\n\n        taskList.push(task);\n      }\n\n      return Promise.all(taskList);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      return this.removeBuffers().then(() => {\n        for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n          let buffer = this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n          this.mediaSource.removeSourceBuffer(buffer);\n          delete this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n        }\n\n        this.container.removeEventListener('timeupdate', this.onTimeUpdate);\n        this.container.removeEventListener('waiting', this.onWaiting);\n        this.mediaSource.removeEventListener('sourceopen', this.onSourceOpen);\n\n        this.endOfStream();\n        window.URL.revokeObjectURL(this.url);\n\n        this.url = null;\n        this.configs = {};\n        this.container = null;\n        this.mediaSource = null;\n        this.sourceBuffers = {};\n        this.preloadTime = 1;\n      });\n    }\n  }], [{\n    key: 'clearBuffer',\n    value: function clearBuffer(buffer) {\n      const buffered = buffer.buffered;\n      let bEnd = 0.1;\n      for (let i = 0, len = buffered.length; i < len; i++) {\n        bEnd = buffered.end(i);\n      }\n      try {\n        buffer.remove(0, bEnd);\n      } catch (e) {\n        // DO NOTHING\n      }\n    }\n  }]);\n\n  return MSE;\n}();\n\nexports.default = MSE;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mse/index.js?")},"../xgplayer-utils/src/write/buffer.js":
/*!*********************************************!*\
  !*** ../xgplayer-utils/src/write/buffer.js ***!
  \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _concatTypedArray = __webpack_require__(/*! concat-typed-array */ \"../xgplayer-utils/node_modules/concat-typed-array/lib/index.js\");\n\nvar _concatTypedArray2 = _interopRequireDefault(_concatTypedArray);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet Buffer = function () {\n  function Buffer(buffer) {\n    _classCallCheck(this, Buffer);\n\n    this.buffer = buffer || new Uint8Array(0);\n  }\n\n  _createClass(Buffer, [{\n    key: 'write',\n    value: function write() {\n      for (var _len = arguments.length, buffer = Array(_len), _key = 0; _key < _len; _key++) {\n        buffer[_key] = arguments[_key];\n      }\n\n      buffer.forEach(item => {\n        this.buffer = (0, _concatTypedArray2.default)(Uint8Array, this.buffer, item);\n      });\n    }\n  }], [{\n    key: 'writeUint32',\n    value: function writeUint32(value) {\n      return new Uint8Array([value >> 24, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff]);\n    }\n  }, {\n    key: 'readAsInt',\n    value: function readAsInt(arr) {\n      let temp = '';\n\n      function padStart4Hex(hexNum) {\n        let hexStr = hexNum.toString(16);\n        return hexStr.padStart(2, '0');\n      }\n\n      arr.forEach(num => {\n        temp += padStart4Hex(num);\n      });\n      return parseInt(temp, 16);\n    }\n  }]);\n\n  return Buffer;\n}();\n\nexports.default = Buffer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/write/buffer.js?")},"../xgplayer-utils/src/write/stream.js":
/*!*********************************************!*\
  !*** ../xgplayer-utils/src/write/stream.js ***!
  \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nlet Stream = function () {\n  function Stream(buffer) {\n    _classCallCheck(this, Stream);\n\n    if (buffer instanceof ArrayBuffer) {\n      this.buffer = buffer;\n      this.dataview = new DataView(buffer);\n      this.dataview.position = 0;\n    } else {\n      throw new Error('data is invalid');\n    }\n  }\n\n  _createClass(Stream, [{\n    key: 'back',\n    value: function back(count) {\n      this.position -= count;\n    }\n  }, {\n    key: 'skip',\n    value: function skip(count) {\n      let loop = Math.floor(count / 4);\n      let last = count % 4;\n      for (let i = 0; i < loop; i++) {\n        Stream.readByte(this.dataview, 4);\n      }\n      if (last > 0) {\n        Stream.readByte(this.dataview, last);\n      }\n    }\n\n    /**\n     * [readByte 从DataView中读取数据]\n     * @param  {DataView} buffer [DataView实例]\n     * @param  {Number} size   [读取字节数]\n     * @return {Number}        [整数]\n     */\n\n  }, {\n    key: 'readUint8',\n    value: function readUint8() {\n      return Stream.readByte(this.dataview, 1);\n    }\n  }, {\n    key: 'readUint16',\n    value: function readUint16() {\n      return Stream.readByte(this.dataview, 2);\n    }\n  }, {\n    key: 'readUint24',\n    value: function readUint24() {\n      return Stream.readByte(this.dataview, 3);\n    }\n  }, {\n    key: 'readUint32',\n    value: function readUint32() {\n      return Stream.readByte(this.dataview, 4);\n    }\n  }, {\n    key: 'readUint64',\n    value: function readUint64() {\n      return Stream.readByte(this.dataview, 8);\n    }\n  }, {\n    key: 'readInt8',\n    value: function readInt8() {\n      return Stream.readByte(this.dataview, 1, true);\n    }\n  }, {\n    key: 'readInt16',\n    value: function readInt16() {\n      return Stream.readByte(this.dataview, 2, true);\n    }\n  }, {\n    key: 'readInt32',\n    value: function readInt32() {\n      return Stream.readByte(this.dataview, 4, true);\n    }\n  }, {\n    key: 'writeUint32',\n    value: function writeUint32(value) {\n      return new Uint8Array([value >>> 24 & 0xff, value >>> 16 & 0xff, value >>> 8 & 0xff, value & 0xff]);\n    }\n  }, {\n    key: 'length',\n    get: function () {\n      return this.buffer.byteLength;\n    }\n  }, {\n    key: 'position',\n    set: function (value) {\n      this.dataview.position = value;\n    },\n    get: function () {\n      return this.dataview.position;\n    }\n  }], [{\n    key: 'readByte',\n    value: function readByte(buffer, size, sign) {\n      let res;\n      switch (size) {\n        case 1:\n          if (sign) {\n            res = buffer.getInt8(buffer.position);\n          } else {\n            res = buffer.getUint8(buffer.position);\n          }\n          break;\n        case 2:\n          if (sign) {\n            res = buffer.getInt16(buffer.position);\n          } else {\n            res = buffer.getUint16(buffer.position);\n          }\n          break;\n        case 3:\n          if (sign) {\n            throw new Error('not supported for readByte 3');\n          } else {\n            res = buffer.getUint8(buffer.position) << 16;\n            res |= buffer.getUint8(buffer.position + 1) << 8;\n            res |= buffer.getUint8(buffer.position + 2);\n          }\n          break;\n        case 4:\n          if (sign) {\n            res = buffer.getInt32(buffer.position);\n          } else {\n            res = buffer.getUint32(buffer.position);\n          }\n          break;\n        case 8:\n          if (sign) {\n            throw new Error('not supported for readBody 8');\n          } else {\n            res = buffer.getUint32(buffer.position) << 32;\n            res |= buffer.getUint32(buffer.position + 4);\n          }\n          break;\n        default:\n          res = '';\n      }\n      buffer.position += size;\n      return res;\n    }\n  }]);\n\n  return Stream;\n}();\n\nexports.default = Stream;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/write/stream.js?")},"./src/flv-live-mobile.js":
/*!********************************!*\
  !*** ./src/flv-live-mobile.js ***!
  \********************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _xgplayerLoader = __webpack_require__(/*! xgplayer-loader */ \"../xgplayer-loader/index.js\");\n\nvar _xgplayerDemux = __webpack_require__(/*! xgplayer-demux */ \"../xgplayer-demux/index.js\");\n\nvar _xgplayerRemux = __webpack_require__(/*! xgplayer-remux */ \"../xgplayer-remux/index.js\");\n\nvar _xgplayerBuffer = __webpack_require__(/*! xgplayer-buffer */ \"../xgplayer-buffer/index.js\");\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _xgplayerCodec = __webpack_require__(/*! xgplayer-codec */ \"../xgplayer-codec/index.js\");\n\nvar _xgplayer = __webpack_require__(/*! xgplayer */ \"xgplayer\");\n\nvar _xgplayer2 = _interopRequireDefault(_xgplayer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nconst DEMUX_EVENTS = _xgplayerUtils.EVENTS.DEMUX_EVENTS;\nconst LOADER_EVENTS = _xgplayerUtils.EVENTS.LOADER_EVENTS;\nconst BROWSER_EVENTS = _xgplayerUtils.EVENTS.BROWSER_EVENTS;\n\nconst Tag = 'FLVController';\n\nlet Logger = function () {\n  function Logger() {\n    _classCallCheck(this, Logger);\n  }\n\n  _createClass(Logger, [{\n    key: 'warn',\n    value: function warn() {}\n  }]);\n\n  return Logger;\n}();\n\nlet FlvController = function () {\n  function FlvController(player) {\n    _classCallCheck(this, FlvController);\n\n    this.TAG = Tag;\n    this._player = player;\n\n    this.video = this._player.video;\n    this.state = {\n      initSegmentArrived: false\n    };\n  }\n\n  _createClass(FlvController, [{\n    key: 'init',\n    value: function init() {\n      this._context.registry('FETCH_LOADER', _xgplayerLoader.FetchLoader);\n      this._context.registry('LOADER_BUFFER', _xgplayerBuffer.XgBuffer);\n      this._context.registry('PRE_SOURCE_BUFFER', _xgplayerBuffer.PreSource);\n\n      this._context.registry('FLV_DEMUXER', _xgplayerDemux.FlvDemuxer);\n\n      this._context.registry('MP4_REMUXER', _xgplayerRemux.Mp4Remuxer);\n      this._context.registry('TRACKS', _xgplayerBuffer.Tracks);\n\n      this._context.registry('COMPATIBILITY', _xgplayerCodec.Compatibility);\n      this._context.registry('PAGE_VISIBILITY', _xgplayerUtils.PageVisibility);\n\n      this._context.registry('LOGGER', Logger);\n\n      this.initListeners();\n    }\n  }, {\n    key: 'initListeners',\n    value: function initListeners() {\n      this.on(LOADER_EVENTS.LOADER_DATALOADED, this._handleLoaderDataLoaded.bind(this));\n      this.on(LOADER_EVENTS.LOADER_ERROR, this._handleNetworkError.bind(this));\n\n      this.on(DEMUX_EVENTS.MEDIA_INFO, this._handleMediaInfo.bind(this));\n      this.on(DEMUX_EVENTS.METADATA_PARSED, this._handleMetadataParsed.bind(this));\n      this.on(DEMUX_EVENTS.DEMUX_COMPLETE, this._handleDemuxComplete.bind(this));\n      this.on(DEMUX_EVENTS.DEMUX_ERROR, this._handleDemuxError.bind(this));\n    }\n  }, {\n    key: '_handleMediaInfo',\n    value: function _handleMediaInfo() {\n      if (!this._context.mediaInfo) {\n        this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error('failed to get mediainfo'));\n      }\n    }\n  }, {\n    key: '_handleLoaderDataLoaded',\n    value: function _handleLoaderDataLoaded() {\n      this.emitTo('FLV_DEMUXER', DEMUX_EVENTS.DEMUX_START);\n    }\n  }, {\n    key: '_handleMetadataParsed',\n    value: function _handleMetadataParsed(type) {\n      if (type === 'audio') {\n        // 将音频meta信息交给audioContext，不走remux封装\n        const { audioTrack } = this._context.getInstance('TRACKS');\n        if (audioTrack && audioTrack.meta) {\n          this._setMetaToAudio(audioTrack.meta);\n        }\n      } else {\n        const { videoTrack } = this._context.getInstance('TRACKS');\n        if (videoTrack && videoTrack.meta) {\n          this._setMetaToVideo(videoTrack.meta);\n        }\n      }\n    }\n  }, {\n    key: '_handleDemuxComplete',\n    value: function _handleDemuxComplete() {\n      if (this._player.video) {\n        const { videoTrack, audioTrack } = this._context.getInstance('TRACKS');\n        this._player.video.onDemuxComplete(videoTrack, audioTrack);\n      }\n    }\n  }, {\n    key: '_handleAppendInitSegment',\n    value: function _handleAppendInitSegment() {\n      this.state.initSegmentArrived = true;\n      //  this.mse.addSourceBuffers()\n    }\n  }, {\n    key: '_handleNetworkError',\n    value: function _handleNetworkError() {\n      this._player.emit('error', new _xgplayer2.default.Errors('network', this._player.config.url));\n    }\n  }, {\n    key: '_handleDemuxError',\n    value: function _handleDemuxError() {\n      this._player.emit('error', new _xgplayer2.default.Errors('parse', this._player.config.url));\n    }\n  }, {\n    key: '_setMetaToAudio',\n    value: function _setMetaToAudio(audioMeta) {\n      if (this._player.video) {\n        this._player.video.setAudioMeta(audioMeta);\n      }\n    }\n  }, {\n    key: '_setMetaToVideo',\n    value: function _setMetaToVideo(videoMeta) {\n      if (this._player.video) {\n        this._player.video.setVideoMeta(videoMeta);\n      }\n    }\n  }, {\n    key: 'seek',\n    value: function seek() {\n      if (!this.state.initSegmentArrived) {\n        this.loadData();\n      }\n    }\n  }, {\n    key: 'loadData',\n    value: function loadData() {\n      this.emit(LOADER_EVENTS.LADER_START, this._player.config.url);\n    }\n  }, {\n    key: 'pause',\n    value: function pause() {\n      const loader = this._context.getInstance('FETCH_LOADER');\n\n      if (loader) {\n        loader.cancel();\n      }\n    }\n\n    /**\n     * 保证当前播放的视频以gop为单位\n     * @param videoTrack\n     */\n\n  }], [{\n    key: 'resolveVideoGOP',\n    value: function resolveVideoGOP(videoTrack) {\n      const { samples } = videoTrack;\n      if (!samples.length) {\n        return;\n      }\n\n      let firstIframeIdx = null;\n      let lastIframeIdx = null;\n\n      if (videoTrack.tempSamples && videoTrack.tempSamples.length) {\n        // 将缓存帧放置到队列的头部\n        samples.unshift.apply(samples, videoTrack.tempSamples);\n      }\n\n      // 寻找第一个I帧\n      for (let i = 0, len = samples.length; i < len; i++) {\n        const current = samples[i];\n        if (current.isKeyframe) {\n          firstIframeIdx = i;\n          break;\n        }\n      }\n\n      // 寻找最后一个I帧\n      for (let i = samples.length - 1; i > 0; i++) {\n        const current = samples[i];\n\n        if (current.isKeyframe) {\n          lastIframeIdx = i;\n          break;\n        }\n      }\n\n      if (firstIframeIdx !== 0) {\n        samples.splice(0, firstIframeIdx - 1);\n      }\n\n      videoTrack.samples = samples.slice(0, lastIframeIdx);\n      const rest = samples.slice(lastIframeIdx);\n      if (videoTrack.tempSamples) {\n        videoTrack.tempSamples.push.apply(videoTrack.tempSamples, rest);\n      } else {\n        // 将剩下的帧缓存，等待一个完整的gop\n        videoTrack.tempSamples = rest;\n      }\n    }\n  }]);\n\n  return FlvController;\n}();\n\nexports.default = FlvController;\n\n//# sourceURL=webpack://xgplayer-flv/./src/flv-live-mobile.js?")},"./src/mobile.js":
/*!***********************!*\
  !*** ./src/mobile.js ***!
  \***********************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _xgplayer = __webpack_require__(/*! xgplayer */ \"xgplayer\");\n\nvar _xgplayer2 = _interopRequireDefault(_xgplayer);\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _flvLiveMobile = __webpack_require__(/*! ./flv-live-mobile */ \"./src/flv-live-mobile.js\");\n\nvar _flvLiveMobile2 = _interopRequireDefault(_flvLiveMobile);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nconst flvAllowedEvents = _xgplayerUtils.EVENTS.FlvAllowedEvents;\n\nlet FlvPlayer = function (_Player) {\n  _inherits(FlvPlayer, _Player);\n\n  function FlvPlayer(config) {\n    _classCallCheck(this, FlvPlayer);\n\n    if (!config.mediaType) {\n      config.mediaType = 'mobile-video';\n    }\n\n    var _this = _possibleConstructorReturn(this, (FlvPlayer.__proto__ || Object.getPrototypeOf(FlvPlayer)).call(this, config));\n\n    _this.video.width = Number.parseInt(config.width || 600);\n    _this.video.height = Number.parseInt(config.height || 337.5);\n    _this.video.style.outline = 'none';\n    _this.context = new _xgplayerUtils.Context(flvAllowedEvents);\n    _this.initEvents();\n    return _this;\n  }\n\n  _createClass(FlvPlayer, [{\n    key: 'start',\n    value: function start() {\n      this.initFlv();\n      this.context.init();\n      this.flv.seek(0);\n      _get(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'start', this).call(this, this.config.url);\n      this.play();\n    }\n  }, {\n    key: 'initFlvEvents',\n    value: function initFlvEvents(flv) {\n      const player = this;\n      flv.once(_xgplayerUtils.EVENTS.REMUX_EVENTS.INIT_SEGMENT, () => {\n        _xgplayer2.default.util.addClass(player.root, 'xgplayer-is-live');\n        if (!_xgplayer2.default.util.findDom(this.root, 'xg-live')) {\n          const live = _xgplayer2.default.util.createDom('xg-live', '正在直播', {}, 'xgplayer-live');\n          player.controls.appendChild(live);\n        }\n      });\n\n      flv.once(_xgplayerUtils.EVENTS.LOADER_EVENTS.LOADER_COMPLETE, () => {\n        // 直播完成，待播放器播完缓存后发送关闭事件\n        if (!player.paused) {\n          const timer = setInterval(() => {\n            const end = player.getBufferedRange()[1];\n            if (Math.abs(player.currentTime - end) < 0.5) {\n              player.emit('ended');\n              window.clearInterval(timer);\n            }\n          }, 200);\n        }\n      });\n      flv.on(_xgplayerUtils.EVENTS.BROWSER_EVENTS.VISIBILITY_CHANGE, hidden => {\n        if (hidden) {\n          this.pause();\n        }\n      });\n    }\n  }, {\n    key: 'initEvents',\n    value: function initEvents() {\n      this.on('timeupdate', () => {\n        this.loadData();\n      });\n\n      this.on('seeking', () => {\n        const time = this.currentTime;\n        const range = this.getBufferedRange();\n        if (time > range[1] || time < range[0]) {\n          this.flv.seek(this.currentTime);\n        }\n      });\n    }\n  }, {\n    key: 'initFlv',\n    value: function initFlv() {\n      const flv = this.context.registry('FLV_CONTROLLER', _flvLiveMobile2.default)(this);\n      this.initFlvEvents(flv);\n      this.flv = flv;\n    }\n  }, {\n    key: 'play',\n    value: function play() {\n      if (this._hasStart && this.paused) {\n        this._destroy();\n        this.context = new _xgplayerUtils.Context(flvAllowedEvents);\n        const flv = this.context.registry('FLV_CONTROLLER', _flvLiveMobile2.default)(this);\n        this.initFlvEvents(flv);\n        this.flv = flv;\n        this.context.init();\n        this.loadData();\n        _get(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'start', this).call(this);\n        _get(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'play', this).call(this);\n      } else {\n        _get(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'play', this).call(this);\n        this.addLiveFlag();\n      }\n    }\n  }, {\n    key: 'pause',\n    value: function pause() {\n      _get(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'pause', this).call(this);\n      if (this.flv) {\n        this.flv.pause();\n      }\n    }\n  }, {\n    key: 'loadData',\n    value: function loadData() {\n      let time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentTime;\n\n      if (this.flv) {\n        this.flv.seek(time);\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._destroy();\n      _get(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'destroy', this).call(this);\n    }\n  }, {\n    key: 'addLiveFlag',\n    value: function addLiveFlag() {\n      const player = this;\n      _xgplayer2.default.util.addClass(player.root, 'xgplayer-is-live');\n      if (!_xgplayer2.default.util.findDom(this.root, 'xg-live')) {\n        const live = _xgplayer2.default.util.createDom('xg-live', '正在直播', {}, 'xgplayer-live');\n        player.controls.appendChild(live);\n      }\n    }\n  }, {\n    key: '_destroy',\n    value: function _destroy() {\n      this.context.destroy();\n      this.flv = null;\n      this.context = null;\n    }\n  }, {\n    key: 'src',\n    get: function () {\n      return this.currentSrc;\n    },\n    set: function (url) {\n      this.player.config.url = url;\n      if (!this.paused) {\n        this.pause();\n        this.once('pause', () => {\n          this.start(url);\n        });\n        this.once('canplay', () => {\n          this.play();\n        });\n      } else {\n        this.start(url);\n      }\n      this.once('canplay', () => {\n        this.currentTime = 0;\n      });\n    }\n  }]);\n\n  return FlvPlayer;\n}(_xgplayer2.default);\n\nmodule.exports = FlvPlayer;\n\n//# sourceURL=webpack://xgplayer-flv/./src/mobile.js?")},"./src/polyfills/custom-elements.min.js":
/*!**********************************************!*\
  !*** ./src/polyfills/custom-elements.min.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\n(function () {\n  /*\n  \n   Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n  */\n  \'use strict\';\n  var n = window.Document.prototype.createElement,\n      p = window.Document.prototype.createElementNS,\n      aa = window.Document.prototype.importNode,\n      ba = window.Document.prototype.prepend,\n      ca = window.Document.prototype.append,\n      da = window.DocumentFragment.prototype.prepend,\n      ea = window.DocumentFragment.prototype.append,\n      q = window.Node.prototype.cloneNode,\n      r = window.Node.prototype.appendChild,\n      t = window.Node.prototype.insertBefore,\n      u = window.Node.prototype.removeChild,\n      v = window.Node.prototype.replaceChild,\n      x = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),\n      y = window.Element.prototype.attachShadow,\n      z = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),\n      A = window.Element.prototype.getAttribute,\n      B = window.Element.prototype.setAttribute,\n      C = window.Element.prototype.removeAttribute,\n      D = window.Element.prototype.getAttributeNS,\n      E = window.Element.prototype.setAttributeNS,\n      F = window.Element.prototype.removeAttributeNS,\n      G = window.Element.prototype.insertAdjacentElement,\n      fa = window.Element.prototype.insertAdjacentHTML,\n      ha = window.Element.prototype.prepend,\n      ia = window.Element.prototype.append,\n      ja = window.Element.prototype.before,\n      ka = window.Element.prototype.after,\n      la = window.Element.prototype.replaceWith,\n      ma = window.Element.prototype.remove,\n      na = window.HTMLElement,\n      H = Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, "innerHTML"),\n      oa = window.HTMLElement.prototype.insertAdjacentElement,\n      pa = window.HTMLElement.prototype.insertAdjacentHTML;var qa = new Set();"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" ").forEach(function (a) {\n    return qa.add(a);\n  });function ra(a) {\n    var b = qa.has(a);a = /^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(a);return !b && a;\n  }var sa = document.contains ? document.contains.bind(document) : document.documentElement.contains.bind(document.documentElement);\n  function I(a) {\n    var b = a.isConnected;if (void 0 !== b) return b;if (sa(a)) return !0;for (; a && !(a.__CE_isImportDocument || a instanceof Document);) a = a.parentNode || (window.ShadowRoot && a instanceof ShadowRoot ? a.host : void 0);return !(!a || !(a.__CE_isImportDocument || a instanceof Document));\n  }function J(a) {\n    var b = a.children;if (b) return Array.prototype.slice.call(b);b = [];for (a = a.firstChild; a; a = a.nextSibling) a.nodeType === Node.ELEMENT_NODE && b.push(a);return b;\n  }\n  function K(a, b) {\n    for (; b && b !== a && !b.nextSibling;) b = b.parentNode;return b && b !== a ? b.nextSibling : null;\n  }\n  function L(a, b, c) {\n    for (var f = a; f;) {\n      if (f.nodeType === Node.ELEMENT_NODE) {\n        var d = f;b(d);var e = d.localName;if ("link" === e && "import" === d.getAttribute("rel")) {\n          f = d.import;void 0 === c && (c = new Set());if (f instanceof Node && !c.has(f)) for (c.add(f), f = f.firstChild; f; f = f.nextSibling) L(f, b, c);f = K(a, d);continue;\n        } else if ("template" === e) {\n          f = K(a, d);continue;\n        }if (d = d.__CE_shadowRoot) for (d = d.firstChild; d; d = d.nextSibling) L(d, b, c);\n      }f = f.firstChild ? f.firstChild : K(a, f);\n    }\n  }function M(a, b, c) {\n    a[b] = c;\n  };function ta(a) {\n    var b = document;this.c = a;this.a = b;this.b = void 0;N(this.c, this.a);"loading" === this.a.readyState && (this.b = new MutationObserver(this.f.bind(this)), this.b.observe(this.a, { childList: !0, subtree: !0 }));\n  }function ua(a) {\n    a.b && a.b.disconnect();\n  }ta.prototype.f = function (a) {\n    var b = this.a.readyState;"interactive" !== b && "complete" !== b || ua(this);for (b = 0; b < a.length; b++) for (var c = a[b].addedNodes, f = 0; f < c.length; f++) N(this.c, c[f]);\n  };function va() {\n    var a = this;this.b = this.a = void 0;this.c = new Promise(function (b) {\n      a.b = b;a.a && b(a.a);\n    });\n  }function wa(a) {\n    if (a.a) throw Error("Already resolved.");a.a = void 0;a.b && a.b(void 0);\n  };function O(a) {\n    this.f = new Map();this.g = new Map();this.l = new Map();this.i = !1;this.b = a;this.j = new Map();this.c = function (b) {\n      return b();\n    };this.a = !1;this.h = [];this.m = a.f ? new ta(a) : void 0;\n  }O.prototype.o = function (a, b) {\n    var c = this;if (!(b instanceof Function)) throw new TypeError("Custom element constructor getters must be functions.");xa(this, a);this.f.set(a, b);this.h.push(a);this.a || (this.a = !0, this.c(function () {\n      return ya(c);\n    }));\n  };\n  O.prototype.define = function (a, b) {\n    var c = this;if (!(b instanceof Function)) throw new TypeError("Custom element constructors must be functions.");xa(this, a);za(this, a, b);this.h.push(a);this.a || (this.a = !0, this.c(function () {\n      return ya(c);\n    }));\n  };function xa(a, b) {\n    if (!ra(b)) throw new SyntaxError("The element name \'" + b + "\' is not valid.");if (P(a, b)) throw Error("A custom element with name \'" + b + "\' has already been defined.");if (a.i) throw Error("A custom element is already being defined.");\n  }\n  function za(a, b, c) {\n    a.i = !0;var f;try {\n      var d = function (m) {\n        var w = e[m];if (void 0 !== w && !(w instanceof Function)) throw Error("The \'" + m + "\' callback must be a function.");return w;\n      },\n          e = c.prototype;if (!(e instanceof Object)) throw new TypeError("The custom element constructor\'s prototype is not an object.");var g = d("connectedCallback");var h = d("disconnectedCallback");var k = d("adoptedCallback");var l = (f = d("attributeChangedCallback")) && c.observedAttributes || [];\n    } catch (m) {\n      throw m;\n    } finally {\n      a.i = !1;\n    }c = { localName: b, constructorFunction: c,\n      connectedCallback: g, disconnectedCallback: h, adoptedCallback: k, attributeChangedCallback: f, observedAttributes: l, constructionStack: [] };a.g.set(b, c);a.l.set(c.constructorFunction, c);return c;\n  }O.prototype.upgrade = function (a) {\n    N(this.b, a);\n  };\n  function ya(a) {\n    if (!1 !== a.a) {\n      a.a = !1;for (var b = [], c = a.h, f = new Map(), d = 0; d < c.length; d++) f.set(c[d], []);N(a.b, document, { upgrade: function (k) {\n          if (void 0 === k.__CE_state) {\n            var l = k.localName,\n                m = f.get(l);m ? m.push(k) : a.g.has(l) && b.push(k);\n          }\n        } });for (d = 0; d < b.length; d++) Q(a.b, b[d]);for (d = 0; d < c.length; d++) {\n        for (var e = c[d], g = f.get(e), h = 0; h < g.length; h++) Q(a.b, g[h]);(e = a.j.get(e)) && wa(e);\n      }c.length = 0;\n    }\n  }O.prototype.get = function (a) {\n    if (a = P(this, a)) return a.constructorFunction;\n  };\n  O.prototype.whenDefined = function (a) {\n    if (!ra(a)) return Promise.reject(new SyntaxError("\'" + a + "\' is not a valid custom element name."));var b = this.j.get(a);if (b) return b.c;b = new va();this.j.set(a, b);var c = this.g.has(a) || this.f.has(a);a = -1 === this.h.indexOf(a);c && a && wa(b);return b.c;\n  };O.prototype.polyfillWrapFlushCallback = function (a) {\n    this.m && ua(this.m);var b = this.c;this.c = function (c) {\n      return a(function () {\n        return b(c);\n      });\n    };\n  };\n  function P(a, b) {\n    var c = a.g.get(b);if (c) return c;if (c = a.f.get(b)) {\n      a.f.delete(b);try {\n        return za(a, b, c());\n      } catch (f) {\n        R(f);\n      }\n    }\n  }window.CustomElementRegistry = O;O.prototype.define = O.prototype.define;O.prototype.upgrade = O.prototype.upgrade;O.prototype.get = O.prototype.get;O.prototype.whenDefined = O.prototype.whenDefined;O.prototype.polyfillDefineLazy = O.prototype.o;O.prototype.polyfillWrapFlushCallback = O.prototype.polyfillWrapFlushCallback;function S() {\n    var a = T && T.noDocumentConstructionObserver,\n        b = T && T.shadyDomFastWalk;this.b = [];this.c = [];this.a = !1;this.shadyDomFastWalk = b;this.f = !a;\n  }function U(a, b, c, f) {\n    var d = window.ShadyDOM;if (a.shadyDomFastWalk && d && d.inUse) {\n      if (b.nodeType === Node.ELEMENT_NODE && c(b), b.querySelectorAll) for (a = d.nativeMethods.querySelectorAll.call(b, "*"), b = 0; b < a.length; b++) c(a[b]);\n    } else L(b, c, f);\n  }function Aa(a, b) {\n    a.a = !0;a.b.push(b);\n  }function Ba(a, b) {\n    a.a = !0;a.c.push(b);\n  }function V(a, b) {\n    a.a && U(a, b, function (c) {\n      return W(a, c);\n    });\n  }\n  function W(a, b) {\n    if (a.a && !b.__CE_patched) {\n      b.__CE_patched = !0;for (var c = 0; c < a.b.length; c++) a.b[c](b);for (c = 0; c < a.c.length; c++) a.c[c](b);\n    }\n  }function X(a, b) {\n    var c = [];U(a, b, function (d) {\n      return c.push(d);\n    });for (b = 0; b < c.length; b++) {\n      var f = c[b];1 === f.__CE_state ? a.connectedCallback(f) : Q(a, f);\n    }\n  }function Y(a, b) {\n    var c = [];U(a, b, function (d) {\n      return c.push(d);\n    });for (b = 0; b < c.length; b++) {\n      var f = c[b];1 === f.__CE_state && a.disconnectedCallback(f);\n    }\n  }\n  function N(a, b, c) {\n    c = void 0 === c ? {} : c;var f = c.s,\n        d = c.upgrade || function (g) {\n      return Q(a, g);\n    },\n        e = [];U(a, b, function (g) {\n      a.a && W(a, g);if ("link" === g.localName && "import" === g.getAttribute("rel")) {\n        var h = g.import;h instanceof Node && (h.__CE_isImportDocument = !0, h.__CE_registry = document.__CE_registry);h && "complete" === h.readyState ? h.__CE_documentLoadHandled = !0 : g.addEventListener("load", function () {\n          var k = g.import;if (!k.__CE_documentLoadHandled) {\n            k.__CE_documentLoadHandled = !0;var l = new Set();f && (f.forEach(function (m) {\n              return l.add(m);\n            }), l.delete(k));N(a, k, { s: l, upgrade: d });\n          }\n        });\n      } else e.push(g);\n    }, f);for (b = 0; b < e.length; b++) d(e[b]);\n  }\n  function Q(a, b) {\n    try {\n      var c = b.ownerDocument,\n          f = c.__CE_registry;var d = f && (c.defaultView || c.__CE_isImportDocument) ? P(f, b.localName) : void 0;if (d && void 0 === b.__CE_state) {\n        d.constructionStack.push(b);try {\n          try {\n            if (new d.constructorFunction() !== b) throw Error("The custom element constructor did not produce the element being upgraded.");\n          } finally {\n            d.constructionStack.pop();\n          }\n        } catch (k) {\n          throw b.__CE_state = 2, k;\n        }b.__CE_state = 1;b.__CE_definition = d;if (d.attributeChangedCallback && b.hasAttributes()) {\n          var e = d.observedAttributes;\n          for (d = 0; d < e.length; d++) {\n            var g = e[d],\n                h = b.getAttribute(g);null !== h && a.attributeChangedCallback(b, g, null, h, null);\n          }\n        }I(b) && a.connectedCallback(b);\n      }\n    } catch (k) {\n      R(k);\n    }\n  }S.prototype.connectedCallback = function (a) {\n    var b = a.__CE_definition;if (b.connectedCallback) try {\n      b.connectedCallback.call(a);\n    } catch (c) {\n      R(c);\n    }\n  };S.prototype.disconnectedCallback = function (a) {\n    var b = a.__CE_definition;if (b.disconnectedCallback) try {\n      b.disconnectedCallback.call(a);\n    } catch (c) {\n      R(c);\n    }\n  };\n  S.prototype.attributeChangedCallback = function (a, b, c, f, d) {\n    var e = a.__CE_definition;if (e.attributeChangedCallback && -1 < e.observedAttributes.indexOf(b)) try {\n      e.attributeChangedCallback.call(a, b, c, f, d);\n    } catch (g) {\n      R(g);\n    }\n  };\n  function Ca(a, b, c, f) {\n    var d = b.__CE_registry;if (d && (null === f || "http://www.w3.org/1999/xhtml" === f) && (d = P(d, c))) try {\n      var e = new d.constructorFunction();if (void 0 === e.__CE_state || void 0 === e.__CE_definition) throw Error("Failed to construct \'" + c + "\': The returned value was not constructed with the HTMLElement constructor.");if ("http://www.w3.org/1999/xhtml" !== e.namespaceURI) throw Error("Failed to construct \'" + c + "\': The constructed element\'s namespace must be the HTML namespace.");if (e.hasAttributes()) throw Error("Failed to construct \'" + c + "\': The constructed element must not have any attributes.");if (null !== e.firstChild) throw Error("Failed to construct \'" + c + "\': The constructed element must not have any children.");if (null !== e.parentNode) throw Error("Failed to construct \'" + c + "\': The constructed element must not have a parent node.");if (e.ownerDocument !== b) throw Error("Failed to construct \'" + c + "\': The constructed element\'s owner document is incorrect.");if (e.localName !== c) throw Error("Failed to construct \'" + c + "\': The constructed element\'s local name is incorrect.");\n      return e;\n    } catch (g) {\n      return R(g), b = null === f ? n.call(b, c) : p.call(b, f, c), Object.setPrototypeOf(b, HTMLUnknownElement.prototype), b.__CE_state = 2, b.__CE_definition = void 0, W(a, b), b;\n    }b = null === f ? n.call(b, c) : p.call(b, f, c);W(a, b);return b;\n  }\n  function R(a) {\n    var b = a.message,\n        c = a.sourceURL || a.fileName || "",\n        f = a.line || a.lineNumber || 0,\n        d = a.column || a.columnNumber || 0,\n        e = void 0;void 0 === ErrorEvent.prototype.initErrorEvent ? e = new ErrorEvent("error", { cancelable: !0, message: b, filename: c, lineno: f, colno: d, error: a }) : (e = document.createEvent("ErrorEvent"), e.initErrorEvent("error", !1, !0, b, c, f), e.preventDefault = function () {\n      Object.defineProperty(this, "defaultPrevented", { configurable: !0, get: function () {\n          return !0;\n        } });\n    });void 0 === e.error && Object.defineProperty(e, "error", { configurable: !0, enumerable: !0, get: function () {\n        return a;\n      } });window.dispatchEvent(e);e.defaultPrevented || console.error(a);\n  };var Da = new function () {}();function Ea(a) {\n    window.HTMLElement = function () {\n      function b() {\n        var c = this.constructor;var f = document.__CE_registry.l.get(c);if (!f) throw Error("Failed to construct a custom element: The constructor was not registered with `customElements`.");var d = f.constructionStack;if (0 === d.length) return d = n.call(document, f.localName), Object.setPrototypeOf(d, c.prototype), d.__CE_state = 1, d.__CE_definition = f, W(a, d), d;var e = d.length - 1,\n            g = d[e];if (g === Da) throw Error("Failed to construct \'" + f.localName + "\': This element was already constructed.");\n        d[e] = Da;Object.setPrototypeOf(g, c.prototype);W(a, g);return g;\n      }b.prototype = na.prototype;Object.defineProperty(b.prototype, "constructor", { writable: !0, configurable: !0, enumerable: !1, value: b });return b;\n    }();\n  };function Z(a, b, c) {\n    function f(d) {\n      return function (e) {\n        for (var g = [], h = 0; h < arguments.length; ++h) g[h] = arguments[h];h = [];for (var k = [], l = 0; l < g.length; l++) {\n          var m = g[l];m instanceof Element && I(m) && k.push(m);if (m instanceof DocumentFragment) for (m = m.firstChild; m; m = m.nextSibling) h.push(m);else h.push(m);\n        }d.apply(this, g);for (g = 0; g < k.length; g++) Y(a, k[g]);if (I(this)) for (g = 0; g < h.length; g++) k = h[g], k instanceof Element && X(a, k);\n      };\n    }void 0 !== c.prepend && M(b, "prepend", f(c.prepend));void 0 !== c.append && M(b, "append", f(c.append));\n  }\n  ;function Fa(a) {\n    M(Document.prototype, "createElement", function (b) {\n      return Ca(a, this, b, null);\n    });M(Document.prototype, "importNode", function (b, c) {\n      b = aa.call(this, b, !!c);this.__CE_registry ? N(a, b) : V(a, b);return b;\n    });M(Document.prototype, "createElementNS", function (b, c) {\n      return Ca(a, this, c, b);\n    });Z(a, Document.prototype, { prepend: ba, append: ca });\n  };function Ga(a) {\n    function b(c, f) {\n      Object.defineProperty(c, "textContent", { enumerable: f.enumerable, configurable: !0, get: f.get, set: function (d) {\n          if (this.nodeType === Node.TEXT_NODE) f.set.call(this, d);else {\n            var e = void 0;if (this.firstChild) {\n              var g = this.childNodes,\n                  h = g.length;if (0 < h && I(this)) {\n                e = Array(h);for (var k = 0; k < h; k++) e[k] = g[k];\n              }\n            }f.set.call(this, d);if (e) for (d = 0; d < e.length; d++) Y(a, e[d]);\n          }\n        } });\n    }M(Node.prototype, "insertBefore", function (c, f) {\n      if (c instanceof DocumentFragment) {\n        var d = J(c);c = t.call(this, c, f);if (I(this)) for (f = 0; f < d.length; f++) X(a, d[f]);return c;\n      }d = c instanceof Element && I(c);f = t.call(this, c, f);d && Y(a, c);I(this) && X(a, c);return f;\n    });M(Node.prototype, "appendChild", function (c) {\n      if (c instanceof DocumentFragment) {\n        var f = J(c);c = r.call(this, c);if (I(this)) for (var d = 0; d < f.length; d++) X(a, f[d]);return c;\n      }f = c instanceof Element && I(c);d = r.call(this, c);f && Y(a, c);I(this) && X(a, c);return d;\n    });M(Node.prototype, "cloneNode", function (c) {\n      c = q.call(this, !!c);this.ownerDocument.__CE_registry ? N(a, c) : V(a, c);return c;\n    });M(Node.prototype, "removeChild", function (c) {\n      var f = c instanceof Element && I(c),\n          d = u.call(this, c);f && Y(a, c);return d;\n    });M(Node.prototype, "replaceChild", function (c, f) {\n      if (c instanceof DocumentFragment) {\n        var d = J(c);c = v.call(this, c, f);if (I(this)) for (Y(a, f), f = 0; f < d.length; f++) X(a, d[f]);return c;\n      }d = c instanceof Element && I(c);var e = v.call(this, c, f),\n          g = I(this);g && Y(a, f);d && Y(a, c);g && X(a, c);return e;\n    });x && x.get ? b(Node.prototype, x) : Aa(a, function (c) {\n      b(c, { enumerable: !0, configurable: !0, get: function () {\n          for (var f = [], d = this.firstChild; d; d = d.nextSibling) d.nodeType !== Node.COMMENT_NODE && f.push(d.textContent);return f.join("");\n        }, set: function (f) {\n          for (; this.firstChild;) u.call(this, this.firstChild);null != f && "" !== f && r.call(this, document.createTextNode(f));\n        } });\n    });\n  };function Ha(a) {\n    function b(f) {\n      return function (d) {\n        for (var e = [], g = 0; g < arguments.length; ++g) e[g] = arguments[g];g = [];for (var h = [], k = 0; k < e.length; k++) {\n          var l = e[k];l instanceof Element && I(l) && h.push(l);if (l instanceof DocumentFragment) for (l = l.firstChild; l; l = l.nextSibling) g.push(l);else g.push(l);\n        }f.apply(this, e);for (e = 0; e < h.length; e++) Y(a, h[e]);if (I(this)) for (e = 0; e < g.length; e++) h = g[e], h instanceof Element && X(a, h);\n      };\n    }var c = Element.prototype;void 0 !== ja && M(c, "before", b(ja));void 0 !== ka && M(c, "after", b(ka));void 0 !== la && M(c, "replaceWith", function (f) {\n      for (var d = [], e = 0; e < arguments.length; ++e) d[e] = arguments[e];e = [];for (var g = [], h = 0; h < d.length; h++) {\n        var k = d[h];k instanceof Element && I(k) && g.push(k);if (k instanceof DocumentFragment) for (k = k.firstChild; k; k = k.nextSibling) e.push(k);else e.push(k);\n      }h = I(this);la.apply(this, d);for (d = 0; d < g.length; d++) Y(a, g[d]);if (h) for (Y(a, this), d = 0; d < e.length; d++) g = e[d], g instanceof Element && X(a, g);\n    });void 0 !== ma && M(c, "remove", function () {\n      var f = I(this);ma.call(this);f && Y(a, this);\n    });\n  };function Ia(a) {\n    function b(d, e) {\n      Object.defineProperty(d, "innerHTML", { enumerable: e.enumerable, configurable: !0, get: e.get, set: function (g) {\n          var h = this,\n              k = void 0;I(this) && (k = [], U(a, this, function (w) {\n            w !== h && k.push(w);\n          }));e.set.call(this, g);if (k) for (var l = 0; l < k.length; l++) {\n            var m = k[l];1 === m.__CE_state && a.disconnectedCallback(m);\n          }this.ownerDocument.__CE_registry ? N(a, this) : V(a, this);return g;\n        } });\n    }function c(d, e) {\n      M(d, "insertAdjacentElement", function (g, h) {\n        var k = I(h);g = e.call(this, g, h);k && Y(a, h);I(g) && X(a, h);return g;\n      });\n    }\n    function f(d, e) {\n      function g(h, k) {\n        for (var l = []; h !== k; h = h.nextSibling) l.push(h);for (k = 0; k < l.length; k++) N(a, l[k]);\n      }M(d, "insertAdjacentHTML", function (h, k) {\n        h = h.toLowerCase();if ("beforebegin" === h) {\n          var l = this.previousSibling;e.call(this, h, k);g(l || this.parentNode.firstChild, this);\n        } else if ("afterbegin" === h) l = this.firstChild, e.call(this, h, k), g(this.firstChild, l);else if ("beforeend" === h) l = this.lastChild, e.call(this, h, k), g(l || this.firstChild, null);else if ("afterend" === h) l = this.nextSibling, e.call(this, h, k), g(this.nextSibling, l);else throw new SyntaxError("The value provided (" + String(h) + ") is not one of \'beforebegin\', \'afterbegin\', \'beforeend\', or \'afterend\'.");\n      });\n    }y && M(Element.prototype, "attachShadow", function (d) {\n      d = y.call(this, d);if (a.a && !d.__CE_patched) {\n        d.__CE_patched = !0;for (var e = 0; e < a.b.length; e++) a.b[e](d);\n      }return this.__CE_shadowRoot = d;\n    });z && z.get ? b(Element.prototype, z) : H && H.get ? b(HTMLElement.prototype, H) : Ba(a, function (d) {\n      b(d, { enumerable: !0, configurable: !0, get: function () {\n          return q.call(this, !0).innerHTML;\n        }, set: function (e) {\n          var g = "template" === this.localName,\n              h = g ? this.content : this,\n              k = p.call(document, this.namespaceURI, this.localName);for (k.innerHTML = e; 0 < h.childNodes.length;) u.call(h, h.childNodes[0]);for (e = g ? k.content : k; 0 < e.childNodes.length;) r.call(h, e.childNodes[0]);\n        } });\n    });M(Element.prototype, "setAttribute", function (d, e) {\n      if (1 !== this.__CE_state) return B.call(this, d, e);var g = A.call(this, d);B.call(this, d, e);e = A.call(this, d);a.attributeChangedCallback(this, d, g, e, null);\n    });M(Element.prototype, "setAttributeNS", function (d, e, g) {\n      if (1 !== this.__CE_state) return E.call(this, d, e, g);var h = D.call(this, d, e);E.call(this, d, e, g);g = D.call(this, d, e);a.attributeChangedCallback(this, e, h, g, d);\n    });M(Element.prototype, "removeAttribute", function (d) {\n      if (1 !== this.__CE_state) return C.call(this, d);var e = A.call(this, d);C.call(this, d);null !== e && a.attributeChangedCallback(this, d, e, null, null);\n    });M(Element.prototype, "removeAttributeNS", function (d, e) {\n      if (1 !== this.__CE_state) return F.call(this, d, e);var g = D.call(this, d, e);F.call(this, d, e);var h = D.call(this, d, e);g !== h && a.attributeChangedCallback(this, e, g, h, d);\n    });oa ? c(HTMLElement.prototype, oa) : G ? c(Element.prototype, G) : console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");pa ? f(HTMLElement.prototype, pa) : fa ? f(Element.prototype, fa) : console.warn("Custom Elements: `Element#insertAdjacentHTML` was not patched.");Z(a, Element.prototype, { prepend: ha, append: ia });Ha(a);\n  };var T = window.customElements;function Ja() {\n    var a = new S();Ea(a);Fa(a);Z(a, DocumentFragment.prototype, { prepend: da, append: ea });Ga(a);Ia(a);a = new O(a);document.__CE_registry = a;Object.defineProperty(window, "customElements", { configurable: !0, enumerable: !0, value: a });\n  }T && !T.forcePolyfill && "function" == typeof T.define && "function" == typeof T.get || Ja();window.__CE_installPolyfill = Ja;\n}).call(self);\n\n//# sourceMappingURL=custom-elements.min.js.map\n\n//# sourceURL=webpack://xgplayer-flv/./src/polyfills/custom-elements.min.js?')},"./src/polyfills/native-element.js":
/*!*****************************************!*\
  !*** ./src/polyfills/native-element.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This shim allows elements written in, or compiled to, ES5 to work on native\n * implementations of Custom Elements v1. It sets new.target to the value of\n * this.constructor so that the native HTMLElement constructor can access the\n * current under-construction element's definition.\n */\n(function () {\n  if (\n  // No Reflect, no classes, no need for shim because native custom elements\n  // require ES2015 classes or Reflect.\n  window.Reflect === undefined || window.customElements === undefined ||\n  // The webcomponentsjs custom elements polyfill doesn't require\n  // ES2015-compatible construction (`super()` or `Reflect.construct`).\n  window.customElements.polyfillWrapFlushCallback) {\n    return;\n  }\n  const BuiltInHTMLElement = HTMLElement;\n  /**\n   * With jscompiler's RECOMMENDED_FLAGS the function name will be optimized away.\n   * However, if we declare the function as a property on an object literal, and\n   * use quotes for the property name, then closure will leave that much intact,\n   * which is enough for the JS VM to correctly set Function.prototype.name.\n   */\n  const wrapperForTheName = {\n    'HTMLElement': /** @this {!Object} */function HTMLElement() {\n      return Reflect.construct(BuiltInHTMLElement, [], /** @type {!Function} */this.constructor);\n    }\n  };\n  window.HTMLElement = wrapperForTheName['HTMLElement'];\n  HTMLElement.prototype = BuiltInHTMLElement.prototype;\n  HTMLElement.prototype.constructor = HTMLElement;\n  Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);\n})();\n\n//# sourceURL=webpack://xgplayer-flv/./src/polyfills/native-element.js?")},1:
/*!******************************************************************************************************!*\
  !*** multi ./src/polyfills/custom-elements.min.js ./src/polyfills/native-element.js ./src/mobile.js ***!
  \******************************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('__webpack_require__(/*! ./src/polyfills/custom-elements.min.js */"./src/polyfills/custom-elements.min.js");\n__webpack_require__(/*! ./src/polyfills/native-element.js */"./src/polyfills/native-element.js");\nmodule.exports = __webpack_require__(/*! ./src/mobile.js */"./src/mobile.js");\n\n\n//# sourceURL=webpack://xgplayer-flv/multi_./src/polyfills/custom-elements.min.js_./src/polyfills/native-element.js_./src/mobile.js?')},xgplayer:
/*!***************************!*\
  !*** external "xgplayer" ***!
  \***************************/
/*! no static exports found */function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_xgplayer__;\n\n//# sourceURL=webpack://xgplayer-flv/external_%22xgplayer%22?")}})}));
=======
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("xgplayer")):"function"==typeof define&&define.amd?define(["xgplayer"],t):"object"==typeof exports?exports["xgplayer-flv"]=t(require("xgplayer")):e["xgplayer-flv"]=t(e.xgplayer)}(window,(function(e){return function(e){var t={};function i(n){if(t[n])return t[n].exports;var r=t[n]={i:n,l:!1,exports:{}};return e[n].call(r.exports,r,r.exports,i),r.l=!0,r.exports}return i.m=e,i.c=t,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)i.d(n,r,function(t){return e[t]}.bind(null,r));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=55)}([function(e,t,i){"use strict";e.exports={Context:i(14).default,EVENTS:i(2).default,WORKER_COMMANDS:i(15).default,sniffer:i(16).default,isLe:i(17).default,UTF8:i(18).default,PageVisibility:i(19).default,MediaInfo:i(6).default,MediaSample:i(20).default,MediaSegment:i(21).default,MediaSegmentList:i(22).default,AudioTrackMeta:i(8).AudioTrackMeta,VideoTrackMeta:i(8).VideoTrackMeta,AudioTrackSample:i(9).AudioTrackSample,VideoTrackSample:i(9).VideoTrackSample,Mse:i(23).default,Stream:i(10).default,Buffer:i(24).default,MobileVideo:i(27),Crypto:i(37).default}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}let s=function(){function e(){o(this,e),this.id=-1,this.sequenceNumber=0,this.samples=[],this.droppedSamples=[],this.length=0}return n(e,[{key:"reset",value:function(){this.sequenceNumber=0,this.samples=[],this.length=0}},{key:"distroy",value:function(){this.reset(),this.id=-1}}]),e}();t.default=s;t.AudioTrack=function(e){function t(){o(this,t);var e=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return e.TAG="AudioTrack",e.type="audio",e}return a(t,e),t}(s),t.VideoTrack=function(e){function t(){o(this,t);var e=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return e.TAG="VideoTrack",e.type="video",e.dropped=0,e}return a(t,e),n(t,[{key:"reset",value:function(){this.sequenceNumber=0,this.samples=[],this.length=0,this.dropped=0}}]),t}(s),t.Tracks=function(){function e(){o(this,e),this.audioTrack=null,this.videoTrack=null}return n(e,[{key:"destroy",value:function(){this.audioTrack=null,this.videoTrack=null}}]),e}()},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n={LADER_START:"LOADER_START",LOADER_DATALOADED:"LOADER_DATALOADED",LOADER_COMPLETE:"LOADER_COMPLETE",LOADER_ERROR:"LOADER_ERROR"},r={DEMUX_START:"DEMUX_START",DEMUX_COMPLETE:"DEMUX_COMPLETE",DEMUX_ERROR:"DEMUX_ERROR",METADATA_PARSED:"METADATA_PARSED",VIDEO_METADATA_CHANGE:"VIDEO_METADATA_CHANGE",AUDIO_METADATA_CHANGE:"AUDIO_METADATA_CHANGE",MEDIA_INFO:"MEDIA_INFO"},a={REMUX_METADATA:"REMUX_METADATA",REMUX_MEDIA:"REMUX_MEDIA",MEDIA_SEGMENT:"MEDIA_SEGMENT",REMUX_ERROR:"REMUX_ERROR",INIT_SEGMENT:"INIT_SEGMENT",DETECT_CHANGE_STREAM:"DETECT_CHANGE_STREAM"},o={SOURCE_UPDATE_END:"SOURCE_UPDATE_END"},s={RETRY_TIME_EXCEEDED:"RETRY_TIME_EXCEEDED"},u={VISIBILITY_CHANGE:"VISIBILITY_CHANGE"},l=Object.assign({},n,r,a,o,s,u),c=[],f=[];for(let e in l)l.hasOwnProperty(e)&&c.push(l[e]);for(let e in l)l.hasOwnProperty(e)&&f.push(l[e]);t.default={ALLEVENTS:l,HLS_EVENTS:s,REMUX_EVENTS:a,DEMUX_EVENTS:r,MSE_EVENTS:o,LOADER_EVENTS:n,FlvAllowedEvents:c,HlsAllowedEvents:f,CRYTO_EVENTS:{START_DECRYPT:"START_DECRYPT",DECRYPTED:"DECRYPTED"},BROWSER_EVENTS:u}},function(e,t,i){"use strict";e.exports={Nalunit:i(11).default,SpsParser:i(12).default,Compatibility:i(46).default}},function(e,t,i){"use strict";e.exports={Track:i(1).default,Tracks:i(1).Tracks,AudioTrack:i(1).AudioTrack,VideoTrack:i(1).VideoTrack,XgBuffer:i(13).XgBuffer,RemuxBuffer:i(13).RemuxBuffer,PreSource:i(48).default}},function(t,i){t.exports=e},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();const r=e=>{for(let t in e)if(e.hasOwnProperty(t)&&null===e[t])return!1;return!0};let a=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.mimeType=null,this.duration=null,this.hasVideo=null,this.video={codec:null,width:null,height:null,profile:null,level:null,frameRate:{fixed:!0,fps:25,fps_num:25e3,fps_den:1e3},chromaFormat:null,parRatio:{width:1,height:1}},this.hasAudio=null,this.audio={codec:null,sampleRate:null,sampleRateIndex:null,channelCount:null}}return n(e,[{key:"isComplete",value:function(){return e.isBaseInfoReady(this)&&e.isVideoReady(this)&&e.isAudioReady(this)}}],[{key:"isBaseInfoReady",value:function(e){return r(e)}},{key:"isVideoReady",value:function(e){return!e.hasVideo||r(e.video)}},{key:"isAudioReady",value:function(e){return!e.hasAudio||r(e.video)}}]),e}();t.default=a},function(e,t,i){"use strict";var n,r="object"==typeof Reflect?Reflect:null,a=r&&"function"==typeof r.apply?r.apply:function(e,t,i){return Function.prototype.apply.call(e,t,i)};n=r&&"function"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var o=Number.isNaN||function(e){return e!=e};function s(){s.init.call(this)}e.exports=s,s.EventEmitter=s,s.prototype._events=void 0,s.prototype._eventsCount=0,s.prototype._maxListeners=void 0;var u=10;function l(e){return void 0===e._maxListeners?s.defaultMaxListeners:e._maxListeners}function c(e,t,i,n){var r,a,o,s;if("function"!=typeof i)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof i);if(void 0===(a=e._events)?(a=e._events=Object.create(null),e._eventsCount=0):(void 0!==a.newListener&&(e.emit("newListener",t,i.listener?i.listener:i),a=e._events),o=a[t]),void 0===o)o=a[t]=i,++e._eventsCount;else if("function"==typeof o?o=a[t]=n?[i,o]:[o,i]:n?o.unshift(i):o.push(i),(r=l(e))>0&&o.length>r&&!o.warned){o.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=e,u.type=t,u.count=o.length,s=u,console&&console.warn&&console.warn(s)}return e}function f(){for(var e=[],t=0;t<arguments.length;t++)e.push(arguments[t]);this.fired||(this.target.removeListener(this.type,this.wrapFn),this.fired=!0,a(this.listener,this.target,e))}function h(e,t,i){var n={fired:!1,wrapFn:void 0,target:e,type:t,listener:i},r=f.bind(n);return r.listener=i,n.wrapFn=r,r}function d(e,t,i){var n=e._events;if(void 0===n)return[];var r=n[t];return void 0===r?[]:"function"==typeof r?i?[r.listener||r]:[r]:i?function(e){for(var t=new Array(e.length),i=0;i<t.length;++i)t[i]=e[i].listener||e[i];return t}(r):y(r,r.length)}function p(e){var t=this._events;if(void 0!==t){var i=t[e];if("function"==typeof i)return 1;if(void 0!==i)return i.length}return 0}function y(e,t){for(var i=new Array(t),n=0;n<t;++n)i[n]=e[n];return i}Object.defineProperty(s,"defaultMaxListeners",{enumerable:!0,get:function(){return u},set:function(e){if("number"!=typeof e||e<0||o(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");u=e}}),s.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},s.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||o(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},s.prototype.getMaxListeners=function(){return l(this)},s.prototype.emit=function(e){for(var t=[],i=1;i<arguments.length;i++)t.push(arguments[i]);var n="error"===e,r=this._events;if(void 0!==r)n=n&&void 0===r.error;else if(!n)return!1;if(n){var o;if(t.length>0&&(o=t[0]),o instanceof Error)throw o;var s=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw s.context=o,s}var u=r[e];if(void 0===u)return!1;if("function"==typeof u)a(u,this,t);else{var l=u.length,c=y(u,l);for(i=0;i<l;++i)a(c[i],this,t)}return!0},s.prototype.addListener=function(e,t){return c(this,e,t,!1)},s.prototype.on=s.prototype.addListener,s.prototype.prependListener=function(e,t){return c(this,e,t,!0)},s.prototype.once=function(e,t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t);return this.on(e,h(this,e,t)),this},s.prototype.prependOnceListener=function(e,t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t);return this.prependListener(e,h(this,e,t)),this},s.prototype.removeListener=function(e,t){var i,n,r,a,o;if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t);if(void 0===(n=this._events))return this;if(void 0===(i=n[e]))return this;if(i===t||i.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete n[e],n.removeListener&&this.emit("removeListener",e,i.listener||t));else if("function"!=typeof i){for(r=-1,a=i.length-1;a>=0;a--)if(i[a]===t||i[a].listener===t){o=i[a].listener,r=a;break}if(r<0)return this;0===r?i.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(i,r),1===i.length&&(n[e]=i[0]),void 0!==n.removeListener&&this.emit("removeListener",e,o||t)}return this},s.prototype.off=s.prototype.removeListener,s.prototype.removeAllListeners=function(e){var t,i,n;if(void 0===(i=this._events))return this;if(void 0===i.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==i[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete i[e]),this;if(0===arguments.length){var r,a=Object.keys(i);for(n=0;n<a.length;++n)"removeListener"!==(r=a[n])&&this.removeAllListeners(r);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=i[e]))this.removeListener(e,t);else if(void 0!==t)for(n=t.length-1;n>=0;n--)this.removeListener(e,t[n]);return this},s.prototype.listeners=function(e){return d(this,e,!0)},s.prototype.rawListeners=function(e){return d(this,e,!1)},s.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):p.call(e,t)},s.prototype.listenerCount=p,s.prototype.eventNames=function(){return this._eventsCount>0?n(this._events):[]}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.AudioTrackMeta=function(){function e(t){r(this,e);const i={sampleRate:48e3,channelCount:2,codec:"mp4a.40.2",config:[41,401,136,0],duration:0,id:2,refSampleDuration:21,sampleRateIndex:3,timescale:1e3,type:"audio"};return t?Object.assign({},i,t):i}return n(e,[{key:"destroy",value:function(){this.init=null}}]),e}(),t.VideoTrackMeta=function(){function e(t){r(this,e);const i={avcc:null,sps:new Uint8Array(0),pps:new Uint8Array(0),chromaFormat:420,codec:"avc1.640020",codecHeight:720,codecWidth:1280,duration:0,frameRate:{fixed:!0,fps:25,fps_num:25e3,fps_den:1e3},id:1,level:"3.2",presentHeight:720,presentWidth:1280,profile:"High",refSampleDuration:40,parRatio:{height:1,width:1},timescale:1e3,type:"video"};return t?Object.assign({},i,t):i}return n(e,[{key:"destroy",value:function(){this.init=null,this.sps=null,this.pps=null}}]),e}()},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.AudioTrackSample=function(){function e(t){r(this,e);let i=e.getDefault();return t?Object.assign({},i,t):i}return n(e,null,[{key:"getDefault",value:function(){return{dts:null,pts:null,data:new Uint8Array}}}]),e}(),t.VideoTrackSample=function(){function e(t){r(this,e);let i=e.getDefault();return t?Object.assign({},i,t):i}return n(e,null,[{key:"getDefault",value:function(){return{dts:null,pts:null,isKeyframe:!1,originDts:null,data:new Uint8Array}}}]),e}()},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(t){if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),!(t instanceof ArrayBuffer))throw new Error("data is invalid");this.buffer=t,this.dataview=new DataView(t),this.dataview.position=0}return n(e,[{key:"back",value:function(e){this.position-=e}},{key:"skip",value:function(t){let i=Math.floor(t/4),n=t%4;for(let t=0;t<i;t++)e.readByte(this.dataview,4);n>0&&e.readByte(this.dataview,n)}},{key:"readUint8",value:function(){return e.readByte(this.dataview,1)}},{key:"readUint16",value:function(){return e.readByte(this.dataview,2)}},{key:"readUint24",value:function(){return e.readByte(this.dataview,3)}},{key:"readUint32",value:function(){return e.readByte(this.dataview,4)}},{key:"readUint64",value:function(){return e.readByte(this.dataview,8)}},{key:"readInt8",value:function(){return e.readByte(this.dataview,1,!0)}},{key:"readInt16",value:function(){return e.readByte(this.dataview,2,!0)}},{key:"readInt32",value:function(){return e.readByte(this.dataview,4,!0)}},{key:"writeUint32",value:function(e){return new Uint8Array([e>>>24&255,e>>>16&255,e>>>8&255,255&e])}},{key:"length",get:function(){return this.buffer.byteLength}},{key:"position",set:function(e){this.dataview.position=e},get:function(){return this.dataview.position}}],[{key:"readByte",value:function(e,t,i){let n;switch(t){case 1:n=i?e.getInt8(e.position):e.getUint8(e.position);break;case 2:n=i?e.getInt16(e.position):e.getUint16(e.position);break;case 3:if(i)throw new Error("not supported for readByte 3");n=e.getUint8(e.position)<<16,n|=e.getUint8(e.position+1)<<8,n|=e.getUint8(e.position+2);break;case 4:n=i?e.getInt32(e.position):e.getUint32(e.position);break;case 8:if(i)throw new Error("not supported for readBody 8");n=e.getUint32(e.position)<<32,n|=e.getUint32(e.position+4);break;default:n=""}return e.position+=t,n}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),a=i(12),o=(n=a)&&n.__esModule?n:{default:n};let s=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)}return r(e,null,[{key:"getNalunits",value:function(t){if(t.length-t.position<4)return[];let i=t.dataview,n=t.position;return 1===i.getInt32(n)||0===i.getInt16(n)&&1===i.getInt8(n+2)?e.getAnnexbNals(t):e.getAvccNals(t)}},{key:"getAnnexbNals",value:function(t){let i=[],n=e.getHeaderPositionAnnexB(t),r=n.pos,a=r;for(;r<t.length-4;){let o=t.buffer.slice(r,r+n.headerLength);n.pos===t.position&&t.skip(n.headerLength),a=(n=e.getHeaderPositionAnnexB(t)).pos;let s={header:o,body:new Uint8Array(t.buffer.slice(r+o.byteLength,a))};e.analyseNal(s),i.push(s),t.skip(a-t.position),r=a}return i}},{key:"getAvccNals",value:function(t){let i=[];for(;t.position<t.length-4;){let n=t.dataview.getInt32(t.position);if(!(t.length-t.position>=n))break;{let r=t.buffer.slice(t.position,t.position+4);t.skip(4);let a=t.buffer.slice(t.position,t.position+n);t.skip(n);let o={header:r,body:a};e.analyseNal(o),i.push(o)}}return i}},{key:"analyseNal",value:function(e){switch(31&e.body[0]){case 1:e.ndr=!0;break;case 5:e.idr=!0;break;case 6:break;case 7:e.sps=o.default.parseSPS(e.body);break;case 8:e.pps=!0}}},{key:"getHeaderPositionAnnexB",value:function(e){let t=e.position,i=0;for(;3!==i&&4!==i&&t<e.length-4;)0===e.dataview.getInt16(t)?1===e.dataview.getInt16(t+2)?i=4:1===e.dataview.getInt8(t+2)?i=3:t++:t++;return t===e.length-4&&(0===e.dataview.getInt16(t)?1===e.dataview.getInt16(t+2)&&(i=4):(t++,0===e.dataview.getInt16(t)&&1===e.dataview.getInt8(t)?i=3:t=e.length)),{pos:t,headerLength:i}}},{key:"getAvcc",value:function(e,t){let i=new Uint8Array(e.byteLength+t.byteLength+11);i[0]=1,i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=255,i[5]=225;let n=6;return i.set(new Uint8Array([e.byteLength>>>8&255,255&e.byteLength]),n),n+=2,i.set(e,n),i[n+=e.byteLength]=1,n++,i.set(new Uint8Array([t.byteLength>>>8&255,255&t.byteLength]),n),n+=2,i.set(t,n),i}}]),e}();t.default=s},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),a=i(30),o=(n=a)&&n.__esModule?n:{default:n};let s=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)}return r(e,null,[{key:"_ebsp2rbsp",value:function(e){let t=e,i=t.byteLength,n=new Uint8Array(i),r=0;for(let e=0;e<i;e++)e>=2&&3===t[e]&&0===t[e-1]&&0===t[e-2]||(n[r]=t[e],r++);return new Uint8Array(n.buffer,0,r)}},{key:"parseSPS",value:function(t){let i=e._ebsp2rbsp(t),n=new o.default(i);n.readByte();let r=n.readByte();n.readByte();let a=n.readByte();n.readUEG();let s=e.getProfileString(r),u=e.getLevelString(a),l=1,c=420,f=[0,420,422,444],h=8;if((100===r||110===r||122===r||244===r||44===r||83===r||86===r||118===r||128===r||138===r||144===r)&&(3===(l=n.readUEG())&&n.readBits(1),l<=3&&(c=f[l]),h=n.readUEG()+8,n.readUEG(),n.readBits(1),n.readBool())){let t=3!==l?8:12;for(let i=0;i<t;i++)n.readBool()&&(i<6?e._skipScalingList(n,16):e._skipScalingList(n,64))}n.readUEG();let d=n.readUEG();if(0===d)n.readUEG();else if(1===d){n.readBits(1),n.readSEG(),n.readSEG();let e=n.readUEG();for(let t=0;t<e;t++)n.readSEG()}n.readUEG(),n.readBits(1);let p=n.readUEG(),y=n.readUEG(),m=n.readBits(1);0===m&&n.readBits(1),n.readBits(1);let v=0,g=0,_=0,b=0;n.readBool()&&(v=n.readUEG(),g=n.readUEG(),_=n.readUEG(),b=n.readUEG());let E=1,w=1,k=0,T=!0,A=0,S=0;if(n.readBool()){if(n.readBool()){let e=n.readByte(),t=[1,12,10,16,40,24,20,32,80,18,15,64,160,4,3,2],i=[1,11,11,11,33,11,11,11,33,11,11,33,99,3,2,1];e>0&&e<16?(E=t[e-1],w=i[e-1]):255===e&&(E=n.readByte()<<8|n.readByte(),w=n.readByte()<<8|n.readByte())}if(n.readBool()&&n.readBool(),n.readBool()&&(n.readBits(4),n.readBool()&&n.readBits(24)),n.readBool()&&(n.readUEG(),n.readUEG()),n.readBool()){let e=n.readBits(32),t=n.readBits(32);T=n.readBool(),k=(A=t)/(S=2*e)}}let x=1;1===E&&1===w||(x=E/w);let D=0,O=0;if(0===l)D=1,O=2-m;else{D=3===l?1:2,O=(1===l?2:1)*(2-m)}let C=16*(p+1),R=16*(y+1)*(2-m);C-=(v+g)*D,R-=(_+b)*O;let L=Math.ceil(C*x);return n.destroy(),n=null,{profile_string:s,level_string:u,bit_depth:h,chroma_format:c,chroma_format_string:e.getChromaFormatString(c),frame_rate:{fixed:T,fps:k,fps_den:S,fps_num:A},par_ratio:{width:E,height:w},codec_size:{width:C,height:R},present_size:{width:L,height:R}}}},{key:"_skipScalingList",value:function(e,t){let i=8,n=8,r=0;for(let a=0;a<t;a++)0!==n&&(n=(i+(r=e.readSEG())+256)%256),i=0===n?i:n}},{key:"getProfileString",value:function(e){switch(e){case 66:return"Baseline";case 77:return"Main";case 88:return"Extended";case 100:return"High";case 110:return"High10";case 122:return"High422";case 244:return"High444";default:return"Unknown"}}},{key:"getLevelString",value:function(e){return(e/10).toFixed(1)}},{key:"getChromaFormatString",value:function(e){switch(e){case 420:return"4:2:0";case 422:return"4:2:2";case 444:return"4:4:4";default:return"Unknown"}}},{key:"toVideoMeta",value:function(e){let t={};e&&e.codec_size&&(t.codecWidth=e.codec_size.width,t.codecHeight=e.codec_size.height,t.presentWidth=e.present_size.width,t.presentHeight=e.present_size.height),t.profile=e.profile_string,t.level=e.level_string,t.bitDepth=e.bit_depth,t.chromaFormat=e.chroma_format,t.parRatio={width:e.par_ratio.width,height:e.par_ratio.height},t.frameRate=e.frame_rate;let i=t.frameRate.fps_den,n=t.frameRate.fps_num;return t.refSampleDuration=Math.floor(t.timescale*(i/n)),t}}]),e}();t.default=s},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.XgBuffer=function(){function e(t){r(this,e),this.length=t||0,this.historyLen=t||0,this.array=[],this.offset=0}return n(e,[{key:"push",value:function(e){this.array.push(e),this.length+=e.byteLength,this.historyLen+=e.byteLength}},{key:"shift",value:function(e){if(this.array.length<1)return new Uint8Array(0);if(void 0===e)return this._shiftBuffer();if(this.offset+e===this.array[0].length){let t=this.array[0].slice(this.offset,this.offset+e);return this.offset=0,this.array.shift(),this.length-=e,t}if(this.offset+e<this.array[0].length){let t=this.array[0].slice(this.offset,this.offset+e);return this.offset+=e,this.length-=e,t}let t=new Uint8Array(e),i=0;for(;this.array.length>0&&e>0;){if(this.offset+e<this.array[0].length){let n=this.array[0].slice(this.offset,this.offset+e);t.set(n,i),this.offset+=e,this.length-=e,e=0;break}{let n=this.array[0].length-this.offset;t.set(this.array[0].slice(this.offset,this.array[0].length),i),this.array.shift(),this.offset=0,i+=n,this.length-=n,e-=n}}return t}},{key:"clear",value:function(){this.array=[],this.length=0,this.offset=0}},{key:"destroy",value:function(){this.clear(),this.historyLen=0}},{key:"_shiftBuffer",value:function(){return this.length-=this.array[0].length,this.offset=0,this.array.shift()}},{key:"toInt",value:function(e,t){let i=0,n=this.offset+e;for(;n<this.offset+t+e;)n<this.array[0].length?i=256*i+this.array[0][n]:this.array[1]&&(i=256*i+this.array[1][n-this.array[0].length]),n++;return i}}]),e}(),t.RemuxBuffer=function(){function e(){r(this,e),this.video=[],this.audio=[]}return n(e,[{key:"destroy",value:function(){this.video=[],this.audio=[]}}]),e}()},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,r=function e(t,i,n){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,i);if(void 0===r){var a=Object.getPrototypeOf(t);return null===a?void 0:e(a,i,n)}if("value"in r)return r.value;var o=r.get;return void 0!==o?o.call(n):void 0},a=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),o=i(6),s=(n=o)&&n.__esModule?n:{default:n},u=i(7);function l(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}let c=function(){function e(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];l(this,e),this._emitter=new u.EventEmitter,this._instanceMap={},this._clsMap={},this._inited=!1,this.mediaInfo=new s.default,this.allowedEvents=t,this._hooks={}}return a(e,[{key:"getInstance",value:function(e){const t=this._instanceMap[e];return t||null}},{key:"initInstance",value:function(e){if(this._clsMap[e]){for(var t=arguments.length,i=Array(t>1?t-1:0),n=1;n<t;n++)i[n-1]=arguments[n];const r=new(Function.prototype.bind.apply(this._clsMap[e],[null].concat(i)));return this._instanceMap[e]=r,r.init&&r.init(),r}throw new Error(`${e}未在context中注册`)}},{key:"init",value:function(e){if(!this._inited){for(let t in this._clsMap)this._clsMap.hasOwnProperty(t)&&!this._instanceMap[t]&&this.initInstance(t,e);this._inited=!0}}},{key:"registry",value:function(e,t){var i=this;const n=this._emitter,o=this._isMessageNameValid.bind(this),s=this,u=function(t){function i(){var t;l(this,i);for(var n=arguments.length,r=Array(n),a=0;a<n;a++)r[a]=arguments[a];var o=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(t=i.__proto__||Object.getPrototypeOf(i)).call.apply(t,[this].concat(r)));return o.listeners={},o.onceListeners={},o.TAG=e,o._context=s,o}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(i,t),a(i,[{key:"on",value:function(t,i){return o(t),this.listeners[t]?this.listeners[t].push(i):this.listeners[t]=[i],n.on(`${t}__TO__${e}`,i),n.on(t,i)}},{key:"before",value:function(e,t){o(e),s._hooks[e]?s._hooks[e].push(t):s._hooks[e]=[t]}},{key:"once",value:function(t,i){return o(t),this.onceListeners[t]?this.onceListeners[t].push(i):this.onceListeners[t]=[i],n.once(`${t}__TO__${e}`,i),n.once(t,i)}},{key:"emit",value:function(e){o(e);const t=s._hooks?s._hooks[e]:null;if(t)for(let e=0,i=t.length;e<i;e++){(0,t[e])()}for(var i=arguments.length,r=Array(i>1?i-1:0),a=1;a<i;a++)r[a-1]=arguments[a];return n.emit.apply(n,[e].concat(r))}},{key:"emitTo",value:function(e,t){o(t);for(var i=arguments.length,r=Array(i>2?i-2:0),a=2;a<i;a++)r[a-2]=arguments[a];return n.emit.apply(n,[`${t}__TO__${e}`].concat(r))}},{key:"off",value:function(e,t){return o(e),n.off(e,t)}},{key:"removeListeners",value:function(){const t=Object.prototype.hasOwnProperty.bind(this.listeners);for(let i in this.listeners)if(t(i)){const t=this.listeners[i]||[];for(let r=0;r<t.length;r++){const a=t[r];n.off(i,a),n.off(`${i}__TO__${e}`,a)}}for(let i in this.onceListeners)if(t(i)){const t=this.onceListeners[i]||[];for(let r=0;r<t.length;r++){const a=t[r];n.off(i,a),n.off(`${i}__TO__${e}`,a)}}}},{key:"destroy",value:function(){if(this.removeListeners(),this.listeners={},delete s._instanceMap[e],r(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"destroy",this))return r(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"destroy",this).call(this)}}]),i}(t);return this._clsMap[e]=u,function(){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];return i.initInstance.apply(i,[e].concat(n))}}},{key:"destroyInstances",value:function(){Object.keys(this._instanceMap).forEach(e=>{this._instanceMap[e].destroy&&this._instanceMap[e].destroy()})}},{key:"destroy",value:function(){this._emitter=null,this.allowedEvents=[],this._clsMap=null,this._context=null,this._hooks=null,this.destroyInstances()}},{key:"_isMessageNameValid",value:function(e){if(!this.allowedEvents.indexOf(e)<0)throw new Error(`unregistered message name: ${e}`)}}]),e}();t.default=c},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CONTEXT_COMOMANDS={ON:"on",ONCE:"once",OFF:"off",EMIT:"emit",DESTROY:"destroy"}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=function(){const e=new ArrayBuffer(2);return new DataView(e).setInt16(0,256,!0),256===new Int16Array(e)[0]}(),r={get device(){let e=r.os;return e.isPc?"pc":e.isTablet?"tablet":"mobile"},get browser(){let e=navigator.userAgent.toLowerCase(),t={ie:/rv:([\d.]+)\) like gecko/,firfox:/firefox\/([\d.]+)/,chrome:/chrome\/([\d.]+)/,opera:/opera.([\d.]+)/,safari:/version\/([\d.]+).*safari/};return[].concat(Object.keys(t).filter(i=>t[i].test(e)))[0]},get os(){let e=navigator.userAgent,t=/(?:Windows Phone)/.test(e),i=/(?:SymbianOS)/.test(e)||t,n=/(?:Android)/.test(e),r=/(?:Firefox)/.test(e),a=/(?:iPad|PlayBook)/.test(e)||n&&!/(?:Mobile)/.test(e)||r&&/(?:Tablet)/.test(e),o=/(?:iPhone)/.test(e)&&!a;return{isTablet:a,isPhone:o,isAndroid:n,isPc:!o&&!n&&!i,isSymbian:i,isWindowsPhone:t,isFireFox:r}},get isLe(){return n}};t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=function(){const e=new ArrayBuffer(2);return new DataView(e).setInt16(0,256,!0),256===new Int16Array(e)[0]}();t.default=n},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)}return n(e,null,[{key:"decode",value:function(t){const i=[],n=t;let r=0;const a=t.length;for(;r<a;)if(n[r]<128)i.push(String.fromCharCode(n[r])),++r;else{if(n[r]<192);else if(n[r]<224){if(e._checkContinuation(n,r,1)){const e=(31&n[r])<<6|63&n[r+1];if(e>=128){i.push(String.fromCharCode(65535&e)),r+=2;continue}}}else if(n[r]<240){if(e._checkContinuation(n,r,2)){const e=(15&n[r])<<12|(63&n[r+1])<<6|63&n[r+2];if(e>=2048&&55296!=(63488&e)){i.push(String.fromCharCode(65535&e)),r+=3;continue}}}else if(n[r]<248&&e._checkContinuation(n,r,3)){let e=(7&n[r])<<18|(63&n[r+1])<<12|(63&n[r+2])<<6|63&n[r+3];if(e>65536&&e<1114112){e-=65536,i.push(String.fromCharCode(e>>>10|55296)),i.push(String.fromCharCode(1023&e|56320)),r+=4;continue}}i.push(String.fromCharCode(65533)),++r}return i.join("")}},{key:"_checkContinuation",value:function(e,t,i){let n=e;if(t+i<n.length){for(;i--;)if(128!=(192&n[++t]))return!1;return!0}return!1}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),a=i(2);const o=((n=a)&&n.__esModule?n:{default:n}).default.BROWSER_EVENTS;let s,u;void 0!==document.hidden?(s="hidden",u="visibilitychange"):void 0!==document.msHidden?(s="msHidden",u="msvisibilitychange"):void 0!==document.webkitHidden&&(s="webkitHidden",u="webkitvisibilitychange");let l=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.callbacks={onShow:[],onHidden:[]},this.handleVisibilityChange=this.handleVisibilityChange.bind(this),this.init()}return r(e,[{key:"init",value:function(){document.addEventListener(u,this.handleVisibilityChange,!1)}},{key:"handleVisibilityChange",value:function(){this.emit(o.VISIBILITY_CHANGE,document[s])}},{key:"destroy",value:function(){document.removeEventListener(u,this.handleVisibilityChange)}}]),e}();t.default=l},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e);let i=e.getDefaultInf();if(!t||"[object Object]"!==Object.prototype.toString.call(t))return i;let n=Object.assign({},i,t);Object.entries(n).forEach(e=>{let[t,i]=e;this[t]=i})}return n(e,null,[{key:"getDefaultInf",value:function(){return{dts:null,pts:null,duration:null,position:null,isRAP:!1,originDts:null}}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.startDts=-1,this.endDts=-1,this.startPts=-1,this.endPts=-1,this.originStartDts=-1,this.originEndDts=-1,this.randomAccessPoints=[],this.firstSample=null,this.lastSample=null}return n(e,[{key:"addRAP",value:function(e){e.isRAP=!0,this.randomAccessPoints.push(e)}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this._type=t,this._list=[],this._lastAppendLocation=-1}return n(e,[{key:"isEmpty",value:function(){return 0===this._list.length}},{key:"clear",value:function(){this._list=[],this._lastAppendLocation=-1}},{key:"_searchNearestSegmentBefore",value:function(e){let t=this._list;if(0===t.length)return-2;let i=t.length-1,n=0,r=0,a=i,o=0;if(e<t[0].originDts)return o=-1;for(;r<=a;){if((n=r+Math.floor((a-r)/2))===i||e>t[n].lastSample.originDts&&e<t[n+1].originDts){o=n;break}t[n].originDts<e?r=n+1:a=n-1}return o}},{key:"_searchNearestSegmentAfter",value:function(e){return this._searchNearestSegmentBefore(e)+1}},{key:"append",value:function(e){let t=this._list,i=this._lastAppendLocation,n=0;-1!==i&&i<t.length&&e.originStartDts>=t[i].lastSample.originDts&&(i===t.length-1||i<t.length-1&&e.originStartDts<t[i+1].originStartDts)?n=i+1:t.length>0&&(n=this._searchNearestSegmentBefore(e.originStartDts)+1),this._lastAppendLocation=n,this._list.splice(n,0,e)}},{key:"getLastSegmentBefore",value:function(e){let t=this._searchNearestSegmentBefore(e);return t>=0?this._list[t]:null}},{key:"getLastSampleBefore",value:function(e){let t=this.getLastSegmentBefore(e);return null!==t?t.lastSample:null}},{key:"getLastRAPBefore",value:function(e){let t=this._searchNearestSegmentBefore(e),i=this._list[t].randomAccessPoints;for(;0===i.length&&t>0;)t--,i=this._list[t].randomAccessPoints;return i.length>0?i[i.length-1]:null}},{key:"type",get:function(){return this._type}},{key:"length",get:function(){return this._list.length}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.configs=Object.assign({},t),this.container=this.configs.container,this.mediaSource=null,this.sourceBuffers={},this.preloadTime=this.configs.preloadTime||1,this.onSourceOpen=this.onSourceOpen.bind(this),this.onTimeUpdate=this.onTimeUpdate.bind(this),this.onUpdateEnd=this.onUpdateEnd.bind(this),this.onWaiting=this.onWaiting.bind(this)}return n(e,[{key:"init",value:function(){this.mediaSource=new self.MediaSource,this.mediaSource.addEventListener("sourceopen",this.onSourceOpen),this.container.src=URL.createObjectURL(this.mediaSource),this.url=this.container.src,this.container.addEventListener("timeupdate",this.onTimeUpdate),this.container.addEventListener("waiting",this.onWaiting)}},{key:"onTimeUpdate",value:function(){this.emit("TIME_UPDATE",this.container)}},{key:"onWaiting",value:function(){this.emit("WAITING",this.container)}},{key:"onSourceOpen",value:function(){this.addSourceBuffers()}},{key:"onUpdateEnd",value:function(){this.emit("SOURCE_UPDATE_END"),this.doAppend()}},{key:"addSourceBuffers",value:function(){if("open"!==this.mediaSource.readyState)return;let e,t=this._context.getInstance("PRE_SOURCE_BUFFER"),i=this._context.getInstance("TRACKS");t=t.sources;let n=!1;for(let r=0,a=Object.keys(t).length;r<a;r++){let a=Object.keys(t)[r];if("audio"===a?e=i.audioTrack:"video"===a&&(e=i.videoTrack),e){let i="audio"===a?21:40;e.meta&&e.meta.refSampleDuration&&(i=e.meta.refSampleDuration),t[a].data.length>=this.preloadTime/i&&(n=!0)}}if(n){if(Object.keys(this.sourceBuffers).length>0)return;for(let e=0,i=Object.keys(t).length;e<i;e++){let i=Object.keys(t)[e],n=t[i],r="video"===i?"video/mp4;codecs="+n.mimetype:"audio/mp4;codecs="+n.mimetype,a=this.mediaSource.addSourceBuffer(r);this.sourceBuffers[i]=a,a.addEventListener("updateend",this.onUpdateEnd),this.doAppend()}}}},{key:"doAppend",value:function(){let e=this._context.getInstance("PRE_SOURCE_BUFFER");if(e)for(let t=0;t<Object.keys(this.sourceBuffers).length;t++){let i=Object.keys(this.sourceBuffers)[t],n=this.sourceBuffers[i];if(!n.updating){let t=e.sources[i];if(t&&!t.inited)n.appendBuffer(t.init.buffer.buffer),t.inited=!0;else if(t){let e=t.data.shift();e&&n.appendBuffer(e.buffer.buffer)}}}}},{key:"endOfStream",value:function(){const{readyState:e,activeSourceBuffers:t}=this.mediaSource;if("open"===e&&0===t.length)try{this.mediaSource.endOfStream()}catch(e){}}},{key:"remove",value:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;for(let i=0;i<Object.keys(this.sourceBuffers).length;i++){let n=this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];n.updating||n.remove(t,e)}}},{key:"removeBuffers",value:function(){const t=[];for(let i=0;i<Object.keys(this.sourceBuffers).length;i++){let n,r=this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];r.removeEventListener("updateend",this.onUpdateEnd),r.updating?n=new Promise(t=>{const i=function(){let n=3;const a=()=>{r.updating?n>0?(setTimeout(a,200),n--):t():(e.clearBuffer(r),t())};setTimeout(a,200),r.removeEventListener("updateend",i)};r.addEventListener("updateend",i)}):(e.clearBuffer(r),n=Promise.resolve()),t.push(n)}return Promise.all(t)}},{key:"destroy",value:function(){return this.removeBuffers().then(()=>{for(let e=0;e<Object.keys(this.sourceBuffers).length;e++){let t=this.sourceBuffers[Object.keys(this.sourceBuffers)[e]];this.mediaSource.removeSourceBuffer(t),delete this.sourceBuffers[Object.keys(this.sourceBuffers)[e]]}this.container.removeEventListener("timeupdate",this.onTimeUpdate),this.container.removeEventListener("waiting",this.onWaiting),this.mediaSource.removeEventListener("sourceopen",this.onSourceOpen),this.endOfStream(),window.URL.revokeObjectURL(this.url),this.url=null,this.configs={},this.container=null,this.mediaSource=null,this.sourceBuffers={},this.preloadTime=1})}}],[{key:"clearBuffer",value:function(e){const t=e.buffered;let i=.1;for(let e=0,n=t.length;e<n;e++)i=t.end(e);try{e.remove(0,i)}catch(e){}}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),a=i(25),o=(n=a)&&n.__esModule?n:{default:n};let s=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.buffer=t||new Uint8Array(0)}return r(e,[{key:"write",value:function(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];t.forEach(e=>{this.buffer=(0,o.default)(Uint8Array,this.buffer,e)})}}],[{key:"writeUint32",value:function(e){return new Uint8Array([e>>24,e>>16&255,e>>8&255,255&e])}},{key:"readAsInt",value:function(e){let t="";return e.forEach(e=>{t+=function(e){return e.toString(16).padStart(2,"0")}(e)}),parseInt(t,16)}}]),e}();t.default=s},function(e,t,i){"use strict";var n,r=i(26),a=(n=r)&&n.__esModule?n:{default:n};e.exports=a.default},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){for(var t=0,i=arguments.length,n=Array(i>1?i-1:0),r=1;r<i;r++)n[r-1]=arguments[r];var a=!0,o=!1,s=void 0;try{for(var u,l=n[Symbol.iterator]();!(a=(u=l.next()).done);a=!0){var c=u.value;t+=c.length}}catch(e){o=!0,s=e}finally{try{!a&&l.return&&l.return()}finally{if(o)throw s}}var f=new e(t),h=0,d=!0,p=!1,y=void 0;try{for(var m,v=n[Symbol.iterator]();!(d=(m=v.next()).done);d=!0){var g=m.value;f.set(g,h),h+=g.length}}catch(e){p=!0,y=e}finally{try{!d&&v.return&&v.return()}finally{if(p)throw y}}return f}},function(e,t,i){"use strict";var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),r=s(i(28)),a=s(i(35)),o=i(36);function s(e){return e&&e.__esModule?e:{default:e}}function u(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}let l=function(){function e(t){u(this,e),this.aCtx=t.aCtx,this.vCtx=t.vCtx,this.video=t.video,this.timeoutId=null,this.start=null}return n(e,[{key:"doReconcile",value:function(){const e=(this.vCtx.currentTime||0)-1e3*(this.aCtx.currentTime||0);this.timeoutId||(e>200?(this.video.start+=e,this.vCtx.pause(),this.timeoutId=setTimeout(()=>{this.vCtx.play(),this.timeoutId=null},e)):e<-120&&(this.video.start+=e))}},{key:"destroy",value:function(){this.start=null,this.aCtx=null,this.vCtx=null}}]),e}(),c=function(e){function t(){u(this,t);var e=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return e._canvas=document.createElement("canvas"),e.handleAudioSourceEnd=e.handleAudioSourceEnd.bind(e),e.played=!1,e.pendingPlayTask=null,e._paused=!0,e.videoMetaInited=!1,e.audioMetaInited=!1,e.init(),e}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(t,HTMLElement),n(t,[{key:"init",value:function(){this.vCtx=new r.default(Object.assign({canvas:this._canvas},{style:{width:this.width,height:this.height}})),this.aCtx=new a.default({}),this.ticker=new((0,o.getTicker)()),this.reconciler=new l({vCtx:this.vCtx,aCtx:this.aCtx,video:this}),this.dispatchEvent(new Event("waiting")),this.vCtx.oncanplay=()=>{this.played||this.appendChild(this._canvas),this.dispatchEvent(new Event("canplay"))},this.aCtx.on("AUDIO_SOURCE_END",this.handleAudioSourceEnd)}},{key:"handleAudioSourceEnd",value:function(){this.reconciler.doReconcile(),this.vCtx.cleanBuffer()}},{key:"_cleanBuffer",value:function(){this.vCtx.cleanBuffer()}},{key:"destroy",value:function(){this.aCtx.destroy(),this.vCtx.destroy(),this.ticker.stop(),this.start=null,this.reconciler.destroy(),this.aCtx=null,this.vCtx=null,this.ticker=null}},{key:"onDemuxComplete",value:function(e,t){this.aCtx.decodeAudio(t),this.vCtx.decodeVideo(e)}},{key:"setAudioMeta",value:function(e){this.audioMetaInited&&(this.aCtx.destroy(),this.aCtx=new a.default({})),this.aCtx.setAudioMetaData(e),this.audioMetaInited=!0}},{key:"setVideoMeta",value:function(e){this.videoMetaInited&&(this.vCtx.destroy(),this.vCtx=new r.default(Object.assign({canvas:this._canvas},{style:{width:this.width,height:this.height}}))),this.vCtx.setVideoMetaData(e),this.videoMetaInited=!0}},{key:"play",value:function(){this.pendingPlayTask||(this.played&&(this.destroy(),this.init()),this.pendingPlayTask=Promise.all([this.vCtx.play(),this.aCtx.play().then(()=>{this.aCtx.muted=!0})]).then(()=>{this.aCtx.muted=!1,this.ticker.start(()=>{this.start||(this.start=Date.now()),this._currentTime=Date.now()-this.start,this.vCtx._onTimer(this._currentTime)}),this.pendingPlayTask=null,this.played=!0,this.dispatchEvent(new Event("playing")),this.dispatchEvent(new Event("play")),this._paused=!1}))}},{key:"pause",value:function(){this._paused=!0,this.aCtx.pause(),this.vCtx.pause(),this.dispatchEvent(new Event("pause"))}},{key:"width",get:function(){return this.getAttribute("width")||this.videoWidth},set:function(e){this.style.display="inline-block";const t="number"==typeof e?`${e}px`:e;this.setAttribute("width",t),this.style.width=t,this._canvas.style.width=t,this._canvas.width=e}},{key:"height",get:function(){return this.getAttribute("height")},set:function(e){this.style.display="inline-block";const t="number"==typeof e?`${e}px`:e;this.setAttribute("height",t),this.style.height=t,this._canvas.style.height=t,this._canvas.height=e}},{key:"videoWidth",get:function(){return this.vCtx&&this.vCtx.videoWidth?this.vCtx.videoWidth:0}},{key:"videoHeight",get:function(){return this.vCtx&&this.vCtx.videoHeight?this.vCtx.videoHeight:0}},{key:"src",get:function(){return this.getAttribute("src")},set:function(e){this.setAttribute("src",e)}},{key:"readyState",get:function(){return this.videoMetaInited?this.vCtx.readyState:0}},{key:"seeking",get:function(){return!!this.videoMetaInited&&this.vCtx.seeking}},{key:"currentTime",get:function(){return this.videoMetaInited?this.vCtx.currentTime/1e3:0}},{key:"duration",get:function(){return this.audioMetaInited?this.aCtx.duration:0}},{key:"paused",get:function(){return this._paused}},{key:"playbackRate",get:function(){return this.hasAttribute("playbackRate")?this.getAttribute("playbackRate"):1},set:function(e){this.setAttribute("playbackrate",e),this.aCtx.playbackRate=e,this.vCtx.playbackRate=e,this.dispatchEvent(new Event("ratechange"))}},{key:"ended",get:function(){return!!this.audioMetaInited&&this.aCtx.ended}},{key:"autoplay",get:function(){return!!this.hasAttribute("autoplay")&&this.getAttribute("autoplay")},set:function(e){this.setAttribute("autoplay",e)}},{key:"volume",get:function(){return this.aCtx.volume},set:function(e){this.setAttribute("volume",e),this.aCtx.volume=e}},{key:"muted",get:function(){const e="true"===this.getAttribute("muted");return void 0!==e?e:!!this.getAttribute("volume")&&0===Number.parseInt(this.getAttribute("volume"))},set:function(e){this.setAttribute("muted",e),this.aCtx.muted=!!e}},{key:"error",get:function(){return this.vCtx.error||this.aCtx.error}},{key:"buffered",get:function(){return this.vCtx.buffered}}]),t}();customElements.define("mobile-video",c)},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),r=c(i(29)),a=c(i(10)),o=c(i(11)),s=c(i(31)),u=c(i(32)),l=c(i(33));function c(e){return e&&e.__esModule?e:{default:e}}let f=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.config=Object.assign({},t),this.canvas=this.config.canvas?this.config.canvas:document.createElement("canvas"),this.source=new u.default({type:"video"}),this.preloadTime=this.config.preloadTime||3,this.oncanplay=void 0,this.onFirstFrame=void 0,this.meta=void 0,this.readyStatus=0,this.paused=!0,this.count=0,this.currentTime=0,this.lastPlayed=0,this._decoderInited=!1,this._avccpushed=!1,this._decodedFrames={},this._lastSampleDts=void 0,this._baseDts=void 0,this._lastRenderTime=null,this.playFinish=null}return n(e,[{key:"pause",value:function(){this.paused=!0}},{key:"initWasmWorker",value:function(){let e=this;this.wasmworker=(0,r.default)(34),this.wasmworker.postMessage({msg:"init",meta:this.meta}),this.wasmworker.addEventListener("message",t=>{switch(t.data.msg){case"DECODER_READY":e._decoderInited=!0;break;case"DECODED":this._onDecoded(t.data)}})}},{key:"setVideoMetaData",value:function(e){if(this.meta=e,!this._decoderInited)return void this.initWasmWorker();this._avccpushed=!0;let t=new Uint8Array(e.sps.byteLength+4);if(t.set([0,0,0,1]),t.set(e.sps,4),this.wasmworker.postMessage({msg:"decode",data:t}),(t=new Uint8Array(e.pps.byteLength+4)).set([0,0,0,1]),t.set(e.pps,4),this.wasmworker.postMessage({msg:"decode",data:t}),!this.yuvCanvas){let t=Object.assign({meta:e,canvas:this.canvas},this.config);this.yuvCanvas=new s.default(t)}this.readyStatus=1}},{key:"decodeVideo",value:function(e){if(!this._decoderInited)return;this._avccpushed||this.setVideoMetaData(this.meta);let{samples:t}=e,i=t.shift();for(;i;)this._baseDts||(this._baseDts=i.dts),this.source.push(i),i=t.shift();this._preload()}},{key:"_preload",value:function(){if(!this._lastSampleDts||this._lastSampleDts-this._baseDts<this.currentTime+1e3*this.preloadTime){let e=this.source.get();for(e&&(this._lastSampleDts=e.dts,this._analyseNal(e));e&&this._lastSampleDts-this._baseDts<this.currentTime+1e3*this.preloadTime;)(e=this.source.get())&&(this._analyseNal(e),this._lastSampleDts=e.dts)}}},{key:"_analyseNal",value:function(e){let t=o.default.getAvccNals(new a.default(e.data.buffer)),i=0;for(let e=0;e<t.length;e++){i+=t[e].body.byteLength+4}let n=0,r=new Uint8Array(i);for(let e=0;e<t.length;e++){let i=t[e];r.set([0,0,0,1],n),n+=4,r.set(new Uint8Array(i.body),n),n+=i.body.byteLength}this.wasmworker.postMessage({msg:"decode",data:r,info:{dts:e.dts,pts:e.pts?e.pts:e.dts+e.cts,key:e.isKeyframe}})}},{key:"_onDecoded",value:function(e){let{dts:t}=e.info;this._decodedFrames[t]=e,Object.keys(this._decodedFrames).length>10&&(this.playFinish&&this.playFinish(),this.oncanplay&&this.oncanplay())}},{key:"play",value:function(){return this.paused=!1,new Promise(e=>{this.playFinish=e}).then(()=>{this.playFinish=null})}},{key:"_onTimer",value:function(e){if(!this.paused){if(this.meta){this.meta.frameRate&&this.meta.frameRate.fixed&&this.meta.frameRate.fps;let t=Object.keys(this._decodedFrames);if(t.length>0){this.currentTime=e;let i=-1;for(let e=0;e<t.length&&Number.parseInt(t[e])-this._baseDts<=this.currentTime;e++)i=Number.parseInt(t[e-1]);let n=this._decodedFrames[i];n&&this.yuvCanvas.render(n.buffer,n.width,n.height,n.yLinesize,n.uvLinesize);for(let e=0;e<t.length;e++)Number.parseInt(t[e])<i&&delete this._decodedFrames[t[e]]}}this._lastRenderTime=Date.now()}}},{key:"cleanBuffer",value:function(){this.currentTime>1&&this.source.remove(0,this.currentTime-1)}},{key:"destroy",value:function(){this.wasmworker.postMessage({msg:"destroy"}),this.wasmworker=null,this.canvas=null,this.source=null,this._decoderInited=!1}},{key:"buffered",get:function(){const e=[];let t={start:null,end:null};for(let e=0;e<this.source.buffer.length;e++){const{start:i,end:n}=this.source.buffer[e];t.start||(t.start=i),t.end||(t.end=n),i-t.end>1e3?(t.start=t.start/1e3,t.end=t.end/1e3,t={start:i,end:n}):t.end=n}return null!==t.start&&null!==t.end&&(t.start=t.start/1e3,t.end=t.end/1e3,e.push(t)),new l.default(e)}}]),e}();t.default=f},function(e,t,i){"use strict";function n(e){var t={};function i(n){if(t[n])return t[n].exports;var r=t[n]={i:n,l:!1,exports:{}};return e[n].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.m=e,i.c=t,i.i=function(e){return e},i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n})},i.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="/",i.oe=function(e){throw console.error(e),e};var n=i(i.s=ENTRY_MODULE);return n.default||n}var r="[\\.|\\-|\\+|\\w|/|@]+",a="\\(\\s*(/\\*.*?\\*/)?\\s*.*?("+r+").*?\\)";function o(e){return(e+"").replace(/[.?*+^$[\]\\(){}|-]/g,"\\$&")}function s(e,t,n){var s={};s[n]=[];var u=t.toString(),l=u.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/);if(!l)return s;for(var c,f=l[1],h=new RegExp("(\\\\n|\\W)"+o(f)+a,"g");c=h.exec(u);)"dll-reference"!==c[3]&&s[n].push(c[3]);for(h=new RegExp("\\("+o(f)+'\\("(dll-reference\\s('+r+'))"\\)\\)'+a,"g");c=h.exec(u);)e[c[2]]||(s[n].push(c[1]),e[c[2]]=i(c[1]).m),s[c[2]]=s[c[2]]||[],s[c[2]].push(c[4]);for(var d,p=Object.keys(s),y=0;y<p.length;y++)for(var m=0;m<s[p[y]].length;m++)d=s[p[y]][m],isNaN(1*d)||(s[p[y]][m]=1*s[p[y]][m]);return s}function u(e){return Object.keys(e).reduce((function(t,i){return t||e[i].length>0}),!1)}e.exports=function(e,t){t=t||{};var r={main:i.m},a=t.all?{main:Object.keys(r.main)}:function(e,t){for(var i={main:[t]},n={main:[]},r={main:{}};u(i);)for(var a=Object.keys(i),o=0;o<a.length;o++){var l=a[o],c=i[l].pop();if(r[l]=r[l]||{},!r[l][c]&&e[l][c]){r[l][c]=!0,n[l]=n[l]||[],n[l].push(c);for(var f=s(e,e[l][c],l),h=Object.keys(f),d=0;d<h.length;d++)i[h[d]]=i[h[d]]||[],i[h[d]]=i[h[d]].concat(f[h[d]])}}return n}(r,e),o="";Object.keys(a).filter((function(e){return"main"!==e})).forEach((function(e){for(var t=0;a[e][t];)t++;a[e].push(t),r[e][t]="(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })",o=o+"var "+e+" = ("+n.toString().replace("ENTRY_MODULE",JSON.stringify(t))+")({"+a[e].map((function(t){return JSON.stringify(t)+": "+r[e][t].toString()})).join(",")+"});\n"})),o=o+"new (("+n.toString().replace("ENTRY_MODULE",JSON.stringify(e))+")({"+a.main.map((function(e){return JSON.stringify(e)+": "+r.main[e].toString()})).join(",")+"}))(self);";var l=new window.Blob([o],{type:"text/javascript"});if(t.bare)return l;var c=(window.URL||window.webkitURL||window.mozURL||window.msURL).createObjectURL(l),f=new window.Worker(c);return f.objectURL=c,f}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.TAG="Golomb",this._buffer=t,this._bufferIndex=0,this._totalBytes=t.byteLength,this._totalBits=8*t.byteLength,this._currentWord=0,this._currentWordBitsLeft=0}return n(e,[{key:"destroy",value:function(){this._buffer=null}},{key:"_fillCurrentWord",value:function(){let e=this._totalBytes-this._bufferIndex,t=Math.min(4,e),i=new Uint8Array(4);i.set(this._buffer.subarray(this._bufferIndex,this._bufferIndex+t)),this._currentWord=new DataView(i.buffer).getUint32(0),this._bufferIndex+=t,this._currentWordBitsLeft=8*t}},{key:"readBits",value:function(e){let t=Math.min(this._currentWordBitsLeft,e),i=this._currentWord>>>32-t;if(e>32)throw new Error("Cannot read more than 32 bits at a time");return this._currentWordBitsLeft-=t,this._currentWordBitsLeft>0?this._currentWord<<=t:this._totalBytes-this._bufferIndex>0&&this._fillCurrentWord(),(t=e-t)>0&&this._currentWordBitsLeft?i<<t|this.readBits(t):i}},{key:"readBool",value:function(){return 1===this.readBits(1)}},{key:"readByte",value:function(){return this.readBits(8)}},{key:"_skipLeadingZero",value:function(){let e;for(e=0;e<this._currentWordBitsLeft;e++)if(0!=(this._currentWord&2147483648>>>e))return this._currentWord<<=e,this._currentWordBitsLeft-=e,e;return this._fillCurrentWord(),e+this._skipLeadingZero()}},{key:"readUEG",value:function(){let e=this._skipLeadingZero();return this.readBits(e+1)-1}},{key:"readSEG",value:function(){let e=this.readUEG();return 1&e?e+1>>>1:-1*(e>>>1)}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.configs=Object.assign({},t),this.canvas=this.configs.canvas,this.meta=Object.assign({},this.configs.meta),this.chroma=this.meta.chromaFormat,this.height=this.meta.presentHeight,this.width=this.meta.presentWidth,this._initContextGL(),this.contextGL&&(this._initProgram(),this._initBuffers(),this._initTextures())}return n(e,[{key:"_initContextGL",value:function(){for(var e=this.canvas,t=null,i=["webgl","experimental-webgl","moz-webgl","webkit-3d"],n=0;!t&&n<i.length;){var r=i[n];try{t=this.contextOptions?e.getContext(r,this.contextOptions):e.getContext(r)}catch(e){t=null}t&&"function"==typeof t.getParameter||(t=null),++n}this.contextGL=t}},{key:"_initProgram",value:function(){var e,t,i=this.contextGL;e=["attribute vec4 vertexPos;","attribute vec4 texturePos;","attribute vec4 uTexturePos;","attribute vec4 vTexturePos;","varying vec2 textureCoord;","varying vec2 uTextureCoord;","varying vec2 vTextureCoord;","void main()","{","  gl_Position = vertexPos;","  textureCoord = texturePos.xy;","  uTextureCoord = uTexturePos.xy;","  vTextureCoord = vTexturePos.xy;","}"].join("\n"),t=["precision highp float;","varying highp vec2 textureCoord;","varying highp vec2 uTextureCoord;","varying highp vec2 vTextureCoord;","uniform sampler2D ySampler;","uniform sampler2D uSampler;","uniform sampler2D vSampler;","uniform mat4 YUV2RGB;","void main(void) {","  highp float y = texture2D(ySampler,  textureCoord).r;","  highp float u = texture2D(uSampler,  uTextureCoord).r;","  highp float v = texture2D(vSampler,  vTextureCoord).r;","  gl_FragColor = vec4(y, u, v, 1) * YUV2RGB;","}"].join("\n");var n=i.createShader(i.VERTEX_SHADER);i.shaderSource(n,e),i.compileShader(n),i.getShaderParameter(n,i.COMPILE_STATUS)||console.log("Vertex shader failed to compile: "+i.getShaderInfoLog(n));var r=i.createShader(i.FRAGMENT_SHADER);i.shaderSource(r,t),i.compileShader(r),i.getShaderParameter(r,i.COMPILE_STATUS)||console.log("Fragment shader failed to compile: "+i.getShaderInfoLog(r));var a=i.createProgram();i.attachShader(a,n),i.attachShader(a,r),i.linkProgram(a),i.getProgramParameter(a,i.LINK_STATUS)||console.log("Program failed to compile: "+i.getProgramInfoLog(a)),i.useProgram(a);var o=i.getUniformLocation(a,"YUV2RGB");i.uniformMatrix4fv(o,!1,[1.16438,0,1.59603,-.87079,1.16438,-.39176,-.81297,.52959,1.16438,2.01723,0,-1.08139,0,0,0,1]),this.shaderProgram=a}},{key:"_initBuffers",value:function(){var e=this.contextGL,t=this.shaderProgram,i=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,i),e.bufferData(e.ARRAY_BUFFER,new Float32Array([1,1,-1,1,1,-1,-1,-1]),e.STATIC_DRAW);var n=e.getAttribLocation(t,"vertexPos");e.enableVertexAttribArray(n),e.vertexAttribPointer(n,2,e.FLOAT,!1,0,0);var r=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,new Float32Array([1,0,0,0,1,1,0,1]),e.STATIC_DRAW);var a=e.getAttribLocation(t,"texturePos");e.enableVertexAttribArray(a),e.vertexAttribPointer(a,2,e.FLOAT,!1,0,0),this.texturePosBuffer=r;var o=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,new Float32Array([1,0,0,0,1,1,0,1]),e.STATIC_DRAW);var s=e.getAttribLocation(t,"uTexturePos");e.enableVertexAttribArray(s),e.vertexAttribPointer(s,2,e.FLOAT,!1,0,0),this.uTexturePosBuffer=o;var u=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,u),e.bufferData(e.ARRAY_BUFFER,new Float32Array([1,0,0,0,1,1,0,1]),e.STATIC_DRAW);var l=e.getAttribLocation(t,"vTexturePos");e.enableVertexAttribArray(l),e.vertexAttribPointer(l,2,e.FLOAT,!1,0,0),this.vTexturePosBuffer=u}},{key:"_initTextures",value:function(){var e=this.contextGL,t=this.shaderProgram,i=this._initTexture(),n=e.getUniformLocation(t,"ySampler");e.uniform1i(n,0),this.yTextureRef=i;var r=this._initTexture(),a=e.getUniformLocation(t,"uSampler");e.uniform1i(a,1),this.uTextureRef=r;var o=this._initTexture(),s=e.getUniformLocation(t,"vSampler");e.uniform1i(s,2),this.vTextureRef=o}},{key:"_initTexture",value:function(){var e=this.contextGL,t=e.createTexture();return e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.bindTexture(e.TEXTURE_2D,null),t}},{key:"_drawPictureGL",value:function(e,t,i,n,r){var a=n*i,o=r*i/2;444!==this.chroma&&422!==this.chroma||(o*=2);let s={yData:(e=new Uint8Array(e)).subarray(0,a),uData:e.subarray(a,a+o),vData:e.subarray(a+o,a+o+o)};this._drawPictureGL420(s,t,i,n,r)}},{key:"_drawPictureGL420",value:function(e,t,i,n,r){var a=this.contextGL,o=this.texturePosBuffer,s=this.uTexturePosBuffer,u=this.vTexturePosBuffer,l=this.yTextureRef,c=this.uTextureRef,f=this.vTextureRef,h=e.yData,d=e.uData,p=e.vData,y=n,m=i,v=t/2,g=i/2;422!==this.chroma&&444!==this.chroma||(g=i);var _=r,b=g;let E=this.canvas.width/this.width,w=this.canvas.height/this.height,k=0,T=0,A=this.canvas.width,S=this.canvas.height;E<w?(S=this.height*this.canvas.width/this.width,T=parseInt((this.canvas.height-this.height*this.canvas.width/this.width)/2)):(A=this.width*this.canvas.height/this.height,k=parseInt((this.canvas.width-this.width*this.canvas.height/this.height)/2)),a.viewport(k,T,A,S);var x=new Float32Array([1,0,0,0,1,1,0,1]);a.bindBuffer(a.ARRAY_BUFFER,o),a.bufferData(a.ARRAY_BUFFER,x,a.DYNAMIC_DRAW);var D=new Float32Array([1,0,0,0,1,1,0,1]);a.bindBuffer(a.ARRAY_BUFFER,s),a.bufferData(a.ARRAY_BUFFER,D,a.DYNAMIC_DRAW);var O=new Float32Array([1,0,0,0,1,1,0,1]);a.bindBuffer(a.ARRAY_BUFFER,u),a.bufferData(a.ARRAY_BUFFER,O,a.DYNAMIC_DRAW),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,l),a.texImage2D(a.TEXTURE_2D,0,a.LUMINANCE,y,m,0,a.LUMINANCE,a.UNSIGNED_BYTE,h),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,c),a.texImage2D(a.TEXTURE_2D,0,a.LUMINANCE,v,g,0,a.LUMINANCE,a.UNSIGNED_BYTE,d),a.activeTexture(a.TEXTURE2),a.bindTexture(a.TEXTURE_2D,f),a.texImage2D(a.TEXTURE_2D,0,a.LUMINANCE,_,b,0,a.LUMINANCE,a.UNSIGNED_BYTE,p),a.drawArrays(a.TRIANGLE_STRIP,0,4)}},{key:"_drawPictureRGB",value:function(e){}},{key:"render",value:function(e,t,i,n,r){this.contextGL?this._drawPictureGL(e,t,i,n,r):this._drawPictureRGB(e)}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.config=Object.assign({},t),this.type=this.config.type,this.buffer=[],this.currentGop=void 0,this._lastGet=void 0}return n(e,[{key:"push",value:function(e){if("video"===this.type){if(e.isKeyframe){let t={samples:[],start:e.dts,end:e.dts,nextGop:void 0};this.currentGop&&(this.currentGop.nextGop=t),this.currentGop=t,this.buffer.push(this.currentGop)}this.currentGop&&(this.currentGop.samples.push(e),e.dts<this.currentGop.start&&(this.currentGop.start=e.dts),e.dts>this.currentGop.end&&(this.currentGop.end=e.dts))}}},{key:"get",value:function(e){if("video"===this.type){if(this.buffer.length<1)return;if(void 0===e){return this._getNext()}}}},{key:"_getNext",value:function(){if(this._lastGet){let e=this._lastGet.gop,t=e.samples[this._lastGet.index+1];if(t)return this._lastGet.index=this._lastGet.index+1,t;if(!(e=e.nextGop)||e.samples.length<1)return;return t=e.samples[0],this._lastGet={gop:e,index:0},t}{let e=this.buffer[0];if(e.samples.length<1)return;return this._lastGet={gop:e,index:0},e.samples[0]}}},{key:"remove",value:function(e,t){if(this.buffer.length<0)return;let i=0,n=this.buffer[0];for(;n;)n.end<t&&n.start>=e?(this.buffer.splice(i,1),n=this.buffer[i]):(i+=1,n=this.buffer[i])}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.ranges=t||[]}return n(e,[{key:"start",value:function(e){return this.ranges[e]?this.ranges[e].start:0}},{key:"end",value:function(e){return this.ranges[e]?this.ranges[e].end:0}},{key:"add",value:function(e){this.ranges.push(e)}},{key:"length",get:function(){return this.ranges.length}}]),e}();t.default=r},function(e,t,i){"use strict";var n,r=function(e){this.inited=!1,this.self=e,this.meta=this.self.meta,this.infolist={},e.par_broadwayOnBroadwayInited=this.broadwayOnBroadwayInited.bind(this),e.par_broadwayOnPictureDecoded=this.broadwayOnPictureDecoded.bind(this)};function a(){(n=new r(this)).init()}function o(e){self.importScripts("https://sf1-vcloudcdn.pstatp.com/obj/ttfe/media/decoder/h264/decoder.js"),addOnPostRun(a.bind(self))}r.prototype.toU8Array=function(e,t){return this.self.HEAPU8.subarray(e,e+t)},r.prototype.init=function(){Module._broadwayInit(),this.streamBuffer=this.toU8Array(Module._broadwayCreateStream(1048576),1048576)},r.prototype.broadwayOnPictureDecoded=function(e,t,i,n,r,a){let o=Object.assign({},this.infolist[a]),s=i,u=i/2;444!==this.meta.chromaFormat&&422!==this.meta.chromaFormat||(u=i);let l=this.toU8Array(e,n*s+r*u*2);this.infolist[a]=null;let c=new Uint8Array(l.length);c.set(l);let f=c.buffer;this.self.postMessage({msg:"DECODED",width:t,height:i,yLinesize:n,uvLinesize:r,info:o,buffer:f},[f])},r.prototype.broadwayOnBroadwayInited=function(){this.inited=!0,this.self.postMessage({msg:"DECODER_READY"})},r.prototype.decode=function(e,t){let i=parseInt((new Date).getTime()),n=i-1e9*Math.floor(i/1e9);this.infolist[n]=t,this.streamBuffer.set(e),Module._broadwayPlayStream(e.length,n)},r.prototype.destroy=function(){Module._broadwayExit()},e.exports=function(e){e.addEventListener("message",(function(t){var i=t.data;if(i.msg)switch(i.msg){case"init":console.log(i),e.meta=i.meta,o();break;case"decode":n.decode(i.data,i.info);break;case"destory":n.destroy()}else e.postMessage({msg:"ERROR:invalid message"})}),!1)}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),a=i(7);let o=function(e){function t(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t);var i=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));i.config=Object.assign({},e);let n=window.AudioContext||window.webkitAudioContext;return i.context=new n,i.gainNode=i.context.createGain(),i.gainNode.connect(i.context.destination),i.meta=void 0,i.samples=[],i.preloadTime=i.config.preloadTime||3,i.duration=0,i._currentBuffer=void 0,i._nextBuffer=void 0,i._lastpts=void 0,i._preDecode=[],i._currentTime=0,i._decoding=!1,i._volume=i.config.volume||.6,i._played=!1,i.playFinish=null,i.waitNextID=null,i}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(t,e),r(t,[{key:"decodeAudio",value:function(e){let{samples:t}=e,i=t;e.samples=[],this.setAudioData(i)}},{key:"setAudioData",value:function(e){for(let t=0;t<e.length;t++)e[t].pts=void 0===e[t].pts?e[t].dts:e[t].pts,this._preDecode.push(e[t]);this._preDecode.length>0&&(void 0===this._lastpts&&(this._lastpts=this._preDecode[0].pts),(this._preDecode[this._preDecode.length-1].pts-this._lastpts)/1e3>this.preloadTime&&this.decodeAAC())}},{key:"decodeAAC",value:function(){if(this._decoding)return;this._decoding=!0;let e=this._preDecode,i=[],n=this,r=e.shift();for(;r;){let n=t.getAACData(this.meta,r);i.push(n),this._lastpts=r.pts,r=e.shift()}let a=t.combileData(i);try{this.context.decodeAudioData(a.buffer,(function(e){let t=n.context.createBufferSource();t.buffer=e,n.samples.push({time:n.duration,duration:e.duration,data:t}),n.duration+=e.duration,n._currentBuffer||(n._currentBuffer=n.getTimeBuffer(n.currentTime)),!n._nextBuffer&&n._currentBuffer&&(n._nextBuffer=n.getTimeBuffer(n.currentTime+n._currentBuffer.duration)),n._decoding=!1,(n._preDecode.length>0&&n._preDecode[n._preDecode.length-1].pts-n._lastpts)/1e3>=n.preloadTime&&n.decodeAAC(),n.playFinish&&n.playFinish()}),e=>{console.error(e)})}catch(e){console.error(e)}}},{key:"onSourceEnded",value:function(){if(!this._nextBuffer||!this._played)return void(this.waitNextID=setTimeout(()=>{this.onSourceEnded()},200));let e=this._nextBuffer.data;e.start(),e.connect(this.gainNode);let t=this;setTimeout(()=>{t.onSourceEnded.call(this)},1e3*e.buffer.duration-10),this._currentBuffer=this._nextBuffer,this._currentTime=this._currentBuffer.time,this._nextBuffer=this.getTimeBuffer(this.currentTime),this._currentBuffer&&(this._nextBuffer=this.getTimeBuffer(this.currentTime+this._currentBuffer.duration)),this.emit("AUDIO_SOURCE_END")}},{key:"play",value:function(){if(this.playFinish)return;this._played=!0,"suspended"===this.context.state&&this.context.resume();let e=this;const t=()=>{let t=this._currentBuffer.data;t.connect(this.gainNode),t.start(),setTimeout(()=>{e.onSourceEnded.call(this)},1e3*t.buffer.duration-10)};return this._currentBuffer?(t(),Promise.resolve()):new Promise(e=>{this.playFinish=e}).then(()=>{this.playFinish=null,t()})}},{key:"pause",value:function(){const e=this.context;"running"===e.state&&e.suspend()}},{key:"getTimeBuffer",value:function(e){let t;for(let i=0;i<this.samples.length;i++){let n=this.samples[i];if(n.time<=e&&n.time+n.duration>e){t=n;break}}return t}},{key:"setAudioMetaData",value:function(e){this.meta=e}},{key:"destroy",value:function(){this.waitNextID&&window.clearTimeout(this.waitNextID),this.context.close()}},{key:"currentTime",get:function(){return this._currentTime}},{key:"muted",set:function(e){this.gainNode.gain.value=e?0:this._volume}},{key:"volume",get:function(){return this._volume},set:function(e){return e<0?(this._volume=0,void(this.gainNode.gain.value=0)):e>1?(this._volume=1,void(this.gainNode.gain.value=1)):(this._volume=e,void(this.gainNode.gain.value=e))}}],[{key:"getAACData",value:function(e,i){let n=new Uint8Array(i.data.byteLength+7),r=t.getAdts(e,i.data);return n.set(r),n.set(i.data,7),n}},{key:"combileData",value:function(e){let t=0;for(let i=0,n=e.length;i<n;i++)t+=e[i].byteLength;let i=new Uint8Array(t),n=0;for(let t=0,r=e.length;t<r;t++)i.set(e[t],n),n+=e[t].byteLength;return i}},{key:"getAdts",value:function(e,t){let i=new Uint8Array(7);i[0]=255,i[1]=240,i[1]=1|i[1],i[2]=192&e.objectType-1<<6,i[2]=i[2]|60&e.sampleRateIndex<<2,i[2]=i[2]|1&e.channelCount>>2,i[3]=192&e.channelCount<<6;let n=t.byteLength+7;return i[3]=i[3]|3&n>>11,i[4]=255&n>>3,i[5]=224&n<<5,i[5]=31|i[5],i[6]=252,i}}]),t}(((n=a)&&n.__esModule?n:{default:n}).default);t.default=o},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function e(t,i,n){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,i);if(void 0===r){var a=Object.getPrototypeOf(t);return null===a?void 0:e(a,i,n)}if("value"in r)return r.value;var o=r.get;return void 0!==o?o.call(n):void 0},r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function o(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function s(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}let u=function(){function e(t){s(this,e),this.options=Object.assign({},t||{},{interval:16}),this.callbacks=[]}return r(e,[{key:"start",value:function(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];this.callbacks=t}},{key:"onTick",value:function(){for(let e=0,t=this.callbacks.length;e<t;e++){(0,this.callbacks[e])()}}},{key:"setInterval",value:function(e){return this.options.interval=e,this}}]),e}(),l=function(e){function t(e){s(this,t);var i=a(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return i.prev=null,i.timerId=null,i._subTimerId=null,i._tickFunc=t.getTickFunc(),i.tick=i.tick.bind(i),i}return o(t,e),r(t,[{key:"start",value:function(){for(var e,i=arguments.length,r=Array(i),a=0;a<i;a++)r[a]=arguments[a];(e=n(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"start",this)).call.apply(e,[this].concat(r)),this.tick()}},{key:"tick",value:function(){this.nextTick(),this.onTick()}},{key:"nextTick",value:function(){const{_tickFunc:e}=this;this.timerId=e(this.tick)}},{key:"stop",value:function(){if(this.timerId){t.getCancelFunc()(this.timerId)}}},{key:"resume",value:function(){this.nextTick()}}],[{key:"getTickFunc",value:function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame}},{key:"getCancelFunc",value:function(){return window.cancelAnimationFrame||window.webkitCancelAnimationFrame}},{key:"isSupported",value:function(){return void 0!==t.getTickFunc()}}]),t}(u),c=function(e){function t(e){s(this,t);var i=a(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return i.timeoutId=null,i}return o(t,e),r(t,[{key:"start",value:function(){for(var e,i=arguments.length,r=Array(i),a=0;a<i;a++)r[a]=arguments[a];(e=n(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"nextTick",this)).call.apply(e,[this].concat(r)),this.timeoutId=window.setInterval(()=>{this.onTick()},this.options.interval||16)}},{key:"stop",value:function(){this.timeoutId&&window.clearInterval(this.timeoutId)}}]),t}(u);t.getTicker=()=>l.isSupported()?l:c},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),a=i(2);const o=((n=a)&&n.__esModule?n:{default:n}).default.CRYTO_EVENTS;let s=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.inputBuffer=t.inputbuffer,this.outputBuffer=t.outputbuffer,this.key=t.key,this.iv=t.iv,this.method=t.method,this.crypto=window.crypto||window.msCrypto}return r(e,[{key:"init",value:function(){this.on(o.START_DECRYPT,this.decript.bind(this))}},{key:"decript",value:function(){if(this.aeskey)this.decriptData();else{this.crypto.subtle.importKey("raw",this.key.buffer,{name:"AES-CBC"},!1,["encrypt","decrypt"]).then(e=>{this.aeskey=e,this.decriptData()})}}},{key:"decriptData",value:function(){let e=this._context.getInstance(this.inputBuffer),t=this._context.getInstance(this.outputBuffer),i=e.shift();i&&this.crypto.subtle.decrypt({name:"AES-CBC",iv:this.iv.buffer},this.aeskey,i).then(e=>{t.push(new Uint8Array(e)),this.emit(o.DECRYPTED),this.decriptData(i)})}}]),e}();t.default=s},function(e,t,i){"use strict";e.exports={Mp4Remuxer:i(39).default}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),a=i(0),o=i(40),s=(n=o)&&n.__esModule?n:{default:n};const u=a.EVENTS.REMUX_EVENTS;let l=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this._dtsBase=0,this._isDtsBaseInited=!1,this.isFirstVideo=!0,this.isFirstAudio=!0,this.videoAllDuration=0,this.audioAllDuration=0}return r(e,[{key:"init",value:function(){this.on(u.REMUX_MEDIA,this.remux.bind(this)),this.on(u.REMUX_METADATA,this.onMetaDataReady.bind(this)),this.on(u.DETECT_CHANGE_STREAM,this.resetDtsBase.bind(this))}},{key:"destroy",value:function(){this._dtsBase=-1,this._dtsBaseInited=!1}},{key:"reset",value:function(){this._dtsBase=0,this._isDtsBaseInited=!1}},{key:"remux",value:function(){const{audioTrack:e,videoTrack:t}=this._context.getInstance("TRACKS");!this._isDtsBaseInited&&this.calcDtsBase(e,t),this._remuxVideo(t),this._remuxAudio(e)}},{key:"resetDtsBase",value:function(){this._dtsBase=0,this._dtsBaseInited=!1}},{key:"seek",value:function(){}},{key:"onMetaDataReady",value:function(e){let t;if("audio"===e){const{audioTrack:e}=this._context.getInstance("TRACKS");t=e}else{const{videoTrack:e}=this._context.getInstance("TRACKS");t=e}let i=this._context.getInstance("PRE_SOURCE_BUFFER"),n=i.getSource(e);n||(n=i.createSource(e)),n.mimetype=t.meta.codec,n.init=this.remuxInitSegment(e,t.meta),this.emit(u.INIT_SEGMENT,e)}},{key:"remuxInitSegment",value:function(e,t){let i=new a.Buffer,n=s.default.ftyp(),r=s.default.moov({type:e,meta:t});return i.write(n,r),i}},{key:"calcDtsBase",value:function(e,t){if(!e.samples.length&&!t.samples.length)return;let i=1/0,n=1/0;e.samples&&e.samples.length&&(i=e.samples[0].dts),t.samples&&t.samples.length&&(n=t.samples[0].dts),this._dtsBase=Math.min(i,n),this._isDtsBaseInited=!0}},{key:"_remuxVideo",value:function(e){const t=e;if(!e.samples||!e.samples.length)return;let{samples:i}=t,n=-1,r=null;const o=[],l={samples:[]};for(;i.length;){const e=i.shift(),{isKeyframe:t,options:a}=e;if(!this.isFirstAudio&&a&&a.meta){r=this.remuxInitSegment("video",a.meta),a.meta=null,i.unshift(e),a.isContinue||this.resetDtsBase();break}let s,u,c=e.dts-this._dtsBase;-1===n&&(n=c),void 0!==e.pts&&(s=(u=e.pts-this._dtsBase)-c),void 0!==e.cts&&(u=e.cts+c,s=e.cts);let f={buffer:[],size:0};l.samples.push(f),f.buffer.push(e.data),f.size+=e.data.byteLength;let h=0;if(i.length>=1){h=i[0].dts-this._dtsBase-c}else h=o.length>=1?o[o.length-1].duration:this.videoMeta.refSampleDuration;this.videoAllDuration+=h,o.push({dts:c,cts:s,pts:u,data:e.data,size:e.data.byteLength,isKeyframe:t,duration:h,flags:{isLeading:0,dependsOn:t?2:1,isDependedOn:t?1:0,hasRedundancy:0,isNonSync:t?0:1},originDts:c,type:"video"})}let c=new a.Buffer;if(o.length){const e=s.default.moof({id:t.meta.id,time:n,samples:o}),i=s.default.mdat(l);c.write(e,i),this.writeToSource("video",c)}if(r&&(this.writeToSource("video",r),i.length))return t.samples=i,this._remuxVideo(t);this.isFirstVideo=!1,this.emit(u.MEDIA_SEGMENT,"video");const f=o[o.length-1];this._videoNextDts=f.dts+f.duration,t.samples=[],t.length=0}},{key:"_remuxAudio",value:function(e){const{samples:t}=e;let i=-1,n=[],r=null;const o={samples:[]};if(!t||!t.length)return;let l=!1;for(;t.length;){let e=t.shift();const{data:a,options:s}=e;if(!this.isFirstAudio&&s&&s.meta){r=this.remuxInitSegment("audio",s.meta),s.meta=null,t.unshift(e),s.isContinue||this.resetDtsBase();break}let u=e.dts-this._dtsBase;const c=u;l||(i=u,l=!0);let f=0;if(this.audioMeta.refSampleDurationFixed)f=this.audioMeta.refSampleDurationFixed;else if(t.length>=1){f=t[0].dts-this._dtsBase-u}else f=n.length>=1?n[n.length-1].duration:this.audioMeta.refSampleDuration;this.audioAllDuration+=f;const h={dts:u,pts:u,cts:0,size:a.byteLength,duration:e.duration?e.duration:f,flags:{isLeading:0,dependsOn:2,isDependedOn:1,hasRedundancy:0,isNonSync:0},isKeyframe:!0,originDts:c,type:"audio"};let d={buffer:[],size:0};d.buffer.push(a),d.size+=a.byteLength,o.samples.push(d),n.push(h)}const c=new a.Buffer;if(n.length){const t=s.default.moof({id:e.meta.id,time:i,samples:n}),r=s.default.mdat(o);c.write(t,r),this.writeToSource("audio",c)}if(r&&(this.writeToSource("audio",r),t.length))return e.samples=t,this._remuxAudio(e);this.isFirstAudio=!1,this.emit(u.MEDIA_SEGMENT,"audio",c);const f=n[n.length-1];this._videoNextDts=f.dts+f.duration,e.samples=[],e.length=0}},{key:"writeToSource",value:function(e,t){let i=this._context.getInstance("PRE_SOURCE_BUFFER"),n=i.getSource(e);n||(n=i.createSource(e)),n.data.push(t)}},{key:"initSilentAudio",value:function(t,i){const n=e.getSilentFrame(this.audioMeta.channelCount);return{dts:t,pts:t,cts:0,duration:i,unit:n,size:n.byteLength,originDts:t,type:"video"}}},{key:"videoMeta",get:function(){return this._context.getInstance("TRACKS").videoTrack.meta}},{key:"audioMeta",get:function(){return this._context.getInstance("TRACKS").audioTrack.meta}}],[{key:"getSilentFrame",value:function(e){return 1===e?new Uint8Array([0,200,0,128,35,128]):2===e?new Uint8Array([33,0,73,144,2,25,0,35,128]):3===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,142]):4===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,128,44,128,8,2,56]):5===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,56]):6===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,0,178,0,32,8,224]):null}}]),e}();t.default=l},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),r=i(0);let a=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)}return n(e,null,[{key:"size",value:function(e){return r.Buffer.writeUint32(e)}},{key:"initBox",value:function(t,i){const n=new r.Buffer;for(var a=arguments.length,o=Array(a>2?a-2:0),s=2;s<a;s++)o[s-2]=arguments[s];return n.write.apply(n,[e.size(t),e.type(i)].concat(o)),n.buffer}},{key:"extension",value:function(e,t){return new Uint8Array([e,t>>16&255,t>>8&255,255&t])}},{key:"ftyp",value:function(){return e.initBox(24,"ftyp",new Uint8Array([105,115,111,109,0,0,0,1,105,115,111,109,97,118,99,49]))}},{key:"moov",value:function(t){let i,{type:n,meta:r}=t,a=8,o=e.mvhd(r.duration,r.timescale);i="video"===n?e.videoTrak(r):e.audioTrak(r);let s=e.mvex(r.duration,r.timescale||1e3,r.id);return[o,i,s].forEach(e=>{a+=e.byteLength}),e.initBox(a,"moov",o,i,s)}},{key:"mvhd",value:function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3,n=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,i>>>24&255,i>>>16&255,i>>>8&255,255&i,t>>>24&255,t>>>16&255,t>>>8&255,255&t,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255]);return e.initBox(8+n.length,"mvhd",new Uint8Array(n))}},{key:"videoTrak",value:function(t){let i=8,n=e.tkhd({id:1,duration:t.duration,timescale:t.timescale||1e3,width:t.presentWidth,height:t.presentHeight,type:"video"}),r=e.mdia({type:"video",timescale:t.timescale||1e3,duration:t.duration,avcc:t.avcc,parRatio:t.parRatio,width:t.presentWidth,height:t.presentHeight});return[n,r].forEach(e=>{i+=e.byteLength}),e.initBox(i,"trak",n,r)}},{key:"audioTrak",value:function(t){let i=8,n=e.tkhd({id:2,duration:t.duration,timescale:t.timescale||1e3,width:0,height:0,type:"audio"}),r=e.mdia({type:"audio",timescale:t.timescale||1e3,duration:t.duration,channelCount:t.channelCount,samplerate:t.sampleRate,config:t.config});return[n,r].forEach(e=>{i+=e.byteLength}),e.initBox(i,"trak",n,r)}},{key:"tkhd",value:function(t){let i=t.id,n=t.duration,r=t.width,a=t.height,o=new Uint8Array([0,0,0,7,0,0,0,0,0,0,0,0,i>>>24&255,i>>>16&255,i>>>8&255,255&i,0,0,0,0,n>>>24&255,n>>>16&255,n>>>8&255,255&n,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,r>>>8&255,255&r,0,0,a>>>8&255,255&a,0,0]);return e.initBox(8+o.byteLength,"tkhd",o)}},{key:"edts",value:function(t){let i=new r.Buffer,n=t.duration,a=t.mediaTime;return i.write(e.size(36),e.type("edts")),i.write(e.size(28),e.type("elst")),i.write(new Uint8Array([0,0,0,1,n>>24&255,n>>16&255,n>>8&255,255&n,a>>24&255,a>>16&255,a>>8&255,255&a,0,0,0,1])),i.buffer}},{key:"mdia",value:function(t){let i=8,n=e.mdhd(t.timescale,t.duration),r=e.hdlr(t.type),a=e.minf(t);return[n,r,a].forEach(e=>{i+=e.byteLength}),e.initBox(i,"mdia",n,r,a)}},{key:"mdhd",value:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3,i=arguments[1],n=new Uint8Array([0,0,0,0,0,0,0,0,t>>>24&255,t>>>16&255,t>>>8&255,255&t,i>>>24&255,i>>>16&255,i>>>8&255,255&i,85,196,0,0]);return e.initBox(12+n.byteLength,"mdhd",e.extension(0,0),n)}},{key:"hdlr",value:function(t){let i=[0,0,0,0,0,0,0,0,118,105,100,101,0,0,0,0,0,0,0,0,0,0,0,0,86,105,100,101,111,72,97,110,100,108,101,114,0];return"audio"===t&&(i.splice.apply(i,[8,4].concat([115,111,117,110])),i.splice.apply(i,[24,13].concat([83,111,117,110,100,72,97,110,100,108,101,114,0]))),e.initBox(8+i.length,"hdlr",new Uint8Array(i))}},{key:"minf",value:function(t){let i=8,n="video"===t.type?e.vmhd():e.smhd(),r=e.dinf(),a=e.stbl(t);return[n,r,a].forEach(e=>{i+=e.byteLength}),e.initBox(i,"minf",n,r,a)}},{key:"vmhd",value:function(){return e.initBox(20,"vmhd",new Uint8Array([0,0,0,1,0,0,0,0,0,0,0,0]))}},{key:"smhd",value:function(){return e.initBox(16,"smhd",new Uint8Array([0,0,0,0,0,0,0,0]))}},{key:"dinf",value:function(){let t=new r.Buffer;return t.write(e.size(36),e.type("dinf"),e.size(28),e.type("dref"),new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,12,117,114,108,32,0,0,0,1])),t.buffer}},{key:"stbl",value:function(t){let i=8,n=e.stsd(t),r=e.stts(),a=e.stsc(),o=e.stsz(),s=e.stco();return[n,r,a,o,s].forEach(e=>{i+=e.byteLength}),e.initBox(i,"stbl",n,r,a,o,s)}},{key:"stsd",value:function(t){let i;return i="audio"===t.type?e.mp4a(t):e.avc1(t),e.initBox(16+i.byteLength,"stsd",e.extension(0,0),new Uint8Array([0,0,0,1]),i)}},{key:"mp4a",value:function(t){let i=new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,t.channelCount,0,16,0,0,0,0,t.samplerate>>8&255,255&t.samplerate,0,0]),n=e.esds(t.config);return e.initBox(8+i.byteLength+n.byteLength,"mp4a",i,n)}},{key:"esds",value:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[43,146,8,0];const i=t.length;let n=new r.Buffer,a=new Uint8Array([0,0,0,0,3,23+i,0,1,0,4,15+i,64,21,0,0,0,0,0,0,0,0,0,0,0,5].concat([i]).concat(t).concat([6,1,2]));return n.write(e.size(8+a.byteLength),e.type("esds"),a),n.buffer}},{key:"avc1",value:function(t){let i=new r.Buffer,n=t.width,a=t.height,o=t.parRatio.height,s=t.parRatio.width,u=t.avcc,l=new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,n>>8&255,255&n,a>>8&255,255&a,0,72,0,0,0,72,0,0,0,0,0,0,0,1,18,100,97,105,108,121,109,111,116,105,111,110,47,104,108,115,46,106,115,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,17,17]),c=new Uint8Array([0,28,156,128,0,45,198,192,0,45,198,192]),f=new Uint8Array([o>>24,o>>16&255,o>>8&255,255&o,s>>24,s>>16&255,s>>8&255,255&s]);return i.write(e.size(40+l.byteLength+u.byteLength+c.byteLength),e.type("avc1"),l,e.size(8+u.byteLength),e.type("avcC"),u,e.size(20),e.type("btrt"),c,e.size(16),e.type("pasp"),f),i.buffer}},{key:"stts",value:function(){let t=new Uint8Array([0,0,0,0,0,0,0,0]);return e.initBox(16,"stts",t)}},{key:"stsc",value:function(){let t=new Uint8Array([0,0,0,0,0,0,0,0]);return e.initBox(16,"stsc",t)}},{key:"stco",value:function(){let t=new Uint8Array([0,0,0,0,0,0,0,0]);return e.initBox(16,"stco",t)}},{key:"stsz",value:function(){let t=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0]);return e.initBox(20,"stsz",t)}},{key:"mvex",value:function(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1];let i=arguments[2],n=new r.Buffer,a=r.Buffer.writeUint32(t);return n.write(e.size(56),e.type("mvex"),e.size(16),e.type("mehd"),e.extension(0,0),a,e.trex(i)),n.buffer}},{key:"trex",value:function(t){let i=new Uint8Array([0,0,0,0,t>>24,t>>16&255,t>>8&255,255&t,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1]);return e.initBox(8+i.byteLength,"trex",i)}},{key:"moof",value:function(t){let i=8,n=e.mfhd(),r=e.traf(t);return[n,r].forEach(e=>{i+=e.byteLength}),e.initBox(i,"moof",n,r)}},{key:"mfhd",value:function(){let t=r.Buffer.writeUint32(e.sequence);return e.sequence+=1,e.initBox(16,"mfhd",e.extension(0,0),t)}},{key:"traf",value:function(t){let i=8,n=e.tfhd(t.id),r=e.tfdt(t.time),a=e.sdtp(t),o=e.trun(t,a.byteLength);return[n,r,o,a].forEach(e=>{i+=e.byteLength}),e.initBox(i,"traf",n,r,o,a)}},{key:"tfhd",value:function(t){let i=r.Buffer.writeUint32(t);return e.initBox(16,"tfhd",e.extension(0,0),i)}},{key:"tfdt",value:function(t){return e.initBox(16,"tfdt",e.extension(0,0),r.Buffer.writeUint32(t))}},{key:"trun",value:function(t,i){let n=new r.Buffer,a=r.Buffer.writeUint32(t.samples.length),o=r.Buffer.writeUint32(92+16*t.samples.length+i);return n.write(e.size(20+16*t.samples.length),e.type("trun"),new Uint8Array([0,0,15,1]),a,o),t.samples.forEach(e=>{const t=e.flags;n.write(new Uint8Array([e.duration>>>24&255,e.duration>>>16&255,e.duration>>>8&255,255&e.duration,e.size>>>24&255,e.size>>>16&255,e.size>>>8&255,255&e.size,t.isLeading<<2|t.dependsOn,t.isDependedOn<<6|t.hasRedundancy<<4|t.isNonSync,0,0,e.cts>>>24&255,e.cts>>>16&255,e.cts>>>8&255,255&e.cts]))}),n.buffer}},{key:"sdtp",value:function(t){let i=new r.Buffer;return i.write(e.size(12+t.samples.length),e.type("sdtp"),e.extension(0,0)),t.samples.forEach(e=>{const t=e.flags,n=t.isLeading<<6|t.dependsOn<<4|t.isDependedOn<<2|t.hasRedundancy;i.write(new Uint8Array([n]))}),i.buffer}},{key:"mdat",value:function(t){let i=new r.Buffer,n=8;t.samples.forEach(e=>{n+=e.size}),i.write(e.size(n),e.type("mdat"));let a=new Uint8Array(n),o=0;return a.set(i.buffer,o),o+=8,t.samples.forEach(e=>{e.buffer.forEach(e=>{a.set(e,o),o+=e.byteLength})}),a}}]),e}();a.type=e=>new Uint8Array([e.charCodeAt(0),e.charCodeAt(1),e.charCodeAt(2),e.charCodeAt(3)]),a.sequence=1,t.default=a},function(e,t,i){"use strict";e.exports={FetchLoader:i(42).default}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();const r=i(0).EVENTS.LOADER_EVENTS;let a=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.configs=Object.assign({},t),this.url=null,this.status=0,this.error=null,this._reader=null,this._canceled=!1,this._destroyed=!1,this.readtype=this.configs.readtype,this.buffer=this.configs.buffer||"LOADER_BUFFER",this._loaderTaskNo=0}return n(e,[{key:"init",value:function(){this.on(r.LADER_START,this.load.bind(this))}},{key:"load",value:function(e,t){let i=this;this.url=e,this._canceled=!1;let n=this.getParams(t);return i.loading=!0,fetch(this.url,n).then((function(e){if(e.ok)return i.status=e.status,i._onFetchResponse(e);i.loading=!1,i.emit(r.LOADER_ERROR,i.TAG,new Error("invalid response."))})).catch((function(e){throw i.loading=!1,i.emit(r.LOADER_ERROR,i.TAG,e),new Error(e.message)}))}},{key:"_onFetchResponse",value:function(e){let t=this,i=this._context.getInstance(this.buffer);this._loaderTaskNo++;let n=this._loaderTaskNo;if(!0===e.ok)switch(this.readtype){case 2:e.json().then(e=>{t.loading=!1,t._canceled||t._destroyed||(i?(i.push(e),t.emit(r.LOADER_COMPLETE,i)):t.emit(r.LOADER_COMPLETE,e))});break;case 1:e.text().then(e=>{t.loading=!1,t._canceled||t._destroyed||(i?(i.push(e),t.emit(r.LOADER_COMPLETE,i)):t.emit(r.LOADER_COMPLETE,e))});break;case 3:e.arrayBuffer().then(e=>{t.loading=!1,t._canceled||t._destroyed||(i?(i.push(new Uint8Array(e)),t.emit(r.LOADER_COMPLETE,i)):t.emit(r.LOADER_COMPLETE,e))});break;case 0:default:return this._onReader(e.body.getReader(),n)}}},{key:"_onReader",value:function(e,t){let i=this._context.getInstance(this.buffer);if(!i&&this._reader||this._destroyed)try{this._reader.cancel()}catch(e){}if(this._reader=e,!1===this.loading)return;let n=this;this._reader&&this._reader.read().then((function(a){if(a.done)return n.loading=!1,n.status=0,void n.emit(r.LOADER_COMPLETE,i);if(!n._canceled&&!n._destroyed)return i.push(a.value),n.emit(r.LOADER_DATALOADED,i),n._onReader(e,t);if(n._reader)try{n._reader.cancel()}catch(e){}})).catch(e=>{n.loading=!1,n.emit(r.LOADER_ERROR,n.TAG,e)})}},{key:"getParams",value:function(e){let t=Object.assign({},e),i=new Headers,n={method:"GET",headers:i,mode:"cors",cache:"default"};if("object"==typeof this.configs.headers){let e=this.configs.headers;for(let t in e)e.hasOwnProperty(t)&&i.append(t,e[t])}if("object"==typeof t.headers){let e=t.headers;for(let t in e)e.hasOwnProperty(t)&&i.append(t,e[t])}return!1===t.cors&&(n.mode="same-origin"),t.withCredentials&&(n.credentials="include"),n}},{key:"cancel",value:function(){if(this._reader){try{this._reader.cancel()}catch(e){}this._reader=null,this.loading=!1,this._canceled=!0}}},{key:"destroy",value:function(){this._destroyed=!0,this.cancel()}}],[{key:"type",get:function(){return"loader"}}]),e}();t.default=a},function(e,t,i){"use strict";e.exports={M3U8Parser:i(44).default,TsDemuxer:i(45).default,Playlist:i(49).default,FlvDemuxer:i(50).default}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)}return n(e,null,[{key:"parse",value:function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n={duration:0};if(!t||!t.split)return;let r=t.split(/\r|\n/),a=(r=r.filter(e=>e)).shift();if(!a.match("#EXTM3U"))throw new Error('Invalid m3u8 file: not "#EXTM3U"');for(a=r.shift();a;){let t=a.match(/#(.[A-Z|-]*):(.*)/),o=a.match(/#(.[A-Z|-]*)/);if(o&&t&&t.length>2)switch(t[1]){case"EXT-X-VERSION":n.version=parseInt(t[2]);break;case"EXT-X-MEDIA-SEQUENCE":n.sequence=parseInt(t[2]);break;case"EXT-X-TARGETDURATION":n.targetduration=parseFloat(t[2]);break;case"EXTINF":e.parseFrag(t,r,n,i);break;case"EXT-X-KEY":e.parseDecrypt(t[2],n)}if(o&&o.length>1)switch(o[1]){case"EXT-X-DISCONTINUITY":let t=(a=r.shift()).match(/#(.[A-Z|-]*):(.*)/);t.length>2&&"EXTINF"===t[1]&&e.parseFrag(t,r,n,i,!0)}a=r.shift()}return n}},{key:"parseFrag",value:function(e,t,i,n,r){i.frags||(i.frags=[]);let a={start:i.duration,duration:1e3*parseFloat(e[2])};i.duration+=a.duration;let o=t.shift();o.match(/#(.*):(.*)/)&&(o=t.shift()),o.length>0&&"/"===o.charAt(0)&&n.match(/.*\/\/.*\.\w+/g)&&(n=n.match(/.*\/\/.*\.\w+/g)[0]),o.match(/.*:\/\/.*/)?a.url=o:a.url=n+o,a.discontinue=r,i.frags.push(a)}},{key:"parseURL",value:function(e){let t="",i=e.match(/(.*\/).*\.m3u8/);if(i&&i.length>0)for(let e=0;e<i.length;e++)i[e].match(/.*\/$/g)&&i[e].length>t.length&&(t=i[e]);return t}},{key:"parseDecrypt",value:function(e,t){t.encrypt={};let i=e.split(",");for(let e in i){let n=i[e];if(n.match(/METHOD=(.*)/)&&(t.encrypt.method=n.match(/METHOD=(.*)/)[1]),n.match(/URI="(.*)"/)&&(t.encrypt.uri=n.match(/URI="(.*)"/)[1]),n.match(/IV=0x(.*)/)){let e=n.match(/IV=0x(.*)/)[1],i=Math.ceil(e.length/2);t.encrypt.ivb=new Uint8Array(i);for(let n=i-1;n>=0;n--){let i=parseInt(e.substr(2*n,2),16);t.encrypt.ivb[n]=i}t.encrypt.iv=e}}}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),r=i(3),a=i(4),o=i(0);const s=o.EVENTS.DEMUX_EVENTS,u={1:["video","MPEG-1"],2:["video","MPEG-2"],27:["video","AVC.H264"],234:["video","VC-1"],3:["audio","MPEG-1"],4:["audio","MPEG-2"],15:["audio","MPEG-2.AAC"],17:["audio","MPEG-4.AAC"],128:["audio","LPCM"],129:["audio","AC3"],6:["audio","AC3"],130:["audio","DTS"],131:["audio","Dolby TrueHD"],132:["audio","AC3-Plus"],133:["audio","DTS-HD"],134:["audio","DTS-MA"],161:["audio","AC3-Plus-SEC"],162:["audio","DTS-HD-SEC"]};let l=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.configs=Object.assign({},t),this.demuxing=!1,this.pat=[],this.pmt=[],this._hasVideoMeta=!1,this._hasAudioMeta=!1}return n(e,[{key:"init",value:function(){this.on(s.DEMUX_START,this.demux.bind(this))}},{key:"demux",value:function(t){if(this.demuxing)return;let i=this.inputBuffer,n={pat:[],pmt:[]},r={};for(;i.length>=188;){for(i.length>=1&&71!==i.array[0][i.offset]&&this.emit(s.DEMUX_ERROR,this.TAG,new Error(`Untrust sync code: ${i.array[0][i.offset]}, try to recover;`),!1);i.length>=1&&71!==i.array[0][i.offset];)i.shift(1);let t=i.shift(188),a=new o.Stream(t.buffer),u={};e.read(a,u,n),u.pes?(r[u.header.pid]||(r[u.header.pid]=[]),r[u.header.pid].push(u.pes),u.pes.ES.buffer=[u.pes.ES.buffer]):r[u.header.pid]&&r[u.header.pid][r[u.header.pid].length-1].ES.buffer.push(u.payload.stream)}let a=t,u=t;for(let t=0;t<Object.keys(r).length;t++){let i=r[Object.keys(r)[t]];for(let n=0;n<i.length;n++)i[n].id=Object.keys(r)[t],i[n].ES.buffer=e.Merge(i[n].ES.buffer),"audio"===i[n].type?(this.pushAudioSample(i[n],a),a={}):"video"===i[n].type&&(this.pushVideoSample(i[n],u),u={})}this._hasAudioMeta&&this.emit(s.DEMUX_COMPLETE,"audio"),this._hasVideoMeta&&this.emit(s.DEMUX_COMPLETE,"video")}},{key:"pushAudioSample",value:function(t,i){let n;this._tracks.audioTrack?n=this._tracks.audioTrack:(this._tracks.audioTrack=new a.AudioTrack,n=this._tracks.audioTrack);let r=new o.AudioTrackMeta({audioSampleRate:t.ES.frequence,sampleRate:t.ES.frequence,channelCount:t.ES.channel,codec:"mp4a.40."+t.ES.audioObjectType,config:t.ES.audioConfig,id:2,sampleRateIndex:t.ES.frequencyIndex});r.refSampleDuration=Math.floor(1024/r.audioSampleRate*r.timescale);let u=e.compaireMeta(n.meta,r,!0);this._hasAudioMeta&&u||(n.meta=r,this._hasAudioMeta=!0,this.emit(s.METADATA_PARSED,"audio"));let l=new Uint8Array(t.ES.buffer.buffer.slice(t.ES.buffer.position,t.ES.buffer.length)),c=parseInt(t.pts/90),f=parseInt(t.pts/90),h=new o.AudioTrackSample({dts:c,pts:f,data:l,options:i});n.samples.push(h)}},{key:"pushVideoSample",value:function(t,i){let n,u=r.Nalunit.getNalunits(t.ES.buffer),l=new o.VideoTrackMeta;this._tracks.videoTrack?n=this._tracks.videoTrack:(this._tracks.videoTrack=new a.VideoTrack,n=this._tracks.videoTrack);let c=0,f=!1,h=!1;for(let e=0;e<u.length;e++){let t=u[e];if(t.sps){f=t,n.sps=t.body,l.chromaFormat=f.sps.chroma_format,l.codec="avc1.";for(var d=1;d<4;d++){var p=f.body[d].toString(16);p.length<2&&(p="0"+p),l.codec+=p}l.codecHeight=f.sps.codec_size.height,l.codecWidth=f.sps.codec_size.width,l.frameRate=f.sps.frame_rate,l.id=1,l.level=f.sps.level_string,l.presentHeight=f.sps.present_size.height,l.presentWidth=f.sps.present_size.width,l.profile=f.sps.profile_string,l.refSampleDuration=Math.floor(l.timescale*(f.sps.frame_rate.fps_den/f.sps.frame_rate.fps_num)),l.sarRatio=f.sps.sar_ratio?f.sps.sar_ratio:f.sps.par_ratio}else t.pps?(n.pps=t.body,h=t):c+=4+t.body.byteLength}if(f&&h){l.avcc=r.Nalunit.getAvcc(f.body,h.body);let t=e.compaireMeta(n.meta,l,!0);this._hasVideoMeta&&t||(i?i.meta=Object.assign({},l):i={meta:Object.assign({},l)},n.meta=l,this._hasVideoMeta=!0,this.emit(s.METADATA_PARSED,"video"))}let y=new Uint8Array(c),m=0,v=!1;for(let e=0;e<u.length;e++){let t=u[e],i=t.body.byteLength;t.idr&&(v=!0),t.pps||t.sps||(y.set(new Uint8Array([i>>>24&255,i>>>16&255,i>>>8&255,255&i]),m),m+=4,y.set(t.body,m),m+=i)}let g=new o.VideoTrackSample({dts:parseInt(t.dts/90),pts:parseInt(t.pts/90),cts:(t.pts-t.dts)/90,originDts:t.dts,isKeyframe:v,data:y,options:i});n.samples.push(g)}},{key:"destory",value:function(){this.off(s.DEMUX_START,this.demux),this.configs={},this.demuxing=!1,this.pat=[],this.pmt=[],this._hasVideoMeta=!1,this._hasAudioMeta=!1}},{key:"inputBuffer",get:function(){return this._context.getInstance(this.configs.inputbuffer)}},{key:"_tracks",get:function(){return this._context.getInstance("TRACKS")}}],[{key:"compaireArray",value:function(e,t,i){let n=0,r=0;if("Uint8Array"===i?(n=e.byteLength,r=t.byteLength):"Array"===i&&(n=e.length,r=t.length),n!==r)return!1;for(let i=0;i<n;i++)if(e[i]!==t[i])return!1;return!0}},{key:"compaireMeta",value:function(t,i,n){if(!t||!i)return!1;for(let r=0,a=Object.keys(t).length;r<a;r++){let a=t[Object.keys(t)[r]],o=i[Object.keys(t)[r]];if("object"!=typeof a){if(n&&"duration"!==Object.keys(t)[r]&&"refSampleDuration"!==Object.keys(t)[r]&&"refSampleDurationFixed"!==Object.keys(t)[r]&&a!==o)return!1}else if(void 0!==a.byteLength){if(void 0===o.byteLength)return!1;if(!e.compaireArray(a,o,"Uint8Array"))return!1}else if(void 0!==a.length){if(void 0===o.length)return!1;if(!e.compaireArray(a,o,"Array"))return!1}else if(!e.compaireMeta(a,o))return!1}return!0}},{key:"Merge",value:function(e){let t,i=0,n=0;for(let t=0;t<e.length;t++)i+=e[t].length-e[t].position;t=new Uint8Array(i);for(let i=0;i<e.length;i++){let r=e[i];t.set(new Uint8Array(r.buffer,r.position),n),n+=r.length-r.position}return new o.Stream(t.buffer)}},{key:"read",value:function(t,i,n){e.readHeader(t,i),e.readPayload(t,i,n),"MEDIA"!==i.header.packet||1!==i.header.payload||i.unknownPIDs||(i.pes=e.PES(i))}},{key:"readPayload",value:function(t,i,n){let r=i.header.pid;switch(r){case 0:e.PAT(t,i,n);break;case 1:e.CAT(t,i,n);break;case 2:e.TSDT(t,i,n);break;case 8191:break;default:if(n.pat.some(e=>e.pid===r))e.PMT(t,i,n);else{let a=n.pmt?n.pmt.filter(e=>e.pid===r):[];a.length>0?e.Media(t,i,u[a[0].streamType][0]):i.unknownPIDs=!0}}}},{key:"readHeader",value:function(e,t){let i={};i.sync=e.readUint8();let n=e.readUint16();i.error=n>>>15,i.payload=n>>>14&1,i.priority=n>>>13&1,i.pid=8191&n,n=e.readUint8(),i.scrambling=n>>6&3,i.adaptation=n>>4&3,i.continuity=15&n,i.packet=0===i.pid?"PAT":"MEDIA",t.header=i}},{key:"PAT",value:function(e,t,i){let n={},r=e.readUint8();e.skip(r),r=e.readUint8(),n.tabelID=r,r=e.readUint16(),n.error=r>>>7,n.zero=r>>>6&1,n.sectionLength=4095&r,n.streamID=e.readUint16(),n.current=1&e.readUint8(),n.sectionNumber=e.readUint8(),n.lastSectionNumber=e.readUint8();let a=(n.sectionLength-9)/4,o=[];for(let t=0;t<a;t++){let t=e.readUint16(),i=8191&e.readUint16();o.push({program:t,pid:i,type:0===t?"network":"mapPID"})}o.length>0&&(i.pat=i.pat.concat(o)),n.list=o,n.program=e.readUint16(),n.pid=8191&e.readUint16(),t.payload=n}},{key:"PMT",value:function(e,t,i){let n={};t.header.packet="PMT";let r=e.readUint8();e.skip(r),r=e.readUint8(),n.tableID=r,r=e.readUint16(),n.sectionLength=4095&r,n.program=e.readUint16(),n.current=1&e.readUint8(),n.order=e.readUint8(),n.lastOrder=e.readUint8(),n.PCR_PID=8191&e.readUint16(),n.programLength=4095&e.readUint16();let a=(n.sectionLength-13)/5,o=[];for(let t=0;t<a;t++)o.push({streamType:e.readUint8(),pid:8191&e.readUint16(),es:4095&e.readUint16()});n.list=o,this.pmt||(this.pmt=[]),i.pmt=this.pmt.concat(o.map(e=>({pid:e.pid,es:e.es,streamType:e.streamType,program:n.program}))),t.payload=n}},{key:"Media",value:function(e,t,i){let n=t.header,r={};if(n.type=i,3===n.adaptation&&(r.adaptationLength=e.readUint8(),r.adaptationLength>0)){let t=e.readUint8();r.discontinue=t>>>7,r.access=t>>>6&1,r.priority=t>>>5&1,r.PCR=t>>>4&1,r.OPCR=t>>>3&1,r.splicePoint=t>>>2&1,r.transportPrivate=t>>>1&1,r.adaptationField=1&t;let i=e.position;if(1===r.PCR&&(r.programClockBase=e.readUint32()<<1,t=e.readUint16(),r.programClockBase|=t>>>15,r.programClockExtension=511&t),1===r.OPCR&&(r.originProgramClockBase=e.readUint32()<<1,t=e.readUint16(),r.originProgramClockBase+=t>>>15,r.originProgramClockExtension=511&t),1===r.splicePoint&&(r.spliceCountdown=e.readUint8()),1===r.transportPrivate){let t=e.readUint8(),i=[];for(let n=0;n<t;n++)i.push(e.readUint8())}if(1===r.adaptationField){let t=e.readUint8(),i=e.readUint8(),n=e.position,a=i>>>6&1,o=i>>>5&1;1===i>>>7&&(i=e.readUint16(),r.ltwValid=i>>>15,r.ltwOffset=61439&i),1===a&&(i=e.readUint24(),r.piecewiseRate=4194303&i),1===o&&(i=e.readInt8(),r.spliceType=i>>>4,r.dtsNextAU1=i>>>1&7,r.marker1=1&i,i=e.readUint16(),r.dtsNextAU2=i>>>1,r.marker2=1&i,i=e.readUint16(),r.dtsNextAU3=i),e.skip(t-1-(e.position-n))}let n=r.adaptationLength-1-(e.position-i);e.skip(n)}r.stream=new o.Stream(e.buffer.slice(e.position)),t.payload=r}},{key:"PES",value:function(t){let i={},n=t.payload.stream;if(1!==n.readUint24())i.ES={},i.ES.buffer=n;else{let t=n.readUint8();t>=224&&t<=239&&(i.type="video"),t>=192&&t<=223&&(i.type="audio");let r=n.readUint16();if(i.packetLength=r,"video"!==i.type&&"audio"!==i.type)throw new Error("format is not supported");{let t=n.readUint8();if(2!==t>>>6)throw new Error("error when parse pes header");t=n.readUint8(),i.ptsDTSFlag=t>>>6,i.escrFlag=t>>>5&1,i.esRateFlag=t>>>4&1,i.dsmFlag=t>>>3&1,i.additionalFlag=t>>>2&1,i.crcFlag=t>>>1&1,i.extensionFlag=1&t,i.pesHeaderLength=n.readUint8();let r=i.pesHeaderLength;if(2===i.ptsDTSFlag){let e=[];t=n.readUint8(),e.push(t>>>1&7),t=n.readUint16(),e.push(t>>>1),t=n.readUint16(),e.push(t>>>1),i.pts=e[0]<<30|e[1]<<15|e[2],r-=5,"video"===i.type&&(i.dts=i.pts)}if(3===i.ptsDTSFlag){let e=[];t=n.readUint8(),e.push(t>>>1&7),t=n.readUint16(),e.push(t>>>1),t=n.readUint16(),e.push(t>>>1),i.pts=e[0]<<30|e[1]<<15|e[2];let a=[];t=n.readUint8(),a.push(t>>>1&7),t=n.readUint16(),a.push(t>>>1),t=n.readUint16(),a.push(t>>>1),i.dts=a[0]<<30|a[1]<<15|a[2],r-=10}if(1===i.escrFlag){let e=[],a=[];t=n.readUint8(),e.push(t>>>3&7),e.push(3&t),t=n.readUint16(),e.push(t>>>13),e.push(3&t),t=n.readUint16(),e.push(t>>>13),a.push(3&t),t=n.readUint8(),a.push(t>>>1),i.escr=300*(e[0]<<30|e[1]<<28|e[2]<<15|e[3]<<13|e[4])+(a[0]<<7|a[1]),r-=6}if(1===i.esRateFlag&&(t=n.readUint24(),i.esRate=t>>>1&4194303,r-=3),1===i.dsmFlag)throw new Error("not support DSM_trick_mode");if(1===i.additionalFlag&&(t=n.readUint8(),i.additionalCopyInfo=127&t,r-=1),1===i.crcFlag&&(i.pesCRC=n.readUint16(),r-=2),1===i.extensionFlag)throw new Error("not support extension");r>0&&n.skip(r),i.ES=e.ES(n,i.type)}}return i}},{key:"ES",value:function(t,i){let n,r={};if("video"===i){if(1!==(n=t.readUint32())&&(t.back(4),1!==(n=t.readUint24())))throw new Error("h264 nal header parse failed");t.skip(2),r.buffer=t}else{if("audio"!==i)throw new Error(`ES ${i} is not supported`);{if((n=t.readUint16())>>>4!=4095)throw new Error("aac ES parse Error");const i=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350];r.id=0==(n>>>3&1)?"MPEG-4":"MPEG-2",r.layer=n>>>1&3,r.absent=1&n,n=t.readUint16(),r.audioObjectType=1+(n>>>14&3),r.profile=r.audioObjectType-1,r.frequencyIndex=n>>>10&15,r.frequence=i[r.frequencyIndex],r.channel=n>>>6&7,r.frameLength=(3&n)<<11|t.readUint16()>>>5,e.getAudioConfig(r),t.skip(1),r.buffer=t}}return r}},{key:"TSDT",value:function(e,t,i){t.payload={}}},{key:"CAT",value:function(e,t,i){let n={};n.tableID=e.readUint8();let r=e.readUint16();n.sectionIndicator=r>>>7,n.sectionLength=4095&r,e.skip(2),r=e.readUint8(),n.version=r>>>3,n.currentNextIndicator=1&r,n.sectionNumber=e.readUint8(),n.lastSectionNumber=e.readUint8();let a=(this.sectionLength-9)/4,o=[];for(let e=0;e<a;e++)o.push({});n.crc32=e.readUint32(),t.payload=n}},{key:"getAudioConfig",value:function(e){let t,i,n=navigator.userAgent.toLowerCase();/firefox/i.test(n)?e.frequencyIndex>=6?(e.audioObjectType=5,t=new Array(4),i=e.frequencyIndex-3):(e.audioObjectType=2,t=new Array(2),i=e.frequencyIndex):-1!==n.indexOf("android")?(e.audioObjectType=2,t=new Array(2),i=e.frequencyIndex):(e.audioObjectType=5,t=new Array(4),e.frequencyIndex>=6?i=e.frequencyIndex-3:(1===e.channel&&(e.audioObjectType=2,t=new Array(2)),i=e.frequencyIndex)),t[0]=e.audioObjectType<<3,t[0]|=(14&e.frequencyIndex)>>1,t[1]=(1&e.frequencyIndex)<<7,t[1]|=e.channel<<3,5===e.audioObjectType&&(t[1]|=(14&i)>>1,t[2]=(1&i)<<7,t[2]|=8,t[3]=0),e.audioConfig=t}}]),e}();t.default=l},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),a=i(0),o=i(47),s=(n=o)&&n.__esModule?n:{default:n};const{REMUX_EVENTS:u,DEMUX_EVENTS:l}=a.EVENTS;let c=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.nextAudioDts=0,this.nextVideoDts=0,this.lastAudioSamplesLen=0,this.lastVideoSamplesLen=0,this.lastVideoDts=void 0,this.lastAudioDts=void 0,this.allAudioSamplesCount=0,this.allVideoSamplesCount=0,this._firstAudioSample=null,this._firstVideoSample=null,this.filledAudioSamples=[],this.filledVideoSamples=[],this._videoLargeGap=0,this._audioLargeGap=0}return r(e,[{key:"init",value:function(){this.before(u.REMUX_MEDIA,this.doFix.bind(this))}},{key:"reset",value:function(){this.nextAudioDts=null,this.nextVideoDts=null,this.lastAudioSamplesLen=0,this.lastVideoSamplesLen=0,this.lastVideoDts=void 0,this.lastAudioDts=void 0,this.filledAudioSamples=[],this.filledVideoSamples=[]}},{key:"doFix",value:function(){const{isFirstAudioSamples:t,isFirstVideoSamples:i}=this.getFirstSample();this.recordSamplesCount(),this._firstVideoSample&&this.fixRefSampleDuration(this.videoTrack.meta,this.videoTrack.samples),this._firstAudioSample&&this.fixRefSampleDuration(this.audioTrack.meta,this.audioTrack.samples);const{changed:n,changedIdx:r}=e.detactChangeStream(this.videoTrack.samples);n&&!t?this.fixChangeStreamVideo(r):this.doFixVideo(i);const{changed:a,changedIdx:o}=e.detactChangeStream(this.audioTrack.samples);a?this.fixChangeStreamAudio(o):this.doFixAudio(t)}},{key:"doFixVideo",value:function(t,i){let{samples:n,meta:r}=this.videoTrack;if(r.frameRate&&!1===r.frameRate.fixed)return;if(!n||!n.length||!this._firstVideoSample)return;const a=n[0],o=n.length;this._videoLargeGap>0&&e.doFixLargeGap(n,this._videoLargeGap),a.dts!==this._firstVideoSample.dts&&(i||e.detectLargeGap(this.nextVideoDts,a))&&(i&&(this.nextVideoDts=i),this._videoLargeGap=this.nextVideoDts-a.dts,e.doFixLargeGap(n,this._videoLargeGap));const s=a.dts;if(t&&this._firstAudioSample){const e=this._firstVideoSample.dts,t=e-this._firstAudioSample.dts;if(t>2*r.refSampleDuration){const i=Math.floor(t/r.refSampleDuration);for(let t=0;t<i;t++){const i=Object.assign({},a);i.dts=e-(t+1)*r.refSampleDuration,i.pts=i.dts+i.cts,n.unshift(i),this.filledVideoSamples.push({dts:i.dts,size:i.data.byteLength})}}}let u;if(this.nextVideoDts){u=s-this.nextVideoDts;const t=Math.abs(u);if(u>2*r.refSampleDuration){const e=Math.floor(u/r.refSampleDuration);for(let t=0;t<e;t++){const e=Object.assign({},n[0]),i=s-(t+1)*r.refSampleDuration;e.dts=i>this.nextVideoDts?i:this.nextVideoDts,e.pts=e.dts+e.cts,this.videoTrack.samples.unshift(e),this.filledVideoSamples.push({dts:e.dts,size:e.data.byteLength})}}else t<=r.refSampleDuration&&t>0?(n[0].dts=this.nextVideoDts,n[0].originDts=n[0].dts,n[0].cts=void 0!==n[0].cts?n[0].cts:n[0].pts-n[0].dts,n[0].pts=n[0].dts+n[0].cts):u<0&&e.doFixLargeGap(n,-1*u)}const l=n[n.length-1].dts,c=n.length>=2?l-n[n.length-2].dts:r.refSampleDuration;this.lastVideoSamplesLen=o,this.nextVideoDts=l+c,this.lastVideoDts=l;for(let e=0,t=n.length;e<t;e++){const t=n[e],i=n[e+1];if(!i)break;const a=i.dts-t.dts;if(a>2*r.refSampleDuration){let o=Math.floor(a/r.refSampleDuration),s=0;for(;s<o;){const a=Object.assign({},i);a.dts=t.dts+(s+1)*r.refSampleDuration,a.pts=a.dts+a.cts,a<i.dts&&(n.splice(e,0,a),this.filledVideoSamples.push({dts:a.dts,size:a.data.byteLength})),s++,e++}}}this.videoTrack.samples=n}},{key:"doFixAudio",value:function(t,i){let{samples:n,meta:r}=this.audioTrack;if(!n||!n.length)return;const a=n.length,o=s.default.getSilentFrame(r.codec,r.channelCount),u=this._firstAudioSample,l=n[0];if(this._audioLargeGap>0&&e.doFixLargeGap(n,this._audioLargeGap),l.dts!==this._firstAudioSample.dts&&(i||e.detectLargeGap(this.nextAudioDts,l))&&(i&&(this.nextAudioDts=i),this._audioLargeGap=this.nextAudioDts-l.dts,e.doFixLargeGap(n,this._audioLargeGap)),this._firstVideoSample&&t){const e=this._firstVideoSample.pts?this._firstVideoSample.pts:this._firstVideoSample.dts+this._firstVideoSample.cts;if(u.dts-e>r.refSampleDuration){const t=Math.floor((u.dts-e)/r.refSampleDuration);for(let e=0;e<t;e++){const t={data:o,datasize:o.byteLength,dts:u.dts-(e+1)*r.refSampleDuration,filtered:0};n.unshift(t),this.filledAudioSamples.push({dts:t.dts,size:t.data.byteLength})}}}let c;const f=n[0].dts;if(this.nextAudioDts){c=f-this.nextAudioDts;const t=Math.abs(c);if(t>r.refSampleDuration&&1===a&&1===this.lastAudioSamplesLen&&(r.refSampleDurationFixed=void 0),c>2*r.refSampleDuration)if(1===a&&1===this.lastAudioSamplesLen)r.refSampleDurationFixed=void 0!==r.refSampleDurationFixed?r.refSampleDurationFixed+c:r.refSampleDuration+c;else{const e=Math.floor(c/r.refSampleDuration);for(let t=0;t<e;t++){const e=f-(t+1)*r.refSampleDuration,i=Object.assign({},n[0],{dts:e>this.nextAudioDts?e:this.nextAudioDts});this.filledAudioSamples.push({dts:i.dts,size:i.data.byteLength}),this.audioTrack.samples.unshift(i)}}else t<=r.refSampleDuration&&t>0?(n[0].dts=this.nextAudioDts,n[0].pts=this.nextAudioDts):c<0&&e.doFixLargeGap(n,-1*c)}const h=n[n.length-1].dts,d=n.length>=2?h-n[n.length-2].dts:r.refSampleDuration;this.lastAudioSamplesLen=a,this.nextAudioDts=r.refSampleDurationFixed?h+r.refSampleDurationFixed:h+d,this.lastAudioDts=h;for(let e=0,t=n.length;e<t;e++){const t=n[e],i=n[e+1];if(!i)break;const r=i.dts-t.dts;n[e].duration=r}this.audioTrack.samples=e.sortAudioSamples(n)}},{key:"fixChangeStreamVideo",value:function(e){const{samples:t,meta:i}=this.videoTrack,n=0===e?this.getStreamChangeStart(t[0]):t[e-1].dts,r=t[e].dts;if(Math.abs(n-r)<=2*i.refSampleDuration)return t[e].options?t[e].options.isContinue=!0:t[e].options={isContinue:!0},this.doFixVideo(!1);const a=t.slice(0,e),o=t.slice(e),s=t[0],u=o[0].dts-s.dts,l=s.options&&s.options.start+u?s.options.start:null;this.videoTrack.samples=t.slice(0,e),this.doFixVideo(!1),this.videoTrack.samples=t.slice(e),this.doFixVideo(!1,l),this.videoTrack.samples=a.concat(o)}},{key:"fixChangeStreamAudio",value:function(e){const{samples:t,meta:i}=this.audioTrack,n=0===e?this.getStreamChangeStart(t[0]):t[e-1].dts,r=t[e].dts;if(Math.abs(n-r)<=2*i.refSampleDuration)return t[e].options?t[e].options.isContinue=!0:t[e].options={isContinue:!0},this.doFixAudio(!1);const a=t.slice(0,e),o=t.slice(e),s=t[0],u=o[0].dts-s.dts,l=s.options&&s.options.start+u?s.options.start:null;this.audioTrack.samples=a,this.doFixAudio(!1),this.audioTrack.samples=o,this.doFixAudio(!1,l),this.audioTrack.samples=a.concat(o)}},{key:"getFirstSample",value:function(){let{samples:t}=this.videoTrack,{samples:i}=this.audioTrack,n=!1,r=!1;return!this._firstVideoSample&&t.length&&(this._firstVideoSample=e.findFirstVideoSample(t),n=!0),!this._firstAudioSample&&i.length&&(this._firstAudioSample=e.findFirstAudioSample(i),r=!0),{isFirstVideoSamples:n,isFirstAudioSamples:r}}},{key:"fixRefSampleDuration",value:function(e,t){const i="video"===e.type,n=i?this.allVideoSamplesCount:this.allAudioSamplesCount,r=i?this._firstVideoSample.dts:this._firstAudioSample.dts,a=i?this.filledVideoSamples.length:this.filledAudioSamples.length;if(!e.refSampleDuration||e.refSampleDuration<=0||Number.isNaN(e.refSampleDuration)){if(t.length>=1){const i=t[t.length-1].dts;e.refSampleDuration=Math.floor((i-r)/(n+a-1))}}else if(e.refSampleDuration&&t.length>=5){const i=(t[t.length-1].dts-t[0].dts)/(t.length-1);e.refSampleDuration=Math.floor(Math.abs(e.refSampleDuration-i)<=5?e.refSampleDuration:i)}}},{key:"recordSamplesCount",value:function(){const{audioTrack:e,videoTrack:t}=this;this.allAudioSamplesCount+=e.samples.length,this.allVideoSamplesCount+=t.samples.length}},{key:"removeInvalidSamples",value:function(){const{_firstVideoSample:e,_firstAudioSample:t}=this;this.audioTrack.samples=this.audioTrack.samples.filter(e=>e.dts>=t.dts&&(void 0===this.lastAudioDts||e.dts>this.lastAudioDts)),this.videoTrack.samples=this.videoTrack.samples.filter(t=>t.dts>=e.dts&&(void 0===this.lastVideoDts||t.dts>this.lastVideoDts))}},{key:"getStreamChangeStart",value:function(e){return e.options&&e.options.start?e.options.start-this.dtsBase:1/0}},{key:"tracks",get:function(){return this._context.getInstance("TRACKS")}},{key:"audioTrack",get:function(){return this.tracks?this.tracks.audioTrack:null}},{key:"videoTrack",get:function(){return this.tracks?this.tracks.videoTrack:null}},{key:"dtsBase",get:function(){const e=this._context.getInstance("MP4_REMUXER");return e?e._dtsBase:0}}],[{key:"sortAudioSamples",value:function(e){return 1===e.length?e:e.sort((e,t)=>e.dts-t.dts)}},{key:"findFirstAudioSample",value:function(t){return t&&0!==t.length?e.sortAudioSamples(t)[0]:null}},{key:"findFirstVideoSample",value:function(e){if(!e.length)return null;const t=e.sort((e,t)=>e.dts-t.dts);for(let e=0,i=t.length;e<i;e++)if(t[e].isKeyframe)return t[e]}},{key:"detectLargeGap",value:function(e,t){if(null===e)return;const i=t.dts||0,n=e-i>=1e3||i-e>=1e3,r=t.options&&t.options.discontinue;return n||r}},{key:"doFixLargeGap",value:function(e,t){for(let i=0,n=e.length;i<n;i++){const n=e[i];n.dts+=t,n.pts&&(n.pts+=t)}}},{key:"detactChangeStream",value:function(e){let t=!1,i=-1;for(let n=0,r=e.length;n<r;n++)if(e[n].options&&e[n].options.meta){t=!0,i=n;break}return{changed:t,changedIdx:i}}}]),e}();t.default=c},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)}return n(e,null,[{key:"getSilentFrame",value:function(e,t){if("mp4a.40.2"===e){if(1===t)return new Uint8Array([0,200,0,128,35,128]);if(2===t)return new Uint8Array([33,0,73,144,2,25,0,35,128]);if(3===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,142]);if(4===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,128,44,128,8,2,56]);if(5===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,56]);if(6===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,0,178,0,32,8,224])}else{if(1===t)return new Uint8Array([1,64,34,128,163,78,230,128,186,8,0,0,0,28,6,241,193,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94]);if(2===t)return new Uint8Array([1,64,34,128,163,94,230,128,186,8,0,0,0,0,149,0,6,241,161,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94]);if(3===t)return new Uint8Array([1,64,34,128,163,94,230,128,186,8,0,0,0,0,149,0,6,241,161,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94])}return null}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}let a=function e(){r(this,e),this.mimetype="",this.init=null,this.data=[]},o=function(){function e(){r(this,e),this.sources={}}return n(e,[{key:"getSource",value:function(e){return this.sources[e]}},{key:"createSource",value:function(e){return this.sources[e]=new a,this.sources[e]}},{key:"clear",value:function(){this.sources={}}},{key:"destroy",value:function(){this.sources={}}}]),e}();t.default=o},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}();let r=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this._baseURL="",this._list={},this._ts={},this.version=0,this.sequence=-1,this.targetduration=0,this.duration=0,this.fragLength=0,this._lastget=void 0,this._audoclear=t.autoclear||!1}return n(e,[{key:"push",value:function(e,t,i){this._ts[e]||(this._ts[e]={duration:t,downloaded:!1,downloading:!1,start:this.duration,discontinue:!!i},this._list[this.duration]=e,this.duration+=t,this.fragLength+=1)}},{key:"deleteFrag",value:function(e){this._ts[e]&&(this._ts[e].start>this._lastget.time&&(this._lastget={duration:this._ts[e].duration,time:this._ts[e].start,downloaded:!1,downloading:!1,url:e}),delete this._list[this._ts[e].start],delete this._ts[e],this.fragLength-=1)}},{key:"pushM3U8",value:function(e,t){if(!e)throw new Error("No m3u8 data received.");if(this.version=e.version,this.targetduration=e.targetduration,e.encrypt&&!this.encrypt&&(this.encrypt=e.encrypt),!(e.sequence>this.sequence))throw new Error(`Old m3u8 file received, ${e.sequence}`);{this.sequence=e.sequence;let i=[];for(let t=0;t<e.frags.length;t++){let n=e.frags[t];this._ts[n.url]||(i.push(n.url),this.push(n.url,n.duration,n.discontinue))}if(i.length<1)throw new Error("Can not read ts file list.");if(t){let e=this.getTsList();for(let t=0;t<e.length;t++)i.indexOf(e[t])<0&&this.deleteFrag(e[t])}}}},{key:"getTsList",value:function(){return Object.keys(this._ts)}},{key:"downloaded",value:function(e,t){let i=this._ts[e];i&&(i.downloaded=t)}},{key:"downloading",value:function(e,t){let i=this._ts[e];i&&(i.downloading=t)}},{key:"getTsByName",value:function(e){return this._ts[e]}},{key:"getTs",value:function(e){let t,i=Object.keys(this._list);if(void 0===e&&(e=this._lastget?this._lastget.time+this._lastget.duration:0),!(i.length<1||e>=this.duration)){i.sort((e,t)=>parseFloat(e)-parseFloat(t));for(let n=0;n<i.length&&e>=parseInt(i[n]);n++){let e=this._list[i[n]];t={url:e,downloaded:this._ts[e].downloaded,downloading:this._ts[e].downloading,time:parseInt(i[n]),duration:parseInt(this._ts[e].duration)},this.autoclear&&(delete this._ts[this._lastget.url],delete this._list[this._lastget.time]),this._lastget=t}return t}}},{key:"clear",value:function(){this._baseURL="",this._list={},this._ts={},this.version=0,this.sequence=-1,this.targetduration=0,this.duration=0}},{key:"clearDownloaded",value:function(){for(let e=0,t=Object.keys(this._ts).length;e<t;e++){let t=this._ts[Object.keys(this._ts)[e]];t.downloaded=!1,t.downloading=!1}}},{key:"destroy",value:function(){this._baseURL="",this._list={},this._ts={},this.version=0,this.sequence=-1,this.targetduration=0,this.duration=0,this.fragLength=0,this._lastget=void 0,this._audoclear=!1}},{key:"list",get:function(){return this._list}},{key:"baseURL",set:function(e){this.baseURL!==e&&(this.clear(),this._baseURL=e)},get:function(){return this._baseURL}}]),e}();t.default=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),a=i(0),o=i(3),s=i(4),u=i(51),l=(n=u)&&n.__esModule?n:{default:n};const c=a.EVENTS.DEMUX_EVENTS;let f=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this._firstFragmentLoaded=!1,this._trackNum=0,this._hasScript=!1}return r(e,[{key:"init",value:function(){this.on(c.DEMUX_START,this.doParseFlv.bind(this))}},{key:"doParseFlv",value:function(){if(this._firstFragmentLoaded){if(this.loaderBuffer.length<11)return;let e,t=1e5;do{e=this._parseFlvTag()}while(e&&t-- >0);this.emit(c.DEMUX_COMPLETE)}else{if(this.loaderBuffer.length<13)return;const e=this.loaderBuffer.shift(13);this.parseFlvHeader(e),this.doParseFlv()}}},{key:"parseFlvHeader",value:function(t){if(e.isFlvFile(t)){this._firstFragmentLoaded=!0;const i=e.getPlayType(t[4]);i.hasVideo&&this.initVideoTrack(),i.hasAudio&&this.initAudioTrack()}else this.emit(c.DEMUX_ERROR,new Error("invalid flv file")),this.doParseFlv();this.doParseFlv()}},{key:"initVideoTrack",value:function(){this._trackNum++;let e=new s.VideoTrack;e.meta=new a.VideoTrackMeta,e.id=e.meta.id=this._trackNum,this.tracks.videoTrack=e}},{key:"initAudioTrack",value:function(){this._trackNum++;let e=new s.AudioTrack;e.meta=new a.AudioTrackMeta,e.id=e.meta.id=this._trackNum,this.tracks.audioTrack=e}},{key:"_parseFlvTag",value:function(){if(this.loaderBuffer.length<11)return null;let e=this._parseFlvTagHeader();return e&&this._processChunk(e),e}},{key:"_parseFlvTagHeader",value:function(){let e=0,t={},i=this.loaderBuffer.toInt(e,1);if(e+=1,t.filtered=(32&i)>>>5,t.tagType=31&i,t.datasize=this.loaderBuffer.toInt(e,3),e+=3,8!==t.tagType&&9!==t.tagType&&11!==t.tagType&&18!==t.tagType||0!==this.loaderBuffer.toInt(8,3))return this.loaderBuffer&&this.loaderBuffer.length>0&&this.loaderBuffer.shift(1),this.emit(c.DEMUX_ERROR,this.TAG,new Error("tagType "+t.tagType),!1),null;if(this.loaderBuffer.length<t.datasize+15)return null;this.loaderBuffer.shift(4);let n=this.loaderBuffer.toInt(0,3);this.loaderBuffer.shift(3);let r=this.loaderBuffer.shift(1)[0];return r>0&&(n+=16777216*r),t.dts=n,this.loaderBuffer.shift(3),t}},{key:"_processChunk",value:function(e){switch(e.tagType){case 18:this._parseScriptData(e);break;case 8:this._parseAACData(e);break;case 9:this._parseHevcData(e);break;case 11:this.loaderBuffer.shift(3);break;default:this.loaderBuffer.shift(1)}}},{key:"_parseScriptData",value:function(e){let t=this.tracks.audioTrack,i=this.tracks.videoTrack,n=this.loaderBuffer.shift(e.datasize);const r=(new l.default).resolve(n,n.length),a=this._context.onMetaData=r?r.onMetaData:void 0;if(this._context.mediaInfo.duration=a.duration,this._context.mediaInfo.hasVideo=a.hasVideo,this._context.mediaInfo.hsaAudio=a.hasAudio,this._datasizeValidator(e.datasize)&&(this.emit(c.MEDIA_INFO),this._hasScript=!0),t&&!t.hasSpecificConfig){let e=t.meta;switch(a.audiosamplerate&&(e.sampleRate=a.audiosamplerate),a.audiochannels&&(e.channelCount=a.audiochannels),a.audiosamplerate){case 44100:e.sampleRateIndex=4;break;case 22050:e.sampleRateIndex=7;break;case 11025:e.sampleRateIndex=10}}if(i&&!i.hasSpecificConfig){let e=i.meta;if("number"==typeof a.framerate){let t=Math.floor(1e3*a.framerate);if(t>0){let i=t/1e3;e.frameRate||(e.frameRate={}),e.frameRate.fixed=!0,e.frameRate.fps=i,e.frameRate.fps_num=t,e.frameRate.fps_den=1e3}}}}},{key:"_aacSequenceHeaderParser",value:function(e){let t={hasSpecificConfig:!0};t.objectType=e[1]>>>3,t.originObjectType=t.objectType,t.sampleRateIndex=(7&e[1])<<1|e[2]>>>7,t.audiosamplerate=this._switchAudioSampleRate(t.sampleRateIndex),t.channelCount=(120&e[2])>>>3,t.frameLength=(4&e[2])>>>2,t.dependsOnCoreCoder=(2&e[2])>>>1,t.extensionFlagIndex=1&e[2],t.codec=`mp4a.40.${t.objectType}`;let i,n,r=window.navigator.userAgent.toLowerCase(),o=t.sampleRateIndex;return-1!==r.indexOf("firefox")?t.sampleRateIndex>=6?(t.objectType=5,n=new Array(4),i=o-3):(t.objectType=2,n=new Array(2),i=o):-1!==r.indexOf("android")||"safari"===a.sniffer.browser?(t.objectType=2,n=new Array(2),i=o):(t.objectType=5,i=t.sampleRateIndex,n=new Array(4),t.sampleRateIndex>=6?i=t.sampleRateIndex-3:1===t.channelCount&&(t.objectType=2,n=new Array(2),i=t.sampleRateIndex)),n[0]=t.objectType<<3,n[0]|=(15&t.sampleRateIndex)>>>1,n[1]=(15&t.sampleRateIndex)<<7,n[1]|=(15&t.channelCount)<<3,5===t.objectType&&(n[1]|=(15&i)>>>1,n[2]=(1&i)<<7,n[2]|=8,n[3]=0),t.config=n,t}},{key:"_parseAACData",value:function(e){let t=this.tracks.audioTrack;if(!t)return;let i=t.meta;i||(t.meta=new a.AudioTrackMeta,i=t.meta);let n=this.loaderBuffer.shift(1)[0];e.data=this.loaderBuffer.shift(e.datasize-1);let r=(240&n)>>>4;t.format=r,10!==r&&this.emit(c.DEMUX_ERROR,new Error(`invalid audio format: ${r}`)),10!==r||this._hasAudioSequence||(i.sampleRate=this._switchAudioSamplingFrequency(n),i.sampleRateIndex=(12&n)>>>2,i.frameLenth=(2&n)>>>1,i.channelCount=1&n,i.refSampleDuration=Math.floor(1024/i.audioSampleRate*i.timescale));let o=i.audioSampleRate,s=i.sampleRateIndex,u=i.refSampleDuration;delete e.tagType;let l=this._datasizeValidator(e.datasize);if(0===e.data[0]){let t=this._aacSequenceHeaderParser(e.data);o=t.audiosamplerate||i.audioSampleRate,s=t.sampleRateIndex||i.sampleRateIndex,u=Math.floor(1024/o*i.timescale),i.channelCount=t.channelCount,i.sampleRate=o,i.sampleRateIndex=s,i.refSampleDuration=u,i.duration=this._context.mediaInfo.duration*i.timescale,i.config=t.config,i.objectType=t.objectType,i.originObjectType=t.originObjectType;const n=this._context.mediaInfo.audio;n.codec=t.codec,n.channelCount=t.channelCount,n.sampleRate=o,n.sampleRateIndex=t.audioSampleRateIndex,this._hasScript&&!this._hasAudioSequence?this.emit(c.METADATA_PARSED,"audio"):this._hasScript&&this._hasAudioSequence&&(this.emit(c.METADATA_PARSED,"audio"),this.emit(c.AUDIO_METADATA_CHANGE)),this._hasAudioSequence=!0,this._metaChange=!0}else this._metaChange&&(e.options={meta:t.meta},this._metaChange=!1),e.data=e.data.slice(1,e.data.length),t.samples.push(e);l||this.emit(c.DEMUX_ERROR,this.TAG,new Error("TAG length error at "+e.datasize),!1)}},{key:"_parseHevcData",value:function(e){let t=this.loaderBuffer.shift(1)[0];e.frameType=(240&t)>>>4,e.isKeyframe=1===e.frameType;let i=15&t;if(this.tracks.videoTrack.codecID=i,e.avcPacketType=this.loaderBuffer.shift(1)[0],e.cts=this.loaderBuffer.toInt(0,3),this.loaderBuffer.shift(3),12===i){const t=this.loaderBuffer.shift(e.datasize-5);if(e.data=t,0!==Number.parseInt(e.avcPacketType)){this._datasizeValidator(e.datasize)||this.emit(c.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1);let t={},i=0;for(t.cts=e.cts,t.dts=e.dts;e.data.length>i;){let n=e.data.slice(Number.parseInt(i),4+i);t.size=n[3],t.size+=256*n[2],t.size+=256*n[1]*256,t.size+=256*n[0]*256*256,i+=4,t.data=e.data.slice(Number.parseInt(i),t.size+i),i+=t.size,this.tracks.videoTrack.samples.push(t),this.emit(c.METADATA_PARSED,"video")}}else 0===Number.parseInt(e.avcPacketType)&&(this._datasizeValidator(e.datasize)?this.emit(c.METADATA_PARSED,"video"):this.emit(c.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1))}else if(7===i){let t=this.loaderBuffer.shift(e.datasize-5);if(0===t[4]&&0===t[5]&&0===t[6]&&1===t[7]){let e=0;for(let i=0;i<4;i++)e=256*e+t[i];e-=4,(t=t.slice(4,t.length))[3]=e%256,e=(e-t[3])/256,t[2]=e%256,e=(e-t[2])/256,t[1]=e%256,t[0]=(e-t[1])/256}if(e.data=t,0===e.avcPacketType){this._avcSequenceHeaderParser(e.data),this._datasizeValidator(e.datasize)&&(this._hasScript&&!this._hasVideoSequence?this.emit(c.METADATA_PARSED,"video"):this._hasScript&&this._hasVideoSequence&&(this.emit(c.METADATA_PARSED,"audio"),this.emit(c.VIDEO_METADATA_CHANGE)),this._hasVideoSequence=!0),this._metaChange=!0}else{if(!this._datasizeValidator(e.datasize))return void this.emit(c.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1);this._metaChange&&(e.options={meta:Object.assign({},this.tracks.videoTrack.meta)},this._metaChange=!1),this.tracks.videoTrack.samples.push(e)}}else this.emit(c.DEMUX_ERROR,this.TAG,new Error(`video codeid is ${i}`),!1),e.data=this.loaderBuffer.shift(e.datasize-1),this._datasizeValidator(e.datasize)||this.emit(c.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1),this.tracks.videoTrack.samples.push(e),this.emit(c.DEMUX_COMPLETE);delete e.tagType}},{key:"_avcSequenceHeaderParser",value:function(e){let t=this.tracks.videoTrack;if(!t)return;let i=0;t.meta||(t.meta=new a.VideoTrackMeta);let n=t.meta;n.configurationVersion=e[0],n.avcProfileIndication=e[1],n.profileCompatibility=e[2],n.avcLevelIndication=e[3]/10,n.nalUnitLength=1+(3&e[4]);let r=31&e[5];i=6;let s={};for(let t=0;t<r;t++){let t=255*e[i]+e[i+1];i+=2;let r=new Uint8Array(t);for(let n=0;n<t;n++)r[n]=e[i+n];let a="avc1.";for(let e=1;e<4;e++){let t=r[e].toString(16);t.length<2&&(t="0"+t),a+=t}n.codec=a,i+=t,this.tracks.videoTrack.meta.sps=r,s=o.SpsParser.parseSPS(r)}let u=e[i];i++;for(let t=0;t<u;t++){let t=255*e[i]+e[i+1];i+=2;let n=new Uint8Array(t);for(let r=0;r<t;r++)n[r]=e[i+r];i+=t,this.tracks.videoTrack.meta.pps=n}Object.assign(n,o.SpsParser.toVideoMeta(s));const l=this._context.mediaInfo.video;l.codec=n.codec,l.profile=n.profile,l.level=n.level,l.chromaFormat=n.chromaFormat,l.frameRate=n.frameRate,l.parRatio=n.parRatio,l.width=l.width===n.presentWidth?l.width:n.presentWidth,l.height=l.height===n.presentHeight?l.width:n.presentHeight,n.duration=this._context.mediaInfo.duration*n.timescale,n.avcc=new Uint8Array(e.length),n.avcc.set(e),t.meta=n}},{key:"_switchAudioSampleRate",value:function(e){return[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350][e]}},{key:"_switchAudioSamplingFrequency",value:function(e){return[5500,11025,22050,44100,48e3][(12&e)>>>2]}},{key:"_switchAudioChannel",value:function(e){return[1,2][1&e]}},{key:"_datasizeValidator",value:function(e){let t=this.loaderBuffer.toInt(0,4);return this.loaderBuffer.shift(4),t===e+11}},{key:"loaderBuffer",get:function(){const e=this._context.getInstance("LOADER_BUFFER");if(e)return e;this.emit(c.DEMUX_ERROR,new Error("找不到 loaderBuffer 实例"))}},{key:"tracks",get:function(){return this._context.getInstance("TRACKS")}},{key:"logger",get:function(){return this._context.getInstance("LOGGER")}}],[{key:"isFlvFile",value:function(e){return!(70!==e[0]||76!==e[1]||86!==e[2]||1!==e[3])}},{key:"getPlayType",value:function(e){const t={hasVideo:!1,hasAudio:!1};return!0&e&&(t.hasVideo=!0),!0&e&&(t.hasAudio=!0),t}}]),e}();t.default=f},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),r=i(0);const a={NUMBER:0,BOOLEAN:1,STRING:2,OBJECT:3,MIX_ARRAY:8,OBJECT_END:9,STRICT_ARRAY:10,DATE:11,LONE_STRING:12};let o=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.offset=0,this.readOffset=this.offset}return n(e,[{key:"resolve",value:function(e,t){if(t<3)throw new Error("not enough data for metainfo");const i={},n=this.parseValue(e),r=this.parseValue(e,t-n.bodySize);return i[n.data]=r.data,this.resetStatus(),i}},{key:"resetStatus",value:function(){this.offset=0,this.readOffset=this.offset}},{key:"parseString",value:function(e){const t=new DataView(e,this.readOffset).getUint16(0,!r.isLe);let i="";i=t>0?r.UTF8.decode(new Uint8Array(e,this.readOffset+2,t)):"";let n=t+2;return this.readOffset+=n,{data:i,bodySize:t+2}}},{key:"parseDate",value:function(e,t){const i=new DataView(e,this.readOffset,t);let n=i.getFloat64(0,!r.isLe);return n+=60*i.getInt16(8,!r.isLe)*1e3,this.readOffset+=10,{data:new Date(n),bodySize:10}}},{key:"parseObject",value:function(e,t){const i=this.parseString(e,t),n=this.parseValue(e,t-i.bodySize);return{data:{name:i.data,value:n.data},bodySize:i.bodySize+n.bodySize,isObjEnd:n.isObjEnd}}},{key:"parseLongString",value:function(e){const t=new DataView(e,this.readOffset).getUint32(0,!r.isLe);let i="";return i=t>0?r.UTF8.decode(new Uint8Array(e,this.readOffset+2,t)):"",this.readOffset+=t+4,{data:i,bodySize:t+4}}},{key:"parseValue",value:function(e,t){let i=new ArrayBuffer;i=e instanceof ArrayBuffer?e:e.buffer;const{NUMBER:n,BOOLEAN:o,STRING:s,OBJECT:u,MIX_ARRAY:l,OBJECT_END:c,STRICT_ARRAY:f,DATE:h,LONE_STRING:d}=a,p=new DataView(i,this.readOffset,t);let y=!1;const m=p.getUint8(0);let v=1;this.readOffset+=1;let g=null;switch(m){case n:g=p.getFloat64(1,!r.isLe),this.readOffset+=8,v+=8;break;case o:g=!!p.getUint8(1),this.readOffset+=1,v+=1;break;case s:{const e=this.parseString(i);g=e.data,v+=e.bodySize;break}case u:{g={};let e=0;for(16777215&p.getUint32(t-4,!r.isLe)&&(e=3);v<t-4;){const n=this.parseObject(i,t-v-e);if(n.isObjectEnd)break;g[n.data.name]=n.data.value,v+=n.bodySize}if(v<=t-3){9===(16777215&p.getUint32(v-1,!r.isLe))&&(this.readOffset+=3,v+=3)}break}case l:{g={},v+=4,this.readOffset+=4;let e=0;for(9==(16777215&p.getUint32(t-4,!r.isLe))&&(e=3);v<t-8;){const n=this.parseObject(i,t-v-e);if(n.isObjectEnd)break;g[n.data.name]=n.data.value,v+=n.bodySize}if(v<=t-3){9===(16777215&p.getUint32(v-1,!r.isLe))&&(v+=3,this.readOffset+=3)}break}case c:g=null,y=!0;break;case f:{g=[];const e=p.getUint32(1,!r.isLe);v+=4,this.readOffset+=4;for(let n=0;n<e;n++){const e=this.parseValue(i,t-v);g.push(e.data),v+=e.bodySize}break}case h:{const e=this.parseDate(i,t-1);g=e.data,v+=e.bodySize;break}case d:{const e=this.parseLongString(i,t-1);g=e.data,v+=e.bodySize;break}default:v=t}return{data:g,bodySize:v,isObjEnd:y}}}]),e}();t.default=o},,,,function(e,t,i){i(56),i(57),e.exports=i(58)},function(e,t,i){"use strict";(function(){var e=window.Document.prototype.createElement,t=window.Document.prototype.createElementNS,i=window.Document.prototype.importNode,n=window.Document.prototype.prepend,r=window.Document.prototype.append,a=window.DocumentFragment.prototype.prepend,o=window.DocumentFragment.prototype.append,s=window.Node.prototype.cloneNode,u=window.Node.prototype.appendChild,l=window.Node.prototype.insertBefore,c=window.Node.prototype.removeChild,f=window.Node.prototype.replaceChild,h=Object.getOwnPropertyDescriptor(window.Node.prototype,"textContent"),d=window.Element.prototype.attachShadow,p=Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),y=window.Element.prototype.getAttribute,m=window.Element.prototype.setAttribute,v=window.Element.prototype.removeAttribute,g=window.Element.prototype.getAttributeNS,_=window.Element.prototype.setAttributeNS,b=window.Element.prototype.removeAttributeNS,E=window.Element.prototype.insertAdjacentElement,w=window.Element.prototype.insertAdjacentHTML,k=window.Element.prototype.prepend,T=window.Element.prototype.append,A=window.Element.prototype.before,S=window.Element.prototype.after,x=window.Element.prototype.replaceWith,D=window.Element.prototype.remove,O=window.HTMLElement,C=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),R=window.HTMLElement.prototype.insertAdjacentElement,L=window.HTMLElement.prototype.insertAdjacentHTML,M=new Set;function U(e){var t=M.has(e);return e=/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(e),!t&&e}"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" ").forEach((function(e){return M.add(e)}));var P=document.contains?document.contains.bind(document):document.documentElement.contains.bind(document.documentElement);function B(e){var t=e.isConnected;if(void 0!==t)return t;if(P(e))return!0;for(;e&&!(e.__CE_isImportDocument||e instanceof Document);)e=e.parentNode||(window.ShadowRoot&&e instanceof ShadowRoot?e.host:void 0);return!(!e||!(e.__CE_isImportDocument||e instanceof Document))}function I(e){var t=e.children;if(t)return Array.prototype.slice.call(t);for(t=[],e=e.firstChild;e;e=e.nextSibling)e.nodeType===Node.ELEMENT_NODE&&t.push(e);return t}function j(e,t){for(;t&&t!==e&&!t.nextSibling;)t=t.parentNode;return t&&t!==e?t.nextSibling:null}function F(e,t,i){e[t]=i}function N(e){var t=document;this.c=e,this.a=t,this.b=void 0,te(this.c,this.a),"loading"===this.a.readyState&&(this.b=new MutationObserver(this.f.bind(this)),this.b.observe(this.a,{childList:!0,subtree:!0}))}function V(e){e.b&&e.b.disconnect()}function G(){var e=this;this.b=this.a=void 0,this.c=new Promise((function(t){e.b=t,e.a&&t(e.a)}))}function z(e){if(e.a)throw Error("Already resolved.");e.a=void 0,e.b&&e.b(void 0)}function H(e){this.f=new Map,this.g=new Map,this.l=new Map,this.i=!1,this.b=e,this.j=new Map,this.c=function(e){return e()},this.a=!1,this.h=[],this.m=e.f?new N(e):void 0}function X(e,t){if(!U(t))throw new SyntaxError("The element name '"+t+"' is not valid.");if(Y(e,t))throw Error("A custom element with name '"+t+"' has already been defined.");if(e.i)throw Error("A custom element is already being defined.")}function W(e,t,i){var n;e.i=!0;try{var r=function(e){var t=a[e];if(void 0!==t&&!(t instanceof Function))throw Error("The '"+e+"' callback must be a function.");return t},a=i.prototype;if(!(a instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");var o=r("connectedCallback"),s=r("disconnectedCallback"),u=r("adoptedCallback"),l=(n=r("attributeChangedCallback"))&&i.observedAttributes||[]}catch(e){throw e}finally{e.i=!1}return i={localName:t,constructorFunction:i,connectedCallback:o,disconnectedCallback:s,adoptedCallback:u,attributeChangedCallback:n,observedAttributes:l,constructionStack:[]},e.g.set(t,i),e.l.set(i.constructorFunction,i),i}function q(e){if(!1!==e.a){e.a=!1;for(var t=[],i=e.h,n=new Map,r=0;r<i.length;r++)n.set(i[r],[]);for(te(e.b,document,{upgrade:function(i){if(void 0===i.__CE_state){var r=i.localName,a=n.get(r);a?a.push(i):e.g.has(r)&&t.push(i)}}}),r=0;r<t.length;r++)ie(e.b,t[r]);for(r=0;r<i.length;r++){for(var a=i[r],o=n.get(a),s=0;s<o.length;s++)ie(e.b,o[s]);(a=e.j.get(a))&&z(a)}i.length=0}}function Y(e,t){var i=e.g.get(t);if(i)return i;if(i=e.f.get(t)){e.f.delete(t);try{return W(e,t,i())}catch(e){re(e)}}}function K(){var e=ue&&ue.noDocumentConstructionObserver,t=ue&&ue.shadyDomFastWalk;this.b=[],this.c=[],this.a=!1,this.shadyDomFastWalk=t,this.f=!e}function $(e,t,i,n){var r=window.ShadyDOM;if(e.shadyDomFastWalk&&r&&r.inUse){if(t.nodeType===Node.ELEMENT_NODE&&i(t),t.querySelectorAll)for(e=r.nativeMethods.querySelectorAll.call(t,"*"),t=0;t<e.length;t++)i(e[t])}else!function e(t,i,n){for(var r=t;r;){if(r.nodeType===Node.ELEMENT_NODE){var a=r;i(a);var o=a.localName;if("link"===o&&"import"===a.getAttribute("rel")){if(r=a.import,void 0===n&&(n=new Set),r instanceof Node&&!n.has(r))for(n.add(r),r=r.firstChild;r;r=r.nextSibling)e(r,i,n);r=j(t,a);continue}if("template"===o){r=j(t,a);continue}if(a=a.__CE_shadowRoot)for(a=a.firstChild;a;a=a.nextSibling)e(a,i,n)}r=r.firstChild?r.firstChild:j(t,r)}}(t,i,n)}function J(e,t){e.a&&$(e,t,(function(t){return Z(e,t)}))}function Z(e,t){if(e.a&&!t.__CE_patched){t.__CE_patched=!0;for(var i=0;i<e.b.length;i++)e.b[i](t);for(i=0;i<e.c.length;i++)e.c[i](t)}}function Q(e,t){var i=[];for($(e,t,(function(e){return i.push(e)})),t=0;t<i.length;t++){var n=i[t];1===n.__CE_state?e.connectedCallback(n):ie(e,n)}}function ee(e,t){var i=[];for($(e,t,(function(e){return i.push(e)})),t=0;t<i.length;t++){var n=i[t];1===n.__CE_state&&e.disconnectedCallback(n)}}function te(e,t,i){var n=(i=void 0===i?{}:i).s,r=i.upgrade||function(t){return ie(e,t)},a=[];for($(e,t,(function(t){if(e.a&&Z(e,t),"link"===t.localName&&"import"===t.getAttribute("rel")){var i=t.import;i instanceof Node&&(i.__CE_isImportDocument=!0,i.__CE_registry=document.__CE_registry),i&&"complete"===i.readyState?i.__CE_documentLoadHandled=!0:t.addEventListener("load",(function(){var i=t.import;if(!i.__CE_documentLoadHandled){i.__CE_documentLoadHandled=!0;var a=new Set;n&&(n.forEach((function(e){return a.add(e)})),a.delete(i)),te(e,i,{s:a,upgrade:r})}}))}else a.push(t)}),n),t=0;t<a.length;t++)r(a[t])}function ie(e,t){try{var i=t.ownerDocument,n=i.__CE_registry,r=n&&(i.defaultView||i.__CE_isImportDocument)?Y(n,t.localName):void 0;if(r&&void 0===t.__CE_state){r.constructionStack.push(t);try{try{if(new r.constructorFunction!==t)throw Error("The custom element constructor did not produce the element being upgraded.")}finally{r.constructionStack.pop()}}catch(e){throw t.__CE_state=2,e}if(t.__CE_state=1,t.__CE_definition=r,r.attributeChangedCallback&&t.hasAttributes()){var a=r.observedAttributes;for(r=0;r<a.length;r++){var o=a[r],s=t.getAttribute(o);null!==s&&e.attributeChangedCallback(t,o,null,s,null)}}B(t)&&e.connectedCallback(t)}}catch(e){re(e)}}function ne(i,n,r,a){var o=n.__CE_registry;if(o&&(null===a||"http://www.w3.org/1999/xhtml"===a)&&(o=Y(o,r)))try{var s=new o.constructorFunction;if(void 0===s.__CE_state||void 0===s.__CE_definition)throw Error("Failed to construct '"+r+"': The returned value was not constructed with the HTMLElement constructor.");if("http://www.w3.org/1999/xhtml"!==s.namespaceURI)throw Error("Failed to construct '"+r+"': The constructed element's namespace must be the HTML namespace.");if(s.hasAttributes())throw Error("Failed to construct '"+r+"': The constructed element must not have any attributes.");if(null!==s.firstChild)throw Error("Failed to construct '"+r+"': The constructed element must not have any children.");if(null!==s.parentNode)throw Error("Failed to construct '"+r+"': The constructed element must not have a parent node.");if(s.ownerDocument!==n)throw Error("Failed to construct '"+r+"': The constructed element's owner document is incorrect.");if(s.localName!==r)throw Error("Failed to construct '"+r+"': The constructed element's local name is incorrect.");return s}catch(o){return re(o),n=null===a?e.call(n,r):t.call(n,a,r),Object.setPrototypeOf(n,HTMLUnknownElement.prototype),n.__CE_state=2,n.__CE_definition=void 0,Z(i,n),n}return Z(i,n=null===a?e.call(n,r):t.call(n,a,r)),n}function re(e){var t=e.message,i=e.sourceURL||e.fileName||"",n=e.line||e.lineNumber||0,r=e.column||e.columnNumber||0,a=void 0;void 0===ErrorEvent.prototype.initErrorEvent?a=new ErrorEvent("error",{cancelable:!0,message:t,filename:i,lineno:n,colno:r,error:e}):((a=document.createEvent("ErrorEvent")).initErrorEvent("error",!1,!0,t,i,n),a.preventDefault=function(){Object.defineProperty(this,"defaultPrevented",{configurable:!0,get:function(){return!0}})}),void 0===a.error&&Object.defineProperty(a,"error",{configurable:!0,enumerable:!0,get:function(){return e}}),window.dispatchEvent(a),a.defaultPrevented||console.error(e)}N.prototype.f=function(e){var t=this.a.readyState;for("interactive"!==t&&"complete"!==t||V(this),t=0;t<e.length;t++)for(var i=e[t].addedNodes,n=0;n<i.length;n++)te(this.c,i[n])},H.prototype.o=function(e,t){var i=this;if(!(t instanceof Function))throw new TypeError("Custom element constructor getters must be functions.");X(this,e),this.f.set(e,t),this.h.push(e),this.a||(this.a=!0,this.c((function(){return q(i)})))},H.prototype.define=function(e,t){var i=this;if(!(t instanceof Function))throw new TypeError("Custom element constructors must be functions.");X(this,e),W(this,e,t),this.h.push(e),this.a||(this.a=!0,this.c((function(){return q(i)})))},H.prototype.upgrade=function(e){te(this.b,e)},H.prototype.get=function(e){if(e=Y(this,e))return e.constructorFunction},H.prototype.whenDefined=function(e){if(!U(e))return Promise.reject(new SyntaxError("'"+e+"' is not a valid custom element name."));var t=this.j.get(e);if(t)return t.c;t=new G,this.j.set(e,t);var i=this.g.has(e)||this.f.has(e);return e=-1===this.h.indexOf(e),i&&e&&z(t),t.c},H.prototype.polyfillWrapFlushCallback=function(e){this.m&&V(this.m);var t=this.c;this.c=function(i){return e((function(){return t(i)}))}},window.CustomElementRegistry=H,H.prototype.define=H.prototype.define,H.prototype.upgrade=H.prototype.upgrade,H.prototype.get=H.prototype.get,H.prototype.whenDefined=H.prototype.whenDefined,H.prototype.polyfillDefineLazy=H.prototype.o,H.prototype.polyfillWrapFlushCallback=H.prototype.polyfillWrapFlushCallback,K.prototype.connectedCallback=function(e){var t=e.__CE_definition;if(t.connectedCallback)try{t.connectedCallback.call(e)}catch(e){re(e)}},K.prototype.disconnectedCallback=function(e){var t=e.__CE_definition;if(t.disconnectedCallback)try{t.disconnectedCallback.call(e)}catch(e){re(e)}},K.prototype.attributeChangedCallback=function(e,t,i,n,r){var a=e.__CE_definition;if(a.attributeChangedCallback&&-1<a.observedAttributes.indexOf(t))try{a.attributeChangedCallback.call(e,t,i,n,r)}catch(e){re(e)}};var ae=new function(){};function oe(e,t,i){function n(t){return function(i){for(var n=[],r=0;r<arguments.length;++r)n[r]=arguments[r];r=[];for(var a=[],o=0;o<n.length;o++){var s=n[o];if(s instanceof Element&&B(s)&&a.push(s),s instanceof DocumentFragment)for(s=s.firstChild;s;s=s.nextSibling)r.push(s);else r.push(s)}for(t.apply(this,n),n=0;n<a.length;n++)ee(e,a[n]);if(B(this))for(n=0;n<r.length;n++)(a=r[n])instanceof Element&&Q(e,a)}}void 0!==i.prepend&&F(t,"prepend",n(i.prepend)),void 0!==i.append&&F(t,"append",n(i.append))}function se(e){function i(t,i){Object.defineProperty(t,"innerHTML",{enumerable:i.enumerable,configurable:!0,get:i.get,set:function(t){var n=this,r=void 0;if(B(this)&&(r=[],$(e,this,(function(e){e!==n&&r.push(e)}))),i.set.call(this,t),r)for(var a=0;a<r.length;a++){var o=r[a];1===o.__CE_state&&e.disconnectedCallback(o)}return this.ownerDocument.__CE_registry?te(e,this):J(e,this),t}})}function n(t,i){F(t,"insertAdjacentElement",(function(t,n){var r=B(n);return t=i.call(this,t,n),r&&ee(e,n),B(t)&&Q(e,n),t}))}function r(t,i){function n(t,i){for(var n=[];t!==i;t=t.nextSibling)n.push(t);for(i=0;i<n.length;i++)te(e,n[i])}F(t,"insertAdjacentHTML",(function(e,t){if("beforebegin"===(e=e.toLowerCase())){var r=this.previousSibling;i.call(this,e,t),n(r||this.parentNode.firstChild,this)}else if("afterbegin"===e)r=this.firstChild,i.call(this,e,t),n(this.firstChild,r);else if("beforeend"===e)r=this.lastChild,i.call(this,e,t),n(r||this.firstChild,null);else{if("afterend"!==e)throw new SyntaxError("The value provided ("+String(e)+") is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'.");r=this.nextSibling,i.call(this,e,t),n(this.nextSibling,r)}}))}d&&F(Element.prototype,"attachShadow",(function(t){if(t=d.call(this,t),e.a&&!t.__CE_patched){t.__CE_patched=!0;for(var i=0;i<e.b.length;i++)e.b[i](t)}return this.__CE_shadowRoot=t})),p&&p.get?i(Element.prototype,p):C&&C.get?i(HTMLElement.prototype,C):function(e,t){e.a=!0,e.c.push(t)}(e,(function(e){i(e,{enumerable:!0,configurable:!0,get:function(){return s.call(this,!0).innerHTML},set:function(e){var i="template"===this.localName,n=i?this.content:this,r=t.call(document,this.namespaceURI,this.localName);for(r.innerHTML=e;0<n.childNodes.length;)c.call(n,n.childNodes[0]);for(e=i?r.content:r;0<e.childNodes.length;)u.call(n,e.childNodes[0])}})})),F(Element.prototype,"setAttribute",(function(t,i){if(1!==this.__CE_state)return m.call(this,t,i);var n=y.call(this,t);m.call(this,t,i),i=y.call(this,t),e.attributeChangedCallback(this,t,n,i,null)})),F(Element.prototype,"setAttributeNS",(function(t,i,n){if(1!==this.__CE_state)return _.call(this,t,i,n);var r=g.call(this,t,i);_.call(this,t,i,n),n=g.call(this,t,i),e.attributeChangedCallback(this,i,r,n,t)})),F(Element.prototype,"removeAttribute",(function(t){if(1!==this.__CE_state)return v.call(this,t);var i=y.call(this,t);v.call(this,t),null!==i&&e.attributeChangedCallback(this,t,i,null,null)})),F(Element.prototype,"removeAttributeNS",(function(t,i){if(1!==this.__CE_state)return b.call(this,t,i);var n=g.call(this,t,i);b.call(this,t,i);var r=g.call(this,t,i);n!==r&&e.attributeChangedCallback(this,i,n,r,t)})),R?n(HTMLElement.prototype,R):E&&n(Element.prototype,E),L?r(HTMLElement.prototype,L):w&&r(Element.prototype,w),oe(e,Element.prototype,{prepend:k,append:T}),function(e){function t(t){return function(i){for(var n=[],r=0;r<arguments.length;++r)n[r]=arguments[r];r=[];for(var a=[],o=0;o<n.length;o++){var s=n[o];if(s instanceof Element&&B(s)&&a.push(s),s instanceof DocumentFragment)for(s=s.firstChild;s;s=s.nextSibling)r.push(s);else r.push(s)}for(t.apply(this,n),n=0;n<a.length;n++)ee(e,a[n]);if(B(this))for(n=0;n<r.length;n++)(a=r[n])instanceof Element&&Q(e,a)}}var i=Element.prototype;void 0!==A&&F(i,"before",t(A)),void 0!==S&&F(i,"after",t(S)),void 0!==x&&F(i,"replaceWith",(function(t){for(var i=[],n=0;n<arguments.length;++n)i[n]=arguments[n];n=[];for(var r=[],a=0;a<i.length;a++){var o=i[a];if(o instanceof Element&&B(o)&&r.push(o),o instanceof DocumentFragment)for(o=o.firstChild;o;o=o.nextSibling)n.push(o);else n.push(o)}for(a=B(this),x.apply(this,i),i=0;i<r.length;i++)ee(e,r[i]);if(a)for(ee(e,this),i=0;i<n.length;i++)(r=n[i])instanceof Element&&Q(e,r)})),void 0!==D&&F(i,"remove",(function(){var t=B(this);D.call(this),t&&ee(e,this)}))}(e)}var ue=window.customElements;function le(){var t=new K;!function(t){window.HTMLElement=function(){function i(){var i=this.constructor,n=document.__CE_registry.l.get(i);if(!n)throw Error("Failed to construct a custom element: The constructor was not registered with `customElements`.");var r=n.constructionStack;if(0===r.length)return r=e.call(document,n.localName),Object.setPrototypeOf(r,i.prototype),r.__CE_state=1,r.__CE_definition=n,Z(t,r),r;var a=r.length-1,o=r[a];if(o===ae)throw Error("Failed to construct '"+n.localName+"': This element was already constructed.");return r[a]=ae,Object.setPrototypeOf(o,i.prototype),Z(t,o),o}return i.prototype=O.prototype,Object.defineProperty(i.prototype,"constructor",{writable:!0,configurable:!0,enumerable:!1,value:i}),i}()}(t),function(e){F(Document.prototype,"createElement",(function(t){return ne(e,this,t,null)})),F(Document.prototype,"importNode",(function(t,n){return t=i.call(this,t,!!n),this.__CE_registry?te(e,t):J(e,t),t})),F(Document.prototype,"createElementNS",(function(t,i){return ne(e,this,i,t)})),oe(e,Document.prototype,{prepend:n,append:r})}(t),oe(t,DocumentFragment.prototype,{prepend:a,append:o}),function(e){function t(t,i){Object.defineProperty(t,"textContent",{enumerable:i.enumerable,configurable:!0,get:i.get,set:function(t){if(this.nodeType===Node.TEXT_NODE)i.set.call(this,t);else{var n=void 0;if(this.firstChild){var r=this.childNodes,a=r.length;if(0<a&&B(this)){n=Array(a);for(var o=0;o<a;o++)n[o]=r[o]}}if(i.set.call(this,t),n)for(t=0;t<n.length;t++)ee(e,n[t])}}})}F(Node.prototype,"insertBefore",(function(t,i){if(t instanceof DocumentFragment){var n=I(t);if(t=l.call(this,t,i),B(this))for(i=0;i<n.length;i++)Q(e,n[i]);return t}return n=t instanceof Element&&B(t),i=l.call(this,t,i),n&&ee(e,t),B(this)&&Q(e,t),i})),F(Node.prototype,"appendChild",(function(t){if(t instanceof DocumentFragment){var i=I(t);if(t=u.call(this,t),B(this))for(var n=0;n<i.length;n++)Q(e,i[n]);return t}return i=t instanceof Element&&B(t),n=u.call(this,t),i&&ee(e,t),B(this)&&Q(e,t),n})),F(Node.prototype,"cloneNode",(function(t){return t=s.call(this,!!t),this.ownerDocument.__CE_registry?te(e,t):J(e,t),t})),F(Node.prototype,"removeChild",(function(t){var i=t instanceof Element&&B(t),n=c.call(this,t);return i&&ee(e,t),n})),F(Node.prototype,"replaceChild",(function(t,i){if(t instanceof DocumentFragment){var n=I(t);if(t=f.call(this,t,i),B(this))for(ee(e,i),i=0;i<n.length;i++)Q(e,n[i]);return t}n=t instanceof Element&&B(t);var r=f.call(this,t,i),a=B(this);return a&&ee(e,i),n&&ee(e,t),a&&Q(e,t),r})),h&&h.get?t(Node.prototype,h):function(e,t){e.a=!0,e.b.push(t)}(e,(function(e){t(e,{enumerable:!0,configurable:!0,get:function(){for(var e=[],t=this.firstChild;t;t=t.nextSibling)t.nodeType!==Node.COMMENT_NODE&&e.push(t.textContent);return e.join("")},set:function(e){for(;this.firstChild;)c.call(this,this.firstChild);null!=e&&""!==e&&u.call(this,document.createTextNode(e))}})}))}(t),se(t),t=new H(t),document.__CE_registry=t,Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:t})}ue&&!ue.forcePolyfill&&"function"==typeof ue.define&&"function"==typeof ue.get||le(),window.__CE_installPolyfill=le}).call(self)},function(e,t,i){"use strict";
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */!function(){if(void 0===window.Reflect||void 0===window.customElements||window.customElements.polyfillWrapFlushCallback)return;const e=HTMLElement,t=function(){return Reflect.construct(e,[],this.constructor)};window.HTMLElement=t,HTMLElement.prototype=e.prototype,HTMLElement.prototype.constructor=HTMLElement,Object.setPrototypeOf(HTMLElement,e)}()},function(e,t,i){"use strict";var n=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),r=function e(t,i,n){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,i);if(void 0===r){var a=Object.getPrototypeOf(t);return null===a?void 0:e(a,i,n)}if("value"in r)return r.value;var o=r.get;return void 0!==o?o.call(n):void 0},a=u(i(5)),o=i(0),s=u(i(59));function u(e){return e&&e.__esModule?e:{default:e}}const l=o.EVENTS.FlvAllowedEvents;let c=function(e){function t(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),e.mediaType||(e.mediaType="mobile-video");var i=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return i.video.width=Number.parseInt(e.width||600),i.video.height=Number.parseInt(e.height||337.5),i.video.style.outline="none",i.context=new o.Context(l),i.initEvents(),i}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(t,e),n(t,[{key:"start",value:function(){this.initFlv(),this.context.init(),this.flv.seek(0),r(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"start",this).call(this,this.config.url),this.play()}},{key:"initFlvEvents",value:function(e){const t=this;e.once(o.EVENTS.REMUX_EVENTS.INIT_SEGMENT,()=>{if(a.default.util.addClass(t.root,"xgplayer-is-live"),!a.default.util.findDom(this.root,"xg-live")){const e=a.default.util.createDom("xg-live","正在直播",{},"xgplayer-live");t.controls.appendChild(e)}}),e.once(o.EVENTS.LOADER_EVENTS.LOADER_COMPLETE,()=>{if(!t.paused){const e=setInterval(()=>{const i=t.getBufferedRange()[1];Math.abs(t.currentTime-i)<.5&&(t.emit("ended"),window.clearInterval(e))},200)}}),e.on(o.EVENTS.BROWSER_EVENTS.VISIBILITY_CHANGE,e=>{e&&this.pause()})}},{key:"initEvents",value:function(){this.on("timeupdate",()=>{this.loadData()}),this.on("seeking",()=>{const e=this.currentTime,t=this.getBufferedRange();(e>t[1]||e<t[0])&&this.flv.seek(this.currentTime)})}},{key:"initFlv",value:function(){const e=this.context.registry("FLV_CONTROLLER",s.default)(this);this.initFlvEvents(e),this.flv=e}},{key:"play",value:function(){if(this._hasStart&&this.paused){this._destroy(),this.context=new o.Context(l);const e=this.context.registry("FLV_CONTROLLER",s.default)(this);this.initFlvEvents(e),this.flv=e,this.context.init(),this.loadData(),r(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"start",this).call(this),r(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"play",this).call(this)}else r(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"play",this).call(this),this.addLiveFlag()}},{key:"pause",value:function(){r(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"pause",this).call(this),this.flv&&this.flv.pause()}},{key:"loadData",value:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.currentTime;this.flv&&this.flv.seek(e)}},{key:"destroy",value:function(){this._destroy(),r(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this)}},{key:"addLiveFlag",value:function(){const e=this;if(a.default.util.addClass(e.root,"xgplayer-is-live"),!a.default.util.findDom(this.root,"xg-live")){const t=a.default.util.createDom("xg-live","正在直播",{},"xgplayer-live");e.controls.appendChild(t)}}},{key:"_destroy",value:function(){this.context.destroy(),this.flv=null,this.context=null}},{key:"src",get:function(){return this.currentSrc},set:function(e){this.player.config.url=e,this.paused?this.start(e):(this.pause(),this.once("pause",()=>{this.start(e)}),this.once("canplay",()=>{this.play()})),this.once("canplay",()=>{this.currentTime=0})}}]),t}(a.default);e.exports=c},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),a=i(41),o=i(43),s=i(38),u=i(4),l=i(0),c=i(3),f=i(5),h=(n=f)&&n.__esModule?n:{default:n};function d(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}const p=l.EVENTS.DEMUX_EVENTS,y=l.EVENTS.LOADER_EVENTS,m=(l.EVENTS.BROWSER_EVENTS,"FLVController");let v=function(){function e(){d(this,e)}return r(e,[{key:"warn",value:function(){}}]),e}(),g=function(){function e(t){d(this,e),this.TAG=m,this._player=t,this.video=this._player.video,this.state={initSegmentArrived:!1}}return r(e,[{key:"init",value:function(){this._context.registry("FETCH_LOADER",a.FetchLoader),this._context.registry("LOADER_BUFFER",u.XgBuffer),this._context.registry("PRE_SOURCE_BUFFER",u.PreSource),this._context.registry("FLV_DEMUXER",o.FlvDemuxer),this._context.registry("MP4_REMUXER",s.Mp4Remuxer),this._context.registry("TRACKS",u.Tracks),this._context.registry("COMPATIBILITY",c.Compatibility),this._context.registry("PAGE_VISIBILITY",l.PageVisibility),this._context.registry("LOGGER",v),this.initListeners()}},{key:"initListeners",value:function(){this.on(y.LOADER_DATALOADED,this._handleLoaderDataLoaded.bind(this)),this.on(y.LOADER_ERROR,this._handleNetworkError.bind(this)),this.on(p.MEDIA_INFO,this._handleMediaInfo.bind(this)),this.on(p.METADATA_PARSED,this._handleMetadataParsed.bind(this)),this.on(p.DEMUX_COMPLETE,this._handleDemuxComplete.bind(this)),this.on(p.DEMUX_ERROR,this._handleDemuxError.bind(this))}},{key:"_handleMediaInfo",value:function(){this._context.mediaInfo||this.emit(p.DEMUX_ERROR,new Error("failed to get mediainfo"))}},{key:"_handleLoaderDataLoaded",value:function(){this.emitTo("FLV_DEMUXER",p.DEMUX_START)}},{key:"_handleMetadataParsed",value:function(e){if("audio"===e){const{audioTrack:e}=this._context.getInstance("TRACKS");e&&e.meta&&this._setMetaToAudio(e.meta)}else{const{videoTrack:e}=this._context.getInstance("TRACKS");e&&e.meta&&this._setMetaToVideo(e.meta)}}},{key:"_handleDemuxComplete",value:function(){if(this._player.video){const{videoTrack:e,audioTrack:t}=this._context.getInstance("TRACKS");this._player.video.onDemuxComplete(e,t)}}},{key:"_handleAppendInitSegment",value:function(){this.state.initSegmentArrived=!0}},{key:"_handleNetworkError",value:function(){this._player.emit("error",new h.default.Errors("network",this._player.config.url))}},{key:"_handleDemuxError",value:function(){this._player.emit("error",new h.default.Errors("parse",this._player.config.url))}},{key:"_setMetaToAudio",value:function(e){this._player.video&&this._player.video.setAudioMeta(e)}},{key:"_setMetaToVideo",value:function(e){this._player.video&&this._player.video.setVideoMeta(e)}},{key:"seek",value:function(){this.state.initSegmentArrived||this.loadData()}},{key:"loadData",value:function(){this.emit(y.LADER_START,this._player.config.url)}},{key:"pause",value:function(){const e=this._context.getInstance("FETCH_LOADER");e&&e.cancel()}}],[{key:"resolveVideoGOP",value:function(e){const{samples:t}=e;if(!t.length)return;let i=null,n=null;e.tempSamples&&e.tempSamples.length&&t.unshift.apply(t,e.tempSamples);for(let e=0,n=t.length;e<n;e++){if(t[e].isKeyframe){i=e;break}}for(let e=t.length-1;e>0;e++){if(t[e].isKeyframe){n=e;break}}0!==i&&t.splice(0,i-1),e.samples=t.slice(0,n);const r=t.slice(n);e.tempSamples?e.tempSamples.push.apply(e.tempSamples,r):e.tempSamples=r}}]),e}();t.default=g}])}));
>>>>>>> 6568d0dd7c2d795ab5b1bd65773d4c1f5f98fc06
